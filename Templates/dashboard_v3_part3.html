<script>
    // Executive View filter helper
    function getFilteredExecItems() {
        const teamFilter = document.getElementById('exec-team-filter')?.value || 'all';
        const typeFilter = document.getElementById('exec-type-filter')?.value || 'all';
        
        let items = workItems;
        
        if (teamFilter !== 'all') {
            items = items.filter(w => w.team === teamFilter);
        }
        
        if (typeFilter !== 'all') {
            items = items.filter(w => w.type === typeFilter);
        }
        
        return items;
    }
    
    function applyExecFilters() {
        saveStateToStorage();
        renderExecutiveView();
    }
    
    // Executive View
    function renderExecutiveView() {
        const stats = document.getElementById('exec-stats');
        const insights = document.getElementById('exec-insights');
        const charts = document.getElementById('exec-charts');
        
        const filteredItems = getFilteredExecItems();
        const teamFilter = document.getElementById('exec-team-filter')?.value || 'all';
        const typeFilter = document.getElementById('exec-type-filter')?.value || 'all';
        const isFiltered = teamFilter !== 'all' || typeFilter !== 'all';
        
        // Calculate metrics
        const total = filteredItems.length;
        const done = filteredItems.filter(w => w.state === 'Done' || w.state === 'Closed').length;
        const inProgress = filteredItems.filter(w => w.state === 'In Progress').length;
        const bugs = filteredItems.filter(w => w.type === 'Bug');
        const openBugs = bugs.filter(b => b.state !== 'Done' && b.state !== 'Closed' && b.state !== 'Removed');
        const blocked = filteredItems.filter(w => (w.tags || '').toLowerCase().includes('blocked'));
        const unassigned = filteredItems.filter(w => !w.assignedTo && w.state !== 'Done' && w.state !== 'Closed' && w.state !== 'Removed');
        
        const filterNote = isFiltered ? ' (filtered)' : '';
        
        stats.innerHTML = `
            <div class="stat-card clickable" onclick="drilldownStat('total')">
                <div class="stat-label">Total Work Items${filterNote}</div>
                <div class="stat-value" style="color: var(--accent-cyan)">${total}</div>
                <div class="stat-subtitle">${done} completed (${total > 0 ? Math.round(done/total*100) : 0}%)</div>
            </div>
            <div class="stat-card clickable" onclick="drilldownStat('inProgress')">
                <div class="stat-label">In Progress</div>
                <div class="stat-value" style="color: var(--accent-blue)">${inProgress}</div>
                <div class="stat-subtitle">Active work items</div>
            </div>
            <div class="stat-card clickable" onclick="drilldownStat('openBugs')">
                <div class="stat-label">Open Bugs</div>
                <div class="stat-value" style="color: var(--accent-red)">${openBugs.length}</div>
                <div class="stat-subtitle">${bugs.length} total bugs</div>
            </div>
            <div class="stat-card clickable" onclick="drilldownStat('blocked')">
                <div class="stat-label">Blocked Items</div>
                <div class="stat-value" style="color: var(--accent-orange)">${blocked.length}</div>
                <div class="stat-subtitle">Need attention</div>
            </div>
            <div class="stat-card clickable" onclick="drilldownStat('unassigned')">
                <div class="stat-label">Unassigned</div>
                <div class="stat-value" style="color: var(--text-muted)">${unassigned.length}</div>
                <div class="stat-subtitle">Active items without owner</div>
            </div>
        `;
        
        // Key insights
        const novemberItems = filteredItems.filter(w => (w.iterationPath || '').includes('CY2025Q4-Nov'));
        const novemberDone = novemberItems.filter(w => w.state === 'Done' || w.state === 'Closed').length;
        const novemberPct = novemberItems.length > 0 ? Math.round(novemberDone / novemberItems.length * 100) : 0;
        const novemberRemaining = novemberItems.length - novemberDone;
        
        // Find most loaded person
        const assigneeCounts = countBy(filteredItems.filter(w => w.assignedTo && w.state !== 'Done' && w.state !== 'Closed'), 'assignedTo');
        const topAssignee = Object.entries(assigneeCounts).sort((a, b) => b[1] - a[1])[0];
        
        insights.innerHTML = `
            <div class="insights-title">‚ö° Key Insights${filterNote}</div>
            ${novemberItems.length > 0 ? `
            <div class="insight-item ${novemberPct < 60 ? 'warning' : ''}">
                <span class="insight-icon">${novemberPct < 60 ? '‚ö†Ô∏è' : 'üìä'}</span> 
                November completion at ${novemberPct}% (${novemberRemaining} items remaining of ${novemberItems.length})
            </div>
            ` : ''}
            <div class="insight-item critical"><span class="insight-icon">üî¥</span> ${openBugs.length} open bugs need resolution</div>
            <div class="insight-item warning"><span class="insight-icon">üë§</span> ${unassigned.length} active items without owners</div>
            <div class="insight-item warning"><span class="insight-icon">üö´</span> ${blocked.length} items are blocked</div>
            ${topAssignee ? `<div class="insight-item info"><span class="insight-icon">üìã</span> ${topAssignee[0]} has ${topAssignee[1]} active items assigned</div>` : ''}
        `;
        
        // Charts - sorted by value
        const byType = sortObjectByValue(countBy(filteredItems, 'type'));
        const byState = sortObjectByValue(countBy(filteredItems, 'state'));
        const byTeam = sortObjectByValue(countBy(filteredItems.filter(w => w.team && w.team !== 'eShare'), 'team'));
        
        // Get all unique values for filters
        const allTypes = Object.keys(byType);
        const allStates = ['New', 'Triaged', 'To Do', 'In Progress', 'Ready For Review', 'Done', 'Closed', 'Removed'];
        const allTeams = Object.keys(byTeam);
        
        // Apply chart filters
        const chartFilteredItems = getExecChartFilteredItems(filteredItems);
        const filteredByType = sortObjectByValue(countBy(chartFilteredItems, 'type'));
        const filteredByState = sortObjectByValue(countBy(chartFilteredItems, 'state'));
        const filteredByTeam = sortObjectByValue(countBy(chartFilteredItems.filter(w => w.team && w.team !== 'eShare'), 'team'));
        
        charts.innerHTML = `
            <div class="chart-card">
                <div class="chart-title">Work Items by Type</div>
                <div class="chart-container"><canvas id="exec-type-chart"></canvas></div>
                <div class="chart-filter">
                    <div class="multi-select-dropdown" id="exec-chart-type-dropdown">
                        <div class="multi-select-display" onclick="toggleExecFilter('type')">
                            <span id="exec-chart-type-display">All Types</span>
                            <span class="dropdown-arrow">‚ñº</span>
                        </div>
                        <div class="multi-select-options" id="exec-chart-type-options">
                            <label class="checkbox-option select-all-option"><input type="checkbox" id="exec-chart-type-select-all" onchange="toggleAllExecFilter('type', this.checked)"> <strong>Select All</strong></label>
                            <div class="checkbox-divider"></div>
                            ${allTypes.map(t => `<label class="checkbox-option"><input type="checkbox" value="${t}" onchange="updateExecFilter('type')"> ${t}</label>`).join('')}
                        </div>
                    </div>
                </div>
            </div>
            <div class="chart-card">
                <div class="chart-title">Work Items by State</div>
                <div class="chart-container"><canvas id="exec-state-chart"></canvas></div>
                <div class="chart-filter">
                    <div class="multi-select-dropdown" id="exec-chart-state-dropdown">
                        <div class="multi-select-display" onclick="toggleExecFilter('state')">
                            <span id="exec-chart-state-display">All States</span>
                            <span class="dropdown-arrow">‚ñº</span>
                        </div>
                        <div class="multi-select-options" id="exec-chart-state-options">
                            <label class="checkbox-option select-all-option"><input type="checkbox" id="exec-chart-state-select-all" onchange="toggleAllExecFilter('state', this.checked)"> <strong>Select All</strong></label>
                            <div class="checkbox-divider"></div>
                            ${allStates.map(s => `<label class="checkbox-option"><input type="checkbox" value="${s}" onchange="updateExecFilter('state')"> ${s}</label>`).join('')}
                        </div>
                    </div>
                </div>
            </div>
            <div class="chart-card">
                <div class="chart-title">Work Items by Team</div>
                <div class="chart-container"><canvas id="exec-team-chart"></canvas></div>
                <div class="chart-filter">
                    <div class="multi-select-dropdown" id="exec-chart-team-dropdown">
                        <div class="multi-select-display" onclick="toggleExecFilter('team')">
                            <span id="exec-chart-team-display">All Teams</span>
                            <span class="dropdown-arrow">‚ñº</span>
                        </div>
                        <div class="multi-select-options" id="exec-chart-team-options">
                            <label class="checkbox-option select-all-option"><input type="checkbox" id="exec-chart-team-select-all" onchange="toggleAllExecFilter('team', this.checked)"> <strong>Select All</strong></label>
                            <div class="checkbox-divider"></div>
                            ${allTeams.map(t => `<label class="checkbox-option"><input type="checkbox" value="${t}" onchange="updateExecFilter('team')"> ${t}</label>`).join('')}
                        </div>
                    </div>
                </div>
            </div>
        `;
        
        // Restore filter states after HTML rebuild
        restoreExecFilterStates();
        
        setTimeout(() => {
            createClickableChart('exec-type-chart', 'doughnut', filteredByType, 'type', null, chartFilteredItems);
            createClickableChart('exec-state-chart', 'doughnut', filteredByState, 'state', colors.states, chartFilteredItems);
            createClickableChart('exec-team-chart', 'bar', filteredByTeam, 'team', colors.teams, chartFilteredItems);
        }, 50);
    }
    
    function drilldownStat(statType) {
        const filteredItems = getFilteredExecItems();
        let items, title;
        
        switch(statType) {
            case 'total':
                items = filteredItems;
                title = 'All Work Items';
                break;
            case 'inProgress':
                items = filteredItems.filter(w => w.state === 'In Progress');
                title = 'In Progress Items';
                break;
            case 'openBugs':
                items = filteredItems.filter(w => w.type === 'Bug' && w.state !== 'Done' && w.state !== 'Closed' && w.state !== 'Removed');
                title = 'Open Bugs';
                break;
            case 'blocked':
                items = filteredItems.filter(w => (w.tags || '').toLowerCase().includes('blocked'));
                title = 'Blocked Items';
                break;
            case 'unassigned':
                items = filteredItems.filter(w => !w.assignedTo && w.state !== 'Done' && w.state !== 'Closed' && w.state !== 'Removed');
                title = 'Unassigned Active Items';
                break;
            default:
                return;
        }
        
        showDrilldown(title, items, getSliceFields(items));
    }
    
    // Team Lead View
    function renderTeamLeadView() {
        const stats = document.getElementById('team-stats');
        const insights = document.getElementById('team-insights');
        const charts = document.getElementById('team-charts');
        
        const teams = ['Frontend', 'Backend', 'QA', 'DevOps', 'Analytics', 'Govern', 'SCG', 'Staff'];
        
        // Team leads mapping (based on Org Chart)
        const teamLeads = {
            'Frontend': 'Andreas Davros',
            'Backend': 'Thanos Terzis',
            'QA': 'Kostas Tzoulas',
            'DevOps': 'Christos Sidiropoulos',
            'Analytics': 'Maya Dahan',
            'Govern': 'Maya Dahan',
            'SCG': 'Alexandros Papadakis',
            'Staff': 'John Paglierani',
            'Security & Compliance': 'Chakra Bokissam',
            'Customer Success': ''
        };
        
        // Get time-filtered items, then apply dropdown filters
        const timeFilteredItems = getActiveWorkItemsForPeriod(workItems, selectedTimePeriod);
        const filteredItems = getTeamLeadChartFilteredItems(timeFilteredItems);
        
        // Calculate stats based on fully filtered items
        const teamStats = teams.map(team => {
            const teamItems = filteredItems.filter(w => w.team === team);
            
            // Completed = items in Done/Closed state
            const completed = teamItems.filter(w => w.state === 'Done' || w.state === 'Closed').length;
            const active = teamItems.filter(w => w.state !== 'Done' && w.state !== 'Closed' && w.state !== 'Removed').length;
            const total = teamItems.length;
            const pct = total > 0 ? Math.round(completed / total * 100) : 0;
            
            // Calculate effort from filtered items
            const effort = teamItems.reduce((sum, w) => sum + (w.effort || 0), 0);
            
            // Count by type from filtered items
            const byType = {};
            teamItems.forEach(w => {
                byType[w.type] = (byType[w.type] || 0) + 1;
            });
            
            return { team, total, completed, active, pct, effort, byType, lead: teamLeads[team] };
        });
        
        const periodLabel = {
            'all': 'All Time',
            'quarter': 'This Quarter',
            'lastmonth': 'Last Month',
            'month': 'This Month',
            'lastweek': 'Last Week',
            'week': 'This Week'
        }[selectedTimePeriod];
        
        // Calculate "All Teams" totals
        const allTeamsTotal = teamStats.reduce((sum, t) => sum + t.total, 0);
        const allTeamsCompleted = teamStats.reduce((sum, t) => sum + t.completed, 0);
        const allTeamsActive = teamStats.reduce((sum, t) => sum + t.active, 0);
        const allTeamsEffort = teamStats.reduce((sum, t) => sum + t.effort, 0);
        const allTeamsPct = allTeamsTotal > 0 ? Math.round(allTeamsCompleted / allTeamsTotal * 100) : 0;
        
        // Aggregate type breakdown for All Teams
        const allTeamsByType = {};
        teamStats.forEach(t => {
            Object.entries(t.byType).forEach(([type, count]) => {
                allTeamsByType[type] = (allTeamsByType[type] || 0) + count;
            });
        });
        const allTeamsTypeBreakdown = Object.entries(allTeamsByType)
            .sort((a, b) => b[1] - a[1])
            .slice(0, 3)
            .map(([type, count]) => `${count} ${type}${count > 1 ? 's' : ''}`)
            .join(', ');
        
        // Get lead photos from leadPhotos object (defined in part4)
        const allTeamsCard = `
            <div class="stat-card team-stat-card clickable all-teams-card" onclick="expandTeamDetails('All Teams')">
                <div class="stat-label">All Teams</div>
                <div class="stat-value" style="color: var(--accent-cyan)">${allTeamsTotal}</div>
                <div class="stat-subtitle">${allTeamsCompleted} done ‚Ä¢ ${allTeamsActive} active</div>
                <div class="stat-subtitle" style="font-size: 0.65rem; color: var(--text-muted);">${allTeamsTypeBreakdown}</div>
            </div>
        `;
        
        stats.innerHTML = allTeamsCard + teamStats.map(t => {
            const leadPhoto = typeof leadPhotos !== 'undefined' && leadPhotos[t.lead] ? 
                `<img src="data:image/jpeg;base64,${leadPhotos[t.lead]}" class="team-lead-photo" alt="${t.lead}">` : 
                '';
            const typeBreakdown = Object.entries(t.byType)
                .sort((a, b) => b[1] - a[1])
                .slice(0, 3)
                .map(([type, count]) => `${count} ${type}${count > 1 ? 's' : ''}`)
                .join(', ');
            
            return `
                <div class="stat-card team-stat-card clickable" onclick="expandTeamDetails('${t.team}')">
                    <div class="stat-label">${t.team}</div>
                    <div class="stat-value" style="color: ${colors.teams[t.team] || 'var(--accent-cyan)'}">${t.total}</div>
                    <div class="stat-subtitle">${t.completed} done ‚Ä¢ ${t.active} active</div>
                    <div class="stat-subtitle" style="font-size: 0.65rem; color: var(--text-muted);">${typeBreakdown}</div>
                    ${t.lead ? `
                        <div class="team-lead-info">
                            ${leadPhoto}
                            <span class="team-lead-name">${t.lead}</span>
                        </div>
                    ` : ''}
                </div>
            `;
        }).join('');
        
        // Key insights for Team Lead (use filtered items)
        const mostLoadedTeam = teamStats.sort((a, b) => b.active - a.active)[0];
        const lowestCompletion = [...teamStats].sort((a, b) => a.pct - b.pct)[0];
        
        // Find individual with most items (from filtered items)
        const activeFilteredItems = filteredItems.filter(w => w.assignedTo && w.state !== 'Done' && w.state !== 'Closed' && w.state !== 'Removed');
        const byAssignee = countBy(activeFilteredItems, 'assignedTo');
        const sortedAssignees = Object.entries(byAssignee).sort((a, b) => b[1] - a[1]);
        const topAssignees = sortedAssignees.slice(0, 3);
        
        // Items completed this week (from filtered items based on period)
        const completedInPeriod = filteredItems.filter(w => w.state === 'Done' || w.state === 'Closed').length;
        
        insights.innerHTML = `
            <div class="insights-title">‚ö° Team Insights (${periodLabel})</div>
            <div class="insights-content">
                <div class="insight-item info"><span class="insight-icon">üìà</span> ${completedInPeriod} items completed in ${periodLabel.toLowerCase()}</div>
                <div class="insight-item warning"><span class="insight-icon">‚ö†Ô∏è</span> ${mostLoadedTeam.team} has the most active work (${mostLoadedTeam.active} items)</div>
                <div class="insight-item ${lowestCompletion.pct < 50 ? 'critical' : 'warning'}">
                    <span class="insight-icon">${lowestCompletion.pct < 50 ? 'üî¥' : 'üìä'}</span> 
                    ${lowestCompletion.team} has lowest completion rate (${lowestCompletion.pct}%)
                </div>
                ${topAssignees.map((a, i) => `
                    <div class="insight-item ${a[1] > 100 ? 'critical' : a[1] > 50 ? 'warning' : 'info'}">
                        <span class="insight-icon">${a[1] > 100 ? 'üö®' : 'üë§'}</span> 
                        ${a[0]} has ${a[1]} active items ${a[1] > 100 ? '(overloaded!)' : ''}
                    </div>
                `).join('')}
            </div>
        `;
        
        charts.innerHTML = `
            <div class="chart-card">
                <div class="chart-title">Team Completion Rates (${periodLabel})</div>
                <div class="chart-container"><canvas id="team-completion-chart"></canvas></div>
            </div>
            <div class="chart-card">
                <div class="chart-title">Active Work by Team (${periodLabel})</div>
                <div class="chart-container"><canvas id="team-active-chart"></canvas></div>
            </div>
            <div class="chart-card">
                <div class="chart-title">Effort by Team (${periodLabel})</div>
                <div class="chart-container"><canvas id="team-effort-chart"></canvas></div>
            </div>
        `;
        
        // Get unique values for distribution chart filters (from all items for filter options)
        const allTypes = [...new Set(workItems.map(w => w.type))].sort();
        const allStatesForTeam = ['New', 'Triaged', 'To Do', 'In Progress', 'Ready For Review', 'Done', 'Closed', 'Removed'];
        const allAssignees = [...new Set(workItems.map(w => w.assignedTo || '(Unassigned)'))].sort();
        const allPriorities = [...new Set(workItems.map(w => String(w.priority || '(Not Set)')))].sort();
        const allIterations = [...new Set(workItems.map(w => w.iterationPath || '(Not Set)'))].sort();
        
        // Use the same filtered items for distribution charts
        const chartFilteredItems = filteredItems;
        
        // Add distribution charts section
        const iterationOptionsHtml = allIterations.slice(0, 15).map(function(i) { const label = i.includes("\\") ? i.split("\\").pop() : i; return '<label class="checkbox-option"><input type="checkbox" value="' + i + '" onchange="updateTeamLeadChartFilter(\'iteration\')"> ' + label + '</label>'; }).join("");
        const distributionChartsHtml = `
            <div class="section-divider" style="margin-top: 2rem;">
                <h3>Work Item Distribution</h3>
            </div>
            <div class="charts-grid" id="team-distribution-charts">
                <div class="chart-card">
                    <div class="chart-title">Items by Type</div>
                    <div class="chart-container"><canvas id="teamlead-type-chart"></canvas></div>
                    <div class="chart-filter">
                        <div class="multi-select-dropdown" id="teamlead-chart-type-dropdown">
                            <div class="multi-select-display" onclick="toggleTeamLeadChartFilter('type')">
                                <span id="teamlead-chart-type-display">All Types</span>
                                <span class="dropdown-arrow">‚ñº</span>
                            </div>
                            <div class="multi-select-options" id="teamlead-chart-type-options">
                                <label class="checkbox-option select-all-option"><input type="checkbox" id="teamlead-chart-type-select-all" onchange="toggleAllTeamLeadChartFilter('type', this.checked)"> <strong>Select All</strong></label>
                                <div class="checkbox-divider"></div>
                                ${allTypes.map(t => `<label class="checkbox-option"><input type="checkbox" value="${t}" onchange="updateTeamLeadChartFilter('type')"> ${t}</label>`).join('')}
                            </div>
                        </div>
                    </div>
                </div>
                <div class="chart-card">
                    <div class="chart-title">Items by State</div>
                    <div class="chart-container"><canvas id="teamlead-state-chart"></canvas></div>
                    <div class="chart-filter">
                        <div class="multi-select-dropdown" id="teamlead-chart-state-dropdown">
                            <div class="multi-select-display" onclick="toggleTeamLeadChartFilter('state')">
                                <span id="teamlead-chart-state-display">All States</span>
                                <span class="dropdown-arrow">‚ñº</span>
                            </div>
                            <div class="multi-select-options" id="teamlead-chart-state-options">
                                <label class="checkbox-option select-all-option"><input type="checkbox" id="teamlead-chart-state-select-all" onchange="toggleAllTeamLeadChartFilter('state', this.checked)"> <strong>Select All</strong></label>
                                <div class="checkbox-divider"></div>
                                ${allStatesForTeam.map(s => `<label class="checkbox-option"><input type="checkbox" value="${s}" onchange="updateTeamLeadChartFilter('state')"> ${s}</label>`).join('')}
                            </div>
                        </div>
                    </div>
                </div>
                <div class="chart-card">
                    <div class="chart-title">Items by Assignee</div>
                    <div class="chart-container"><canvas id="teamlead-assignee-chart"></canvas></div>
                    <div class="chart-filter">
                        <div class="multi-select-dropdown" id="teamlead-chart-assignee-dropdown">
                            <div class="multi-select-display" onclick="toggleTeamLeadChartFilter('assignee')">
                                <span id="teamlead-chart-assignee-display">All Assignees</span>
                                <span class="dropdown-arrow">‚ñº</span>
                            </div>
                            <div class="multi-select-options" id="teamlead-chart-assignee-options">
                                <label class="checkbox-option select-all-option"><input type="checkbox" id="teamlead-chart-assignee-select-all" onchange="toggleAllTeamLeadChartFilter('assignee', this.checked)"> <strong>Select All</strong></label>
                                <div class="checkbox-divider"></div>
                                ${allAssignees.slice(0, 20).map(a => `<label class="checkbox-option"><input type="checkbox" value="${a}" onchange="updateTeamLeadChartFilter('assignee')"> ${a}</label>`).join('')}
                            </div>
                        </div>
                    </div>
                </div>
                <div class="chart-card">
                    <div class="chart-title">Items by Priority</div>
                    <div class="chart-container"><canvas id="teamlead-priority-chart"></canvas></div>
                    <div class="chart-filter">
                        <div class="multi-select-dropdown" id="teamlead-chart-priority-dropdown">
                            <div class="multi-select-display" onclick="toggleTeamLeadChartFilter('priority')">
                                <span id="teamlead-chart-priority-display">All Priorities</span>
                                <span class="dropdown-arrow">‚ñº</span>
                            </div>
                            <div class="multi-select-options" id="teamlead-chart-priority-options">
                                <label class="checkbox-option select-all-option"><input type="checkbox" id="teamlead-chart-priority-select-all" onchange="toggleAllTeamLeadChartFilter('priority', this.checked)"> <strong>Select All</strong></label>
                                <div class="checkbox-divider"></div>
                                ${allPriorities.map(p => `<label class="checkbox-option"><input type="checkbox" value="${p}" onchange="updateTeamLeadChartFilter('priority')"> ${p}</label>`).join('')}
                            </div>
                        </div>
                    </div>
                </div>
                <div class="chart-card">
                    <div class="chart-title">Items by Iteration</div>
                    <div class="chart-container"><canvas id="teamlead-iteration-chart"></canvas></div>
                    <div class="chart-filter">
                        <div class="multi-select-dropdown" id="teamlead-chart-iteration-dropdown">
                            <div class="multi-select-display" onclick="toggleTeamLeadChartFilter('iteration')">
                                <span id="teamlead-chart-iteration-display">All Iterations</span>
                                <span class="dropdown-arrow">‚ñº</span>
                            </div>
                            <div class="multi-select-options" id="teamlead-chart-iteration-options">
                                <label class="checkbox-option select-all-option"><input type="checkbox" id="teamlead-chart-iteration-select-all" onchange="toggleAllTeamLeadChartFilter('iteration', this.checked)"> <strong>Select All</strong></label>
                                <div class="checkbox-divider"></div>
                                ${iterationOptionsHtml}
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        `;
        document.getElementById('team-distribution-section').innerHTML = distributionChartsHtml;
        
        // Restore filter states
        restoreTeamLeadChartFilterStates();
        
        setTimeout(() => {
            // Sort by completion rate for display
            const sortedByCompletion = [...teamStats].sort((a, b) => b.pct - a.pct);
            
            createChart('team-completion-chart', 'bar', {
                labels: sortedByCompletion.map(t => t.team),
                datasets: [{
                    label: 'Completion %',
                    data: sortedByCompletion.map(t => t.pct),
                    backgroundColor: sortedByCompletion.map(t => colors.teams[t.team] || colors.primary[0])
                }]
            }, {
                scales: {
                    x: { ticks: { color: '#94a3b8' }, grid: { color: '#334155' } },
                    y: { 
                        ticks: { color: '#94a3b8' }, 
                        grid: { color: '#334155' }, 
                        max: 100,
                        title: { display: true, text: 'Completion %', color: '#94a3b8' }
                    }
                }
            });
            
            const sortedByActive = [...teamStats].sort((a, b) => b.active - a.active);
            createChart('team-active-chart', 'bar', {
                labels: sortedByActive.map(t => t.team),
                datasets: [{
                    label: 'Active Items',
                    data: sortedByActive.map(t => t.active),
                    backgroundColor: sortedByActive.map(t => colors.teams[t.team] || colors.primary[0])
                }]
            }, {
                scales: {
                    x: { ticks: { color: '#94a3b8' }, grid: { color: '#334155' } },
                    y: { 
                        ticks: { color: '#94a3b8' }, 
                        grid: { color: '#334155' },
                        title: { display: true, text: 'Count', color: '#94a3b8' }
                    }
                }
            });
            
            const sortedByEffort = [...teamStats].sort((a, b) => b.effort - a.effort);
            createChart('team-effort-chart', 'bar', {
                labels: sortedByEffort.map(t => t.team),
                datasets: [{
                    label: 'Effort (days)',
                    data: sortedByEffort.map(t => t.effort.toFixed(1)),
                    backgroundColor: sortedByEffort.map(t => colors.teams[t.team] || colors.primary[0])
                }]
            }, {
                scales: {
                    x: { ticks: { color: '#94a3b8' }, grid: { color: '#334155' } },
                    y: { 
                        ticks: { color: '#94a3b8' }, 
                        grid: { color: '#334155' },
                        title: { display: true, text: 'Days', color: '#94a3b8' }
                    }
                }
            });
            
            // Distribution charts
            const byType = sortObjectByValue(countBy(chartFilteredItems, 'type'));
            createChart('teamlead-type-chart', 'doughnut', {
                labels: Object.keys(byType),
                datasets: [{ data: Object.values(byType), backgroundColor: colors.primary }]
            });
            
            const byState = sortObjectByValue(countBy(chartFilteredItems, 'state'));
            createChart('teamlead-state-chart', 'doughnut', {
                labels: Object.keys(byState),
                datasets: [{ data: Object.values(byState), backgroundColor: Object.keys(byState).map(s => colors.states[s] || colors.primary[0]) }]
            });
            
            const byAssignee = sortObjectByValue(countBy(chartFilteredItems.filter(w => w.assignedTo), 'assignedTo'));
            const topAssigneesChart = Object.fromEntries(Object.entries(byAssignee).slice(0, 10));
            createChart('teamlead-assignee-chart', 'doughnut', {
                labels: Object.keys(topAssigneesChart),
                datasets: [{ data: Object.values(topAssigneesChart), backgroundColor: colors.primary }]
            });
            
            const byPriority = sortObjectByValue(countBy(chartFilteredItems, 'priority'));
            createChart('teamlead-priority-chart', 'doughnut', {
                labels: Object.keys(byPriority).map(p => p ? `Priority ${p}` : '(Not Set)'),
                datasets: [{ data: Object.values(byPriority), backgroundColor: [colors.priority['1'], colors.priority['2'], colors.priority['3'], colors.priority['4'], '#64748b'] }]
            });
            
            const byIteration = sortObjectByValue(countBy(chartFilteredItems, 'iterationPath'));
            const topIterations = Object.fromEntries(Object.entries(byIteration).slice(0, 8));
            const iterationLabels = Object.keys(topIterations).map(i => {
                if (!i) return '(Not Set)';
                const parts = i.split('\\');
                return parts[parts.length - 1] || i;
            });
            createChart('teamlead-iteration-chart', 'doughnut', {
                labels: iterationLabels,
                datasets: [{ data: Object.values(topIterations), backgroundColor: colors.primary }]
            });
        }, 50);
    }
    
    function drilldownTeam(team) {
        const items = workItems.filter(w => w.team === team);
        showDrilldown(`Team: ${team}`, items, getSliceFields(items));
    }
    
    // ==================== CUSTOMERS VIEW (Issues Only) ====================

    // Customers View filter state
    let customersFilters = {
        search: '',
        customers: [],
        categories: [],
        states: [],
        priorities: [],
        releases: [],
        aging: []
    };

    // Customers View sort state (null = use default sort from config)
    let customersSortState = {
        column: null,
        direction: 'asc'
    };

    // Default sort state for reset
    const defaultCustomersSortState = {
        column: null,  // null means use default (aging)
        direction: 'asc'
    };

    // Customers View column widths (persisted)
    let customersColumnWidths = {};

    // Column resize state
    let resizeState = {
        isResizing: false,
        didResize: false,  // Track if an actual resize occurred
        startX: 0,
        startWidth: 0,
        th: null,
        handle: null
    };

    // Start column resize
    function startCustomersColumnResize(e, handle) {
        e.preventDefault();
        e.stopPropagation();

        const th = handle.parentElement;
        resizeState = {
            isResizing: true,
            didResize: false,
            startX: e.pageX,
            startWidth: th.offsetWidth,
            th: th,
            handle: handle
        };

        handle.classList.add('resizing');
        document.addEventListener('mousemove', doCustomersColumnResize);
        document.addEventListener('mouseup', stopCustomersColumnResize);
    }

    // Perform column resize
    function doCustomersColumnResize(e) {
        if (!resizeState.isResizing) return;

        const diff = e.pageX - resizeState.startX;
        // Only mark as resized if user moved more than 3 pixels
        if (Math.abs(diff) > 3) {
            resizeState.didResize = true;
        }
        const newWidth = Math.max(50, resizeState.startWidth + diff);
        resizeState.th.style.width = newWidth + 'px';
    }

    // Stop column resize and save
    function stopCustomersColumnResize(e) {
        if (!resizeState.isResizing) return;

        const colKey = resizeState.th.getAttribute('data-col');
        const newWidth = resizeState.th.offsetWidth;

        if (colKey && resizeState.didResize) {
            customersColumnWidths[colKey] = newWidth;
            saveStateToStorage();
        }

        resizeState.handle.classList.remove('resizing');
        resizeState.isResizing = false;

        // Prevent the click event from firing if we actually resized
        if (resizeState.didResize) {
            // Set a brief timeout to block the click handler
            setTimeout(() => { resizeState.didResize = false; }, 50);
        }

        document.removeEventListener('mousemove', doCustomersColumnResize);
        document.removeEventListener('mouseup', stopCustomersColumnResize);
    }

    // Wrapper for sort that checks if we just finished resizing
    function sortCustomersTableIfNotResizing(column) {
        if (resizeState.didResize) return;
        sortCustomersTable(column);
    }

    // Aging buckets in display order
    const AGING_BUCKETS = ['1 day', '1 week', '2 weeks', '4 weeks', 'Older', 'TBD'];

    // Helper to parse date string to midnight local time (strips time component)
    function parseToLocalDate(dateStr) {
        if (!dateStr) return null;
        // Extract just the date part (YYYY-MM-DD) regardless of format
        const datePart = dateStr.split('T')[0];
        // Parse as local date at midnight
        const [year, month, day] = datePart.split('-').map(Number);
        return new Date(year, month - 1, day);
    }

    // Calculate aging bucket for an issue (based on DAX logic)
    function calculateAgingBucket(issue) {
        const state = issue.state;
        const createdDate = issue.createdDate;
        const closedDate = issue.closedDate;

        // Check for null/missing values
        const hasError = !state || !createdDate ||
            ((state === 'Closed' || state === 'Done') && !closedDate);

        if (hasError) return 'TBD';

        // Calculate age in days
        let ageDays;
        const today = new Date();
        today.setHours(0, 0, 0, 0);

        if (state === 'New' || state === 'To Do' || state === 'In Progress' || state === 'Triaged' || state === 'Ready For Review') {
            // Open states: days since created
            const created = parseToLocalDate(createdDate);
            ageDays = Math.floor((today - created) / (1000 * 60 * 60 * 24));
        } else if (state === 'Closed' || state === 'Done') {
            // Closed states: days from created to closed
            const created = parseToLocalDate(createdDate);
            const closed = parseToLocalDate(closedDate);
            ageDays = Math.floor((closed - created) / (1000 * 60 * 60 * 24));
        } else {
            // Unexpected state (Removed, etc.)
            return 'TBD';
        }

        // Return the appropriate bucket
        if (ageDays <= 1) return '1 day';
        if (ageDays <= 7) return '1 week';
        if (ageDays <= 14) return '2 weeks';
        if (ageDays <= 28) return '4 weeks';
        return 'Older';
    }

    // Calculate age in days for sorting
    function calculateAgeDays(issue) {
        const state = issue.state;
        const createdDate = issue.createdDate;
        const closedDate = issue.closedDate;

        if (!state || !createdDate) return -1;

        const today = new Date();
        today.setHours(0, 0, 0, 0);

        if (state === 'Closed' || state === 'Done') {
            if (!closedDate) return -1;
            const created = parseToLocalDate(createdDate);
            const closed = parseToLocalDate(closedDate);
            return Math.floor((closed - created) / (1000 * 60 * 60 * 24));
        } else if (state === 'Removed') {
            return -1;
        } else {
            const created = parseToLocalDate(createdDate);
            return Math.floor((today - created) / (1000 * 60 * 60 * 24));
        }
    }

    // Get all Issues (the base dataset for Customers view)
    function getAllIssues() {
        return workItems.filter(w => w.type === 'Issue');
    }

    // Get filtered Issues based on current filter state
    function getFilteredIssues() {
        let issues = getAllIssues();

        // Apply search filter using generic component
        issues = applyGenericSearchFilter(issues, customersFilters.search);

        // Apply customer filter
        if (customersFilters.customers.length > 0) {
            issues = issues.filter(i => {
                if (!i.customers) return customersFilters.customers.includes('(No Customer)');
                const itemCustomers = i.customers.split(';').map(c => c.trim());
                return itemCustomers.some(c => customersFilters.customers.includes(c));
            });
        }

        // Apply category filter
        if (customersFilters.categories.length > 0) {
            issues = issues.filter(i => {
                const category = i.ticketCategory || '(Not Set)';
                return customersFilters.categories.includes(category);
            });
        }

        // Apply state filter
        if (customersFilters.states.length > 0) {
            issues = issues.filter(i => customersFilters.states.includes(i.state));
        }

        // Apply priority filter
        if (customersFilters.priorities.length > 0) {
            issues = issues.filter(i => {
                const priority = i.priority ? 'P' + i.priority : '(No Priority)';
                return customersFilters.priorities.includes(priority);
            });
        }

        // Apply release filter
        if (customersFilters.releases.length > 0) {
            issues = issues.filter(i => {
                // Determine release category: actual release, "(Needs Release)", or "(No Release)"
                let releaseCategory;
                if (i.releaseVersion && i.releaseVersion.trim()) {
                    releaseCategory = i.releaseVersion.trim();
                } else {
                    releaseCategory = i.targetDate ? '(Needs Release)' : '(No Release)';
                }
                return customersFilters.releases.includes(releaseCategory);
            });
        }

        // Apply aging filter
        if (customersFilters.aging.length > 0) {
            issues = issues.filter(i => {
                const aging = calculateAgingBucket(i);
                return customersFilters.aging.includes(aging);
            });
        }

        return issues;
    }

    /**
     * Get Customers issues filtered by all filters EXCEPT the specified one
     * Used for cross-filter dropdown population
     * @param {string} excludeFilter - Filter to exclude: 'priority', 'release', 'customer', 'state', 'categories', 'aging'
     */
    function getCustomersIssuesExcludingFilter(excludeFilter) {
        let issues = getAllIssues();

        // Always apply search filter
        issues = applyGenericSearchFilter(issues, customersFilters.search);

        // Apply customer filter (unless excluded)
        if (excludeFilter !== 'customer' && customersFilters.customers.length > 0) {
            issues = issues.filter(i => {
                if (!i.customers) return customersFilters.customers.includes('(No Customer)');
                const itemCustomers = i.customers.split(';').map(c => c.trim());
                return itemCustomers.some(c => customersFilters.customers.includes(c));
            });
        }

        // Apply category filter (unless excluded)
        if (excludeFilter !== 'categories' && customersFilters.categories.length > 0) {
            issues = issues.filter(i => {
                const category = i.ticketCategory || '(Not Set)';
                return customersFilters.categories.includes(category);
            });
        }

        // Apply state filter (unless excluded) - accept both 'state' and 'states' for compatibility
        if (excludeFilter !== 'state' && excludeFilter !== 'states' && customersFilters.states.length > 0) {
            issues = issues.filter(i => customersFilters.states.includes(i.state));
        }

        // Apply priority filter (unless excluded)
        if (excludeFilter !== 'priority' && customersFilters.priorities.length > 0) {
            issues = issues.filter(i => {
                const priority = i.priority ? 'P' + i.priority : '(No Priority)';
                return customersFilters.priorities.includes(priority);
            });
        }

        // Apply release filter (unless excluded)
        if (excludeFilter !== 'release' && customersFilters.releases.length > 0) {
            issues = issues.filter(i => {
                let releaseCategory;
                if (i.releaseVersion && i.releaseVersion.trim()) {
                    releaseCategory = i.releaseVersion.trim();
                } else {
                    releaseCategory = i.targetDate ? '(Needs Release)' : '(No Release)';
                }
                return customersFilters.releases.includes(releaseCategory);
            });
        }

        // Apply aging filter (unless excluded)
        if (excludeFilter !== 'aging' && customersFilters.aging.length > 0) {
            issues = issues.filter(i => {
                const aging = calculateAgingBucket(i);
                return customersFilters.aging.includes(aging);
            });
        }

        return issues;
    }

    // Check if any filters are active
    function hasActiveCustomersFilters() {
        return hasGenericSearchFilter('customers') ||
               customersFilters.customers.length > 0 ||
               customersFilters.categories.length > 0 ||
               customersFilters.states.length > 0 ||
               customersFilters.priorities.length > 0 ||
               customersFilters.releases.length > 0 ||
               customersFilters.aging.length > 0;
    }

    // Clear all filters
    function clearAllCustomersFilters() {
        // Clear search using generic component
        clearGenericSearch('customers');

        // Clear all filter arrays
        customersFilters.customers = [];
        customersFilters.categories = [];
        customersFilters.states = [];
        customersFilters.priorities = [];
        customersFilters.releases = [];
        customersFilters.aging = [];

        saveStateToStorage();
        renderCustomersView();
        populateCustomersFilterDropdowns();
    }

    // Update clear button visibility
    function updateCustomersClearButton() {
        const clearBtn = document.getElementById('customers-clear-filters-btn');
        if (clearBtn) {
            clearBtn.classList.toggle('hidden', !hasActiveCustomersFilters());
        }
    }

    // Filter dropdown search helper
    function filterCustomersDropdownOptions(inputEl, menuId) {
        const searchValue = inputEl.value.toLowerCase();
        const options = document.querySelectorAll(`#${menuId} .filter-dropdown-option:not(.select-all)`);
        options.forEach(opt => {
            const label = opt.textContent.toLowerCase();
            opt.style.display = label.includes(searchValue) ? '' : 'none';
        });
    }

    // Build dropdown HTML with search, options, and action buttons
    function buildCustomersDropdownHtml(filterType, items, selectedItems) {
        const menuId = getCustomersMenuId(filterType);
        const selectAllId = getCustomersSelectAllId(filterType);

        let html = `
            <div class="filter-dropdown-search">
                <input type="text" placeholder="Search..." oninput="filterCustomersDropdownOptions(this, '${menuId}')" onclick="event.stopPropagation();">
            </div>
            <div class="filter-dropdown-options" id="${menuId}-options">
        `;

        items.forEach(item => {
            const isChecked = selectedItems.includes(item);
            const escapedItem = item.replace(/"/g, '&quot;').replace(/'/g, "\\'");
            html += `
                <label class="filter-dropdown-option" data-search-value="${item.toLowerCase()}" onclick="event.stopPropagation();">
                    <input type="checkbox" value="${escapedItem}" ${isChecked ? 'checked' : ''} onchange="updateCustomersFilter('${filterType}')">
                    <span class="option-label">${item}</span>
                </label>
            `;
        });

        html += `</div>`;
        html += `
            <div class="filter-dropdown-actions">
                <button class="filter-btn-primary" onclick="selectAllCustomersFilter('${filterType}', event)">Select All</button>
                <button class="filter-btn-secondary" onclick="clearCustomersFilter('${filterType}', event)">Clear</button>
            </div>
        `;

        return html;
    }

    // Build release dropdown HTML with version + date (like Releases dashboard)
    function buildCustomersReleaseDropdownHtml(releaseInfo, releases, noReleaseCount, selectedItems) {
        const menuId = 'customers-release-menu';

        let html = `
            <div class="filter-dropdown-search">
                <input type="text" placeholder="Search..." oninput="filterCustomersDropdownOptions(this, '${menuId}')" onclick="event.stopPropagation();">
            </div>
            <div class="filter-dropdown-options" id="${menuId}-options">
        `;

        // (No Release) option at the TOP
        if (noReleaseCount > 0) {
            const isChecked = selectedItems.includes('(No Release)');
            html += `
                <label class="filter-dropdown-option" data-search-value="no release" onclick="event.stopPropagation();">
                    <input type="checkbox" value="(No Release)" ${isChecked ? 'checked' : ''} onchange="updateCustomersFilter('releases')">
                    <span class="option-label">(No Release)</span>
                    <span class="option-meta">${noReleaseCount} items</span>
                </label>
            `;
        }

        // Regular releases with dates
        releases.forEach(r => {
            const info = releaseInfo[r];
            const isChecked = selectedItems.includes(r);
            let dateDisplay;
            if (info.dates.size === 1) {
                dateDisplay = [...info.dates][0];
            } else if (info.dates.size > 1) {
                dateDisplay = 'Multiple dates';
            } else {
                dateDisplay = 'No date';
            }

            const escapedRelease = r.replace(/"/g, '&quot;').replace(/'/g, "\\'");
            html += `
                <label class="filter-dropdown-option" data-search-value="${r.toLowerCase()}" onclick="event.stopPropagation();">
                    <input type="checkbox" value="${escapedRelease}" ${isChecked ? 'checked' : ''} onchange="updateCustomersFilter('releases')">
                    <span class="option-label">${r}</span>
                    <span class="option-meta">${dateDisplay}</span>
                </label>
            `;
        });

        html += `</div>`;
        html += `
            <div class="filter-dropdown-actions">
                <button class="filter-btn-primary" onclick="selectAllCustomersFilter('releases', event)">Select All</button>
                <button class="filter-btn-secondary" onclick="clearCustomersFilter('releases', event)">Clear</button>
            </div>
        `;

        return html;
    }

    // Helper to get menu ID
    function getCustomersMenuId(filterType) {
        const menuIds = {
            customers: 'customers-customer-menu',
            categories: 'customers-category-menu',
            states: 'customers-state-menu',
            priorities: 'customers-priority-menu',
            releases: 'customers-release-menu',
            aging: 'customers-aging-menu'
        };
        return menuIds[filterType];
    }

    // Helper to get select all checkbox ID
    function getCustomersSelectAllId(filterType) {
        const ids = {
            customers: 'customers-customer-select-all',
            categories: 'customers-category-select-all',
            states: 'customers-state-select-all',
            priorities: 'customers-priority-select-all',
            releases: 'customers-release-select-all',
            aging: 'customers-aging-select-all'
        };
        return ids[filterType];
    }

    // Helper to get display element ID
    function getCustomersDisplayId(filterType) {
        const ids = {
            customers: 'customers-customer-display',
            categories: 'customers-category-display',
            states: 'customers-state-display',
            priorities: 'customers-priority-display',
            releases: 'customers-release-display',
            aging: 'customers-aging-display'
        };
        return ids[filterType];
    }

    // Populate filter dropdowns
    function populateCustomersFilterDropdowns() {
        const issues = getAllIssues();

        // Get unique customers
        const customersSet = new Set();
        issues.forEach(i => {
            if (i.customers) {
                i.customers.split(';').forEach(c => {
                    const trimmed = c.trim();
                    if (trimmed) customersSet.add(trimmed);
                });
            } else {
                customersSet.add('(No Customer)');
            }
        });
        const allCustomers = [...customersSet].sort((a, b) => {
            if (a === '(No Customer)') return 1;
            if (b === '(No Customer)') return -1;
            return a.localeCompare(b);
        });

        // Get unique categories
        const categoriesSet = new Set();
        issues.forEach(i => {
            categoriesSet.add(i.ticketCategory || '(Not Set)');
        });
        const allCategories = [...categoriesSet].sort((a, b) => {
            if (a === '(Not Set)') return 1;
            if (b === '(Not Set)') return -1;
            return a.localeCompare(b);
        });

        // Get unique states
        const statesSet = new Set();
        issues.forEach(i => {
            if (i.state) statesSet.add(i.state);
        });
        const stateOrder = ['New', 'Triaged', 'To Do', 'In Progress', 'Ready For Review', 'Done', 'Closed', 'Removed'];
        const allStates = [...statesSet].sort((a, b) => {
            const aIdx = stateOrder.indexOf(a);
            const bIdx = stateOrder.indexOf(b);
            if (aIdx === -1 && bIdx === -1) return a.localeCompare(b);
            if (aIdx === -1) return 1;
            if (bIdx === -1) return -1;
            return aIdx - bIdx;
        });

        // Get unique priorities
        const prioritiesSet = new Set();
        issues.forEach(i => {
            prioritiesSet.add(i.priority ? 'P' + i.priority : '(No Priority)');
        });
        const allPriorities = [...prioritiesSet].sort((a, b) => {
            if (a === '(No Priority)') return 1;
            if (b === '(No Priority)') return -1;
            return a.localeCompare(b);
        });

        // Get unique releases with their target dates
        const releaseInfo = {};
        let noReleaseCount = 0;
        issues.forEach(i => {
            if (!i.releaseVersion) {
                noReleaseCount++;
                return;
            }
            const rv = i.releaseVersion;
            if (!releaseInfo[rv]) {
                releaseInfo[rv] = { dates: new Set(), count: 0 };
            }
            if (i.targetDate) {
                releaseInfo[rv].dates.add(i.targetDate.split(' ')[0]); // Just the date part
            }
            releaseInfo[rv].count++;
        });
        const allReleases = Object.keys(releaseInfo).sort();

        // Populate dropdowns
        // Customer dropdown using generic component (cross-filter aware)
        const customerMenu = document.getElementById('customers-customer-menu');
        if (customerMenu) {
            const customerFilteredIssues = getCustomersIssuesExcludingFilter('customer');
            customerMenu.innerHTML = buildCustomerFilterDropdown({
                dashboardId: 'customers',
                items: customerFilteredIssues,
                selectedCustomers: customersFilters.customers
            });
        }

        // Build Category dropdown (cross-filter aware with counts)
        const categoryMenu = document.getElementById('customers-category-menu');
        if (categoryMenu) {
            const categoryFilteredIssues = getCustomersIssuesExcludingFilter('categories');

            // Count issues by category
            const categoryCounts = {};
            categoryFilteredIssues.forEach(i => {
                const category = i.ticketCategory || '(Not Set)';
                categoryCounts[category] = (categoryCounts[category] || 0) + 1;
            });

            // Use allCategories order but only show those with counts
            const availableCategories = allCategories.filter(c => categoryCounts[c] > 0);

            let categoryHtml = `
                <div class="filter-dropdown-search">
                    <input type="text" placeholder="Search categories..."
                           oninput="filterCustomersDropdownOptions(this, 'customers-category-menu')"
                           onclick="event.stopPropagation();">
                </div>
                <div class="filter-dropdown-options" id="customers-category-menu-options">
            `;

            availableCategories.forEach(c => {
                const isChecked = customersFilters.categories.includes(c);
                const escapedValue = c.replace(/"/g, '&quot;').replace(/'/g, "\\'");
                categoryHtml += `
                    <label class="filter-dropdown-option" data-search-value="${c.toLowerCase()}" onclick="event.stopPropagation();">
                        <input type="checkbox" value="${escapedValue}" ${isChecked ? 'checked' : ''} onchange="updateCustomersFilter('categories')">
                        <span class="option-label">${c}</span>
                        <span class="option-count">${categoryCounts[c]}</span>
                    </label>
                `;
            });

            categoryHtml += `</div>`;
            categoryHtml += `
                <div class="filter-dropdown-actions">
                    <button class="filter-btn-primary" onclick="selectAllCustomersFilter('categories', event)">Select All</button>
                    <button class="filter-btn-secondary" onclick="clearCustomersFilter('categories', event)">Clear</button>
                </div>
            `;
            categoryMenu.innerHTML = categoryHtml;
        }

        // Build state dropdown using generic component (cross-filter aware)
        const stateMenu = document.getElementById('customers-state-menu');
        if (stateMenu) {
            const stateFilteredIssues = getCustomersIssuesExcludingFilter('state');
            stateMenu.innerHTML = buildStateFilterDropdown({
                dashboardId: 'customers',
                items: stateFilteredIssues,
                selectedStates: customersFilters.states
            });
        }

        // Build priority dropdown using generic component (cross-filter aware)
        const priorityMenu = document.getElementById('customers-priority-menu');
        if (priorityMenu) {
            const priorityFilteredIssues = getCustomersIssuesExcludingFilter('priority');
            priorityMenu.innerHTML = buildPriorityFilterDropdown({
                dashboardId: 'customers',
                items: priorityFilteredIssues,
                selectedPriorities: customersFilters.priorities
            });
        }

        // Build release dropdown using generic component (cross-filter aware)
        const releaseMenu = document.getElementById('customers-release-menu');
        if (releaseMenu) {
            const releaseFilteredIssues = getCustomersIssuesExcludingFilter('release');
            releaseMenu.innerHTML = buildReleaseFilterDropdown({
                dashboardId: 'customers',
                items: releaseFilteredIssues,
                selectedReleases: customersFilters.releases
            });
        }

        // Build Aging dropdown (cross-filter aware with counts)
        const agingMenu = document.getElementById('customers-aging-menu');
        if (agingMenu) {
            const agingFilteredIssues = getCustomersIssuesExcludingFilter('aging');

            // Count issues by aging bucket
            const agingCounts = {};
            agingFilteredIssues.forEach(i => {
                const bucket = calculateAgingBucket(i);
                agingCounts[bucket] = (agingCounts[bucket] || 0) + 1;
            });

            // Use AGING_BUCKETS order but only show those with counts
            const availableBuckets = AGING_BUCKETS.filter(b => agingCounts[b] > 0);

            let agingHtml = `
                <div class="filter-dropdown-search">
                    <input type="text" placeholder="Search aging..."
                           oninput="filterCustomersDropdownOptions(this, 'customers-aging-menu')"
                           onclick="event.stopPropagation();">
                </div>
                <div class="filter-dropdown-options" id="customers-aging-menu-options">
            `;

            availableBuckets.forEach(b => {
                const isChecked = customersFilters.aging.includes(b);
                const escapedValue = b.replace(/"/g, '&quot;').replace(/'/g, "\\'");
                agingHtml += `
                    <label class="filter-dropdown-option" data-search-value="${b.toLowerCase()}" onclick="event.stopPropagation();">
                        <input type="checkbox" value="${escapedValue}" ${isChecked ? 'checked' : ''} onchange="updateCustomersFilter('aging')">
                        <span class="option-label">${b}</span>
                        <span class="option-count">${agingCounts[b]}</span>
                    </label>
                `;
            });

            agingHtml += `</div>`;
            agingHtml += `
                <div class="filter-dropdown-actions">
                    <button class="filter-btn-primary" onclick="selectAllCustomersFilter('aging', event)">Select All</button>
                    <button class="filter-btn-secondary" onclick="clearCustomersFilter('aging', event)">Clear</button>
                </div>
            `;
            agingMenu.innerHTML = agingHtml;
        }

        // Update display text for all filters
        // Generic components update their own displays
        updateGenericCustomerDisplay('customers');
        updateGenericPriorityDisplay('customers');
        updateGenericReleaseDisplay('customers');
        updateGenericStateDisplay('customers');
        // Dashboard-specific filters
        ['categories', 'aging'].forEach(ft => {
            updateCustomersFilterDisplay(ft);
        });
    }

    // Select all in a filter
    function selectAllCustomersFilter(filterType, event) {
        event.stopPropagation();
        const menuId = getCustomersMenuId(filterType);
        const checkboxes = document.querySelectorAll(`#${menuId} .filter-dropdown-option:not(.select-all) input[type="checkbox"]`);
        checkboxes.forEach(cb => cb.checked = true);
        customersFilters[filterType] = Array.from(checkboxes).map(cb => cb.value);
        updateCustomersFilterDisplay(filterType);
        saveStateToStorage();
        renderCustomersView();
        updateCustomersClearButton();
    }

    // Clear a filter
    function clearCustomersFilter(filterType, event) {
        event.stopPropagation();
        const menuId = getCustomersMenuId(filterType);
        const checkboxes = document.querySelectorAll(`#${menuId} .filter-dropdown-option:not(.select-all) input[type="checkbox"]`);
        checkboxes.forEach(cb => cb.checked = false);
        customersFilters[filterType] = [];
        updateCustomersFilterDisplay(filterType);
        saveStateToStorage();
        renderCustomersView();
        updateCustomersClearButton();
    }

    // Update filter when checkbox changes
    function updateCustomersFilter(filterType) {
        const menuId = getCustomersMenuId(filterType);
        const checkboxes = document.querySelectorAll(`#${menuId} .filter-dropdown-option:not(.select-all) input[type="checkbox"]`);
        customersFilters[filterType] = Array.from(checkboxes).filter(cb => cb.checked).map(cb => cb.value);
        updateCustomersFilterDisplay(filterType);
        saveStateToStorage();
        renderCustomersView();
        updateCustomersClearButton();
    }

    // Update filter display text
    function updateCustomersFilterDisplay(filterType) {
        const displayId = getCustomersDisplayId(filterType);
        const menuId = getCustomersMenuId(filterType);
        const allLabels = {
            customers: 'All Customers',
            categories: 'All Categories',
            states: 'All States',
            priorities: 'All Priorities',
            releases: 'All Releases',
            aging: 'All Ages'
        };

        const displayEl = document.getElementById(displayId);
        const checkboxes = document.querySelectorAll(`#${menuId} .filter-dropdown-option:not(.select-all) input[type="checkbox"]`);
        const selected = customersFilters[filterType];

        if (displayEl) {
            if (selected.length === 0 || selected.length === checkboxes.length) {
                displayEl.textContent = allLabels[filterType];
            } else if (selected.length === 1) {
                displayEl.textContent = selected[0];
            } else {
                displayEl.textContent = `${selected.length} selected`;
            }
        }
    }

    // Filter by card click (Ticket Category)
    function filterCustomersByCategory(category) {
        // Clear all filters first, then set category
        customersFilters = {
            search: '',
            customers: [],
            categories: category ? [category] : [],
            states: [],
            priorities: [],
            releases: [],
            aging: []
        };
        document.getElementById('customers-search-input').value = '';
        saveStateToStorage();
        renderCustomersView();
        populateCustomersFilterDropdowns();
    }

    // Filter by aging bucket click (from histogram)
    function filterByAgingBucket(bucket) {
        // Set aging filter to the clicked bucket
        customersFilters.aging = [bucket];
        saveStateToStorage();
        renderCustomersView();
        populateCustomersFilterDropdowns();
        updateCustomersClearButton();
    }

    // Filter by state click (from Insights)
    function filterCustomersByState(stateOrType) {
        if (stateOrType === 'open') {
            // "Open issues" = all states except Done, Closed, Removed
            const openStates = ['New', 'Triaged', 'To Do', 'In Progress', 'Ready For Review'];
            customersFilters.states = openStates;
        } else {
            // Single state filter
            customersFilters.states = [stateOrType];
        }
        saveStateToStorage();
        renderCustomersView();
        populateCustomersFilterDropdowns();
        updateCustomersClearButton();
    }

    // Sort Issues for table
    function sortCustomersIssues(issues) {
        const { column, direction } = customersSortState;
        const multiplier = direction === 'asc' ? 1 : -1;

        return [...issues].sort((a, b) => {
            let aVal, bVal;
            switch (column) {
                case 'id':
                    return (a.id - b.id) * multiplier;
                case 'title':
                    return (a.title || '').localeCompare(b.title || '') * multiplier;
                case 'state':
                    const stateOrder = ['New', 'Triaged', 'To Do', 'In Progress', 'Ready For Review', 'Done', 'Closed', 'Removed'];
                    return (stateOrder.indexOf(a.state) - stateOrder.indexOf(b.state)) * multiplier;
                case 'customers':
                    return (a.customers || '').localeCompare(b.customers || '') * multiplier;
                case 'priority':
                    aVal = a.priority || 999;
                    bVal = b.priority || 999;
                    return (aVal - bVal) * multiplier;
                case 'ticketCategory':
                    return (a.ticketCategory || '').localeCompare(b.ticketCategory || '') * multiplier;
                case 'aging':
                    aVal = calculateAgeDays(a);
                    bVal = calculateAgeDays(b);
                    return (aVal - bVal) * multiplier;
                case 'tags':
                    return (a.tags || '').localeCompare(b.tags || '') * multiplier;
                case 'csOwner':
                    return (a.csOwner || '').localeCompare(b.csOwner || '') * multiplier;
                case 'release':
                    return (a.releaseVersion || '').localeCompare(b.releaseVersion || '') * multiplier;
                case 'targetDate':
                    return (a.targetDate || '').localeCompare(b.targetDate || '') * multiplier;
                default:
                    return 0;
            }
        });
    }

    // Handle column header click for sorting
    function sortCustomersTable(column) {
        if (customersSortState.column === column) {
            customersSortState.direction = customersSortState.direction === 'asc' ? 'desc' : 'asc';
        } else {
            customersSortState.column = column;
            customersSortState.direction = 'asc';
        }
        saveStateToStorage();
        renderCustomersView();
    }

    // Reset sort to default (Aging ascending)
    function resetCustomersSort() {
        customersSortState.column = defaultCustomersSortState.column;
        customersSortState.direction = defaultCustomersSortState.direction;
        saveStateToStorage();
        renderCustomersView();
    }

    // Check if current sort is different from default
    function isCustomersSortNonDefault() {
        return customersSortState.column !== defaultCustomersSortState.column ||
               customersSortState.direction !== defaultCustomersSortState.direction;
    }

    // Helper to count relationships for a work item (for displaying pills in table)
    function countRelationshipsForWorkItem(workItemId) {
        let childrenCount = 0;
        let relatedCount = 0;
        let hasParent = false;

        // Count links where this item is the source (children, related-forward)
        workItemLinks.forEach(link => {
            if (link.source === workItemId) {
                if (link.type === 'Child') {
                    childrenCount++;
                } else if (link.type === 'Related') {
                    relatedCount++;
                }
            }
            // Check if this item is a target of a Child link (meaning source is parent)
            if (link.target === workItemId && link.type === 'Child') {
                hasParent = true;
            }
        });

        return { childrenCount, relatedCount, hasParent };
    }

    // Build relationship pills HTML for a work item
    function buildRelationshipPills(workItemId) {
        const counts = countRelationshipsForWorkItem(workItemId);
        const pills = [];

        if (counts.hasParent) {
            pills.push('<span class="rel-pill rel-pill-parent">has parent</span>');
        }
        if (counts.childrenCount > 0) {
            pills.push(`<span class="rel-pill rel-pill-children">${counts.childrenCount} ${counts.childrenCount === 1 ? 'child' : 'children'}</span>`);
        }
        if (counts.relatedCount > 0) {
            pills.push(`<span class="rel-pill rel-pill-related">${counts.relatedCount} related</span>`);
        }

        // If no relationships, show "no links" pill
        if (pills.length === 0) {
            pills.push('<span class="rel-pill rel-pill-none">no links</span>');
        }

        return pills.join('');
    }

    // Customers View
    function renderCustomersView() {
        const stats = document.getElementById('customer-stats');
        const insights = document.getElementById('customer-insights');
        const histogramContainer = document.getElementById('customer-aging-histogram');
        const tableContainer = document.getElementById('customer-issues-table');

        // Get all issues and filtered issues
        const allIssues = getAllIssues();
        const filteredIssues = getFilteredIssues();
        const isFiltered = hasActiveCustomersFilters();
        const filterNote = isFiltered ? ' (filtered)' : '';

        // Calculate stats by Ticket Category
        const enhancementRequests = filteredIssues.filter(i => i.ticketCategory === 'Enhancement Request');
        const bugs = filteredIssues.filter(i => i.ticketCategory === 'Bug');
        const tasks = filteredIssues.filter(i => i.ticketCategory === 'Task');

        // Stats cards - clickable
        stats.innerHTML = `
            <div class="stat-card clickable" onclick="filterCustomersByCategory(null)">
                <div class="stat-label">Total Issues${filterNote}</div>
                <div class="stat-value" style="color: var(--accent-cyan)">${filteredIssues.length}</div>
                <div class="stat-subtitle">${allIssues.length} total in system</div>
            </div>
            <div class="stat-card clickable" onclick="filterCustomersByCategory('Enhancement Request')">
                <div class="stat-label">Enhancement Requests</div>
                <div class="stat-value" style="color: var(--accent-blue)">${enhancementRequests.length}</div>
                <div class="stat-subtitle">${filteredIssues.length > 0 ? Math.round(enhancementRequests.length / filteredIssues.length * 100) : 0}% of issues</div>
            </div>
            <div class="stat-card clickable" onclick="filterCustomersByCategory('Bug')">
                <div class="stat-label">Bugs</div>
                <div class="stat-value" style="color: var(--accent-orange)">${bugs.length}</div>
                <div class="stat-subtitle">${filteredIssues.length > 0 ? Math.round(bugs.length / filteredIssues.length * 100) : 0}% of issues</div>
            </div>
            <div class="stat-card clickable" onclick="filterCustomersByCategory('Task')">
                <div class="stat-label">Tasks</div>
                <div class="stat-value" style="color: var(--accent-purple)">${tasks.length}</div>
                <div class="stat-subtitle">${filteredIssues.length > 0 ? Math.round(tasks.length / filteredIssues.length * 100) : 0}% of issues</div>
            </div>
        `;

        // Insights - horizontal format
        const openIssues = filteredIssues.filter(i => i.state !== 'Done' && i.state !== 'Closed' && i.state !== 'Removed');
        const triaged = filteredIssues.filter(i => i.state === 'Triaged');
        const inProgress = filteredIssues.filter(i => i.state === 'In Progress');
        const newIssues = filteredIssues.filter(i => i.state === 'New');

        insights.innerHTML = `
            <div class="insights-content">
                <span class="insights-title">‚ö° Insights${filterNote}</span>
                <span class="insight-item info clickable" onclick="filterCustomersByState('open')"><span class="insight-icon">üìä</span> ${openIssues.length} open issues</span>
                <span class="insight-item ${newIssues.length > 10 ? 'warning' : 'info'} clickable" onclick="filterCustomersByState('New')"><span class="insight-icon">üÜï</span> ${newIssues.length} new (awaiting triage)</span>
                <span class="insight-item info clickable" onclick="filterCustomersByState('Triaged')"><span class="insight-icon">üìã</span> ${triaged.length} triaged</span>
                <span class="insight-item info clickable" onclick="filterCustomersByState('In Progress')"><span class="insight-icon">üîÑ</span> ${inProgress.length} in progress</span>
            </div>
        `;

        // Aging histogram
        const agingCounts = {};
        AGING_BUCKETS.forEach(bucket => agingCounts[bucket] = 0);
        filteredIssues.forEach(issue => {
            const bucket = calculateAgingBucket(issue);
            agingCounts[bucket]++;
        });
        const maxCount = Math.max(...Object.values(agingCounts), 1);

        // Calculate nice Y-axis tick values
        const yAxisTicks = [];
        const tickCount = 4;
        const tickStep = Math.ceil(maxCount / tickCount);
        for (let i = tickCount; i >= 0; i--) {
            yAxisTicks.push(Math.min(i * tickStep, maxCount));
        }

        histogramContainer.innerHTML = `
            <div class="aging-histogram-title">üìä Issue Aging Distribution${filterNote}</div>
            <div class="aging-histogram-wrapper">
                <div class="aging-histogram-yaxis">
                    ${yAxisTicks.map(tick => `<span class="aging-yaxis-label">${tick}</span>`).join('')}
                </div>
                <div class="aging-histogram-chart">
                    <div class="aging-histogram-bars">
                        ${AGING_BUCKETS.map(bucket => {
                            const count = agingCounts[bucket];
                            const heightPct = maxCount > 0 ? (count / maxCount) * 100 : 0;
                            const barClass = 'bar-' + bucket.replace(/\s+/g, '-');
                            return `
                                <div class="aging-bar-container">
                                    <div class="aging-bar-count">${count}</div>
                                    <div class="aging-bar ${barClass}" style="height: ${Math.max(heightPct, 2)}%" onclick="filterByAgingBucket('${bucket}')" title="${bucket}: ${count} issues"></div>
                                    <div class="aging-bar-label">${bucket}</div>
                                </div>
                            `;
                        }).join('')}
                    </div>
                </div>
            </div>
        `;

        // Render table using generic table component
        const customerColumns = [
            { key: 'id', label: 'ID', class: 'col-id' },
            { key: 'title', label: 'Title', class: 'col-title' },
            { key: 'state', label: 'State', class: 'col-state' },
            { key: 'customers', label: 'Customers', class: 'col-customers' },
            { key: 'priority', label: 'Priority', class: 'col-priority' },
            { key: 'ticketCategory', label: 'Category', class: 'col-category' },
            { key: 'aging', label: 'Aging', class: 'col-aging' },
            { key: 'tags', label: 'Tags', class: 'col-tags' },
            { key: 'csOwner', label: 'CS Owner', class: 'col-csowner' },
            { key: 'releaseVersion', label: 'Release', class: 'col-release' },
            { key: 'targetDate', label: 'Target Date', class: 'col-date' }
        ];

        // Custom cell renderer for Customers-specific columns
        const customersRenderCell = (item, col) => {
            const key = col.key;
            const colClass = col.class || `col-${key}`;

            if (key === 'id') {
                return `<td class="${colClass}"><a href="${item.url}" target="_blank" class="work-item-link" onclick="event.stopPropagation()">${item.id}</a></td>`;
            }
            if (key === 'title') {
                return `<td class="${colClass}" title="${(item.title || '').replace(/"/g, '&quot;')}">
                    <span class="title-text">${item.title || ''}</span>
                    <span class="rel-pills">${buildRelationshipPills(item.id)}</span>
                </td>`;
            }
            if (key === 'state') {
                const stateClass = `state-${(item.state || '').toLowerCase().replace(/\s+/g, '-')}`;
                return `<td class="${colClass}"><span class="state-badge ${stateClass}">${item.state || ''}</span></td>`;
            }
            if (key === 'customers') {
                return `<td class="${colClass}" title="${(item.customers || '').replace(/"/g, '&quot;')}">${item.customers || ''}</td>`;
            }
            if (key === 'priority') {
                return `<td class="${colClass} priority-cell">${item.priority ? 'P' + item.priority : ''}</td>`;
            }
            if (key === 'ticketCategory') {
                const catClass = `category-${(item.ticketCategory || '').toLowerCase().replace(/\s+/g, '-')}`;
                return `<td class="${colClass}"><span class="category-badge ${catClass}">${item.ticketCategory || ''}</span></td>`;
            }
            if (key === 'aging') {
                const agingBucket = calculateAgingBucket(item);
                const agingClass = `aging-${agingBucket.replace(/\s+/g, '-')}`;
                return `<td class="${colClass}"><span class="aging-badge ${agingClass}">${agingBucket}</span></td>`;
            }
            if (key === 'tags') {
                return `<td class="${colClass}" title="${(item.tags || '').replace(/"/g, '&quot;')}">${item.tags || ''}</td>`;
            }
            if (key === 'csOwner') {
                return `<td class="${colClass}">${item.csOwner || ''}</td>`;
            }
            if (key === 'releaseVersion') {
                return `<td class="${colClass}">${item.releaseVersion || ''}</td>`;
            }
            if (key === 'targetDate') {
                return `<td class="${colClass}">${formatDate(item.targetDate)}</td>`;
            }
            return `<td class="${colClass}">${item[key] || ''}</td>`;
        };

        // Row click handler
        const handleCustomerRowClick = (item) => {
            showWorkItemDetailsModal(item);
        };

        // Column resize handler
        const handleCustomerColumnResize = (columnKey, width) => {
            customersColumnWidths[columnKey] = width;
            saveStateToStorage();
        };

        // Sort change handler
        const handleCustomerSortChange = (column, direction) => {
            customersSortState.column = column;
            customersSortState.direction = direction;
            saveStateToStorage();
        };

        buildGenericTable({
            containerId: 'customer-issues-table',
            tableId: 'customers-table',
            icon: 'üé´',
            title: 'Issue Details',
            columns: customerColumns,
            items: filteredIssues,
            sortState: customersSortState,
            defaultSort: { column: 'aging', direction: 'asc' },
            onSort: handleCustomerSortChange,
            onRowClick: handleCustomerRowClick,
            rowClickHint: 'Click on a row to view relationships',
            columnWidths: customersColumnWidths,
            onColumnResize: handleCustomerColumnResize,
            renderCell: customersRenderCell
        });

        // Populate filter dropdowns on first render
        populateCustomersFilterDropdowns();
        updateCustomersClearButton();
    }

    // ==================== FEATURE ROADMAP VIEW ====================

    // Roadmap state
    let roadmapSortState = {
        column: null,  // null means use default backlog priority order
        direction: 'asc'
    };

    // Roadmap filter state
    // Roadmap filters - all filters start empty (no defaults)
    let roadmapFilters = {
        search: '',
        states: [],
        customers: [],
        assignees: [],
        teams: [],
        iterations: [],
        priorities: [],
        releases: [],
        releasesExclusionMode: false,  // Track if we started from "Select All" for release filter
        tags: [],
        tagsExclusionMode: false,  // Track if we started from "Select All" for tag filter
        tagsLogicMode: 'or'  // 'and' or 'or' - controls how multiple tag selections are combined
    };

    // Track collapsed state for collapsible sections
    let roadmapTeamSummaryCollapsed = true; // Collapsed by default

    // Column widths for Roadmap table (persisted)
    let roadmapColumnWidths = {};

    // Helper to extract last segment from backslash-delimited path
    function getLastPathSegment(path) {
        if (!path) return '';
        const parts = path.split('\\');
        return parts[parts.length - 1].trim();
    }

    // Get all Delivery Slices that are children of the given feature IDs
    function getDeliverySlicesForFeatures(featureIds) {
        const featureIdSet = new Set(featureIds.map(id => String(id)));
        return workItems.filter(w => {
            if (w.type !== 'Delivery Slice') return false;
            // Check if parent is one of our features
            return w.parentId && featureIdSet.has(String(w.parentId));
        });
    }

    // Calculate effort by team from delivery slices
    function calculateEffortByTeam(deliverySlices) {
        const effortByTeam = {};
        let totalEffort = 0;

        deliverySlices.forEach(ds => {
            const effort = ds.effort || 0;
            const team = getLastPathSegment(ds.areaPath) || '(No Team)';

            if (!effortByTeam[team]) {
                effortByTeam[team] = 0;
            }
            effortByTeam[team] += effort;
            totalEffort += effort;
        });

        return { effortByTeam, totalEffort };
    }

    // Team leads mapping
    const roadmapTeamLeads = {
        'Frontend': 'Andreas Davros',
        'Backend': 'Thanos Terzis',
        'QA': 'Kostas Tzoulas',
        'DevOps': 'Christos Sidiropoulos',
        'Analytics': 'Maya Dahan',
        'Govern': 'Maya Dahan',
        'SCG': 'Alexandros Papadakis',
        'Staff': 'John Paglierani',
        'Security & Compliance': 'Chakra Bokissam',
        'Customer Success': ''
    };

    // Get team member count for capacity calculation
    function getRoadmapTeamMemberCount(teamName) {
        if (typeof orgChartData === 'undefined') return 0;

        // Find the org chart entry that contains this team
        // Note: t.team may be "Analytics & Govern" for leads who manage multiple teams
        const teamData = orgChartData.find(t => {
            // Split combined team names and check if any matches
            const teams = t.team.split(' & ').map(name => name.split(' (')[0].trim());
            return teams.includes(teamName) || t.team === teamName;
        });

        if (!teamData) return 0;

        // Count only members from this specific team (plus lead if they manage just this team)
        let count = 0;

        // Check if lead manages only this team (not multiple teams)
        const leadTeams = teamData.team.split(' & ').map(name => name.split(' (')[0].trim());
        if (leadTeams.length === 1 && leadTeams[0] === teamName) {
            count = 1; // Include the lead
        }

        // Count active members from this specific team
        teamData.members.forEach(m => {
            if (m.status !== 'Former' && m.team === teamName) {
                count++;
            }
        });

        return count;
    }

    // Get initials from name
    function getInitials(name) {
        if (!name) return '?';
        const parts = name.trim().split(' ');
        if (parts.length === 1) return parts[0][0].toUpperCase();
        return (parts[0][0] + parts[parts.length - 1][0]).toUpperCase();
    }

    // Count features and delivery slices by team
    function countItemsByTeam(features, slices, team) {
        // Count features that have at least one slice from this team
        const featureIdsWithTeam = new Set();
        slices.forEach(ds => {
            const dsTeam = getLastPathSegment(ds.areaPath) || '(No Team)';
            if (dsTeam === team && ds.parentId) {
                featureIdsWithTeam.add(String(ds.parentId));
            }
        });
        const featureCount = features.filter(f => featureIdsWithTeam.has(String(f.id))).length;

        // Count slices from this team
        const sliceCount = slices.filter(ds => {
            const dsTeam = getLastPathSegment(ds.areaPath) || '(No Team)';
            return dsTeam === team;
        }).length;

        return { featureCount, sliceCount };
    }

    // Strategy categories for Summary View (Section 1)
    const strategyCategories = [
        { prefix: '1:', label: 'eSHARE is must-have' },
        { prefix: '2:', label: 'eSHARE is the collaboration standard' },
        { prefix: '3:', label: 'eSHARE deployability' },
        { prefix: '4:', label: 'eSHARE is customer-focused, stable and secure' }
    ];

    // Calculate strategy summary for filtered features
    function calculateStrategySummary(features, featureEffortMap) {
        // Initialize results for each category
        const results = strategyCategories.map(cat => ({
            prefix: cat.prefix,
            label: cat.label,
            count: 0,
            effort: 0,
            featureIds: []
        }));

        // Track features that match multiple categories (for error detection)
        const multiCategoryFeatures = [];

        features.forEach(f => {
            const tags = (f.tags || '').split(';').map(t => t.trim()).filter(t => t);
            const featureEffort = featureEffortMap[f.id] || 0;

            // Check which categories this feature matches
            const matchedCategories = [];
            results.forEach((cat, idx) => {
                const hasMatchingTag = tags.some(tag => tag.startsWith(cat.prefix));
                if (hasMatchingTag) {
                    matchedCategories.push(idx);
                    cat.count++;
                    cat.effort += featureEffort;
                    cat.featureIds.push(f.id);
                }
            });

            // If feature matches more than one category, track it
            if (matchedCategories.length > 1) {
                multiCategoryFeatures.push({
                    id: f.id,
                    title: f.title,
                    categories: matchedCategories.map(idx => results[idx].prefix)
                });
            }
        });

        return { results, multiCategoryFeatures };
    }

    // Render strategy summary (Section 1)
    function renderStrategySummary(features, featureEffortMap) {
        const tbody = document.getElementById('strategy-summary-body');
        const errorContainer = document.getElementById('strategy-error-container');
        const unmatchedNote = document.getElementById('strategy-unmatched-note');
        if (!tbody || !errorContainer) return;

        const { results, multiCategoryFeatures } = calculateStrategySummary(features, featureEffortMap);

        // Calculate features that don't match any category
        const matchedFeatureIds = new Set();
        results.forEach(r => r.featureIds.forEach(id => matchedFeatureIds.add(id)));
        const unmatchedCount = features.length - matchedFeatureIds.size;

        // Calculate total effort across all categories for percentage calculation
        const totalEffort = results.reduce((sum, r) => sum + r.effort, 0);

        // Build table rows - counts are clickable to filter by that strategy tag
        tbody.innerHTML = `
            <tr>
                <td class="row-label">Features</td>
                ${results.map((r, idx) => `<td class="count-value clickable" onclick="filterByOkrCategory('${r.prefix}')" title="Click to filter by ${r.prefix}* tags">${r.count}</td>`).join('')}
            </tr>
            <tr>
                <td class="row-label">Effort</td>
                ${results.map(r => {
                    const pct = totalEffort > 0 ? (r.effort / totalEffort * 100) : 0;
                    const pctDisplay = pct > 0 ? pct.toFixed(0) + '%' : '0%';
                    const daysDisplay = r.effort > 0 ? r.effort.toFixed(1) + 'd' : '0d';
                    return `<td class="effort-value"><span class="effort-pct">${pctDisplay}</span><span class="effort-days">${daysDisplay}</span></td>`;
                }).join('')}
            </tr>
        `;

        // Show note about features without matching tags
        if (unmatchedNote) {
            if (unmatchedCount > 0) {
                unmatchedNote.textContent = `${unmatchedCount} feature${unmatchedCount !== 1 ? 's' : ''} without OKR tags`;
            } else {
                unmatchedNote.textContent = '';
            }
        }

        // Show error message if any features match multiple categories
        if (multiCategoryFeatures.length > 0) {
            const featureIdList = multiCategoryFeatures.map(f => f.id).join(',');
            errorContainer.innerHTML = `
                <div class="strategy-error-message">
                    <span class="error-icon">‚ö†Ô∏è</span>
                    <span>${multiCategoryFeatures.length} feature${multiCategoryFeatures.length !== 1 ? 's have' : ' has'} tags in multiple OKR categories.
                    <a onclick="filterMultiCategoryFeatures('${featureIdList}')">Show in table</a></span>
                </div>
            `;
        } else {
            errorContainer.innerHTML = '';
        }
    }

    // Filter by OKR category (e.g., "1:", "2:", etc.)
    // Preserves all existing filters except tags - only updates the tag filter
    function filterByOkrCategory(prefix) {
        // Get all tags that start with this prefix from the current features
        const allFeatures = getRoadmapFeatures();
        const matchingTags = new Set();
        allFeatures.forEach(f => {
            const tags = (f.tags || '').split(';').map(t => t.trim()).filter(t => t);
            tags.forEach(tag => {
                if (tag.startsWith(prefix)) {
                    matchingTags.add(tag);
                }
            });
        });

        // Update only the tag filter (preserve all other filters)
        roadmapFilters.tags = [...matchingTags];
        roadmapFilters.tagsExclusionMode = false;
        roadmapFilters.tagsLogicMode = 'or'; // Show features with ANY of these tags

        // Update display (use 'tag' not 'tags')
        updateRoadmapFilterDisplay('tag');

        // Save state and re-render
        saveStateToStorage();
        renderRoadmapView();

        // Sync the tag dropdown checkboxes AFTER render (since render may rebuild the dropdown)
        const tagOptionsContainer = document.getElementById('roadmap-tag-options');
        if (tagOptionsContainer) {
            tagOptionsContainer.querySelectorAll('input[type="checkbox"]').forEach(cb => {
                cb.checked = roadmapFilters.tags.includes(cb.value);
            });
        }
    }

    // Filter table to show only multi-category features
    function filterMultiCategoryFeatures(featureIdList) {
        const ids = featureIdList.split(',').map(id => id.trim());
        // Set search filter to show these IDs
        // We'll use a special search that matches these specific IDs
        const searchInput = document.getElementById('roadmap-search-input');
        if (searchInput) {
            // Use a regex-like pattern that the search can handle: ID1|ID2|ID3
            searchInput.value = ids.join('|');
            roadmapFilters.search = ids.join('|');
            saveStateToStorage();
            renderRoadmapView();

            // Scroll to the table section
            const tableSection = document.getElementById('roadmap-section-details');
            if (tableSection) {
                tableSection.scrollIntoView({ behavior: 'smooth', block: 'start' });
            }
        }
    }

    function getRoadmapFeatures() {
        // Return all Features - release version filtering is now handled by the Release filter dropdown
        // Tag filtering (including Candidate) is handled by the Tag filter dropdown
        return workItems.filter(w => w.type === 'Feature');
    }

    function getFilteredRoadmapFeatures() {
        let features = getRoadmapFeatures();

        // Apply search filter using generic component (supports pipe-separated IDs)
        features = applyGenericSearchFilter(features, roadmapFilters.search, { supportPipeSeparated: true });

        // Apply state filter
        if (roadmapFilters.states.length > 0) {
            features = features.filter(f => roadmapFilters.states.includes(f.state));
        }

        // Apply customer filter
        if (roadmapFilters.customers.length > 0) {
            features = features.filter(f => {
                if (!f.customers) return roadmapFilters.customers.includes('(No Customer)');
                return roadmapFilters.customers.some(c => f.customers.includes(c));
            });
        }

        // Apply assignee filter
        if (roadmapFilters.assignees.length > 0) {
            features = features.filter(f => {
                const assignee = f.assignedTo || '(Unassigned)';
                return roadmapFilters.assignees.includes(assignee);
            });
        }

        // Apply team and iteration filters together (based on delivery slices)
        // When both are active, a feature must have at least one slice that matches BOTH filters
        if (roadmapFilters.teams.length > 0 || roadmapFilters.iterations.length > 0) {
            features = features.filter(f => {
                const slices = getDeliverySlicesForFeatures([f.id]);
                return slices.some(ds => {
                    const team = getLastPathSegment(ds.areaPath) || '(No Team)';
                    const iteration = getLastPathSegment(ds.iterationPath) || '(No Iteration)';

                    // Check team filter (if active)
                    const teamMatch = roadmapFilters.teams.length === 0 || roadmapFilters.teams.includes(team);
                    // Check iteration filter (if active)
                    const iterationMatch = roadmapFilters.iterations.length === 0 || roadmapFilters.iterations.includes(iteration);

                    // Slice must match both filters (when active)
                    return teamMatch && iterationMatch;
                });
            });
        }

        // Apply priority filter (generic component uses P1, P2, etc. format)
        if (roadmapFilters.priorities.length > 0) {
            features = features.filter(f => {
                const priority = f.priority ? 'P' + f.priority : '(No Priority)';
                return roadmapFilters.priorities.includes(priority);
            });
        }

        // Apply release version filter
        if (roadmapFilters.releases.length > 0) {
            // Helper to get release category for a feature
            const getFeatureReleaseCategory = (f) => {
                if (f.releaseVersion && f.releaseVersion.trim()) {
                    return f.releaseVersion.trim();
                }
                // No release version - check if has target date
                return f.targetDate ? '(Needs Release)' : '(No Release)';
            };

            if (roadmapFilters.releasesExclusionMode) {
                // Exclusion mode: Started from "Select All", now excluding unchecked releases
                // Get all available release categories
                const allAvailableReleases = new Set(['(No Release)', '(Needs Release)']);
                getRoadmapFeatures().forEach(f => {
                    if (f.releaseVersion && f.releaseVersion.trim()) {
                        allAvailableReleases.add(f.releaseVersion.trim());
                    }
                });
                const uncheckedReleases = [...allAvailableReleases].filter(r => !roadmapFilters.releases.includes(r));

                features = features.filter(f => {
                    const featureRelease = getFeatureReleaseCategory(f);
                    // Exclude features that have any unchecked release
                    return !uncheckedReleases.includes(featureRelease);
                });
            } else {
                // Inclusion mode: Show features that have any of the selected releases
                features = features.filter(f => {
                    const featureRelease = getFeatureReleaseCategory(f);
                    return roadmapFilters.releases.includes(featureRelease);
                });
            }
        }

        // Apply tag filter
        if (roadmapFilters.tags.length > 0) {
            if (roadmapFilters.tagsExclusionMode) {
                // Exclusion mode: Started from "Select All", now excluding unchecked tags
                // Get all available tags to determine what's unchecked
                const allAvailableTags = new Set();
                getRoadmapFeatures().forEach(f => {
                    if (f.tags) {
                        f.tags.split(';').forEach(t => {
                            const trimmed = t.trim();
                            if (trimmed) allAvailableTags.add(trimmed);
                        });
                    }
                });
                const uncheckedTags = [...allAvailableTags].filter(t => !roadmapFilters.tags.includes(t));

                features = features.filter(f => {
                    const featureTags = (f.tags || '').split(';').map(t => t.trim()).filter(t => t);
                    // Exclude features that have any unchecked tag
                    return !featureTags.some(tag => uncheckedTags.includes(tag));
                });
            } else {
                // Inclusion mode: logic depends on tagsLogicMode setting
                features = features.filter(f => {
                    const featureTags = (f.tags || '').split(';').map(t => t.trim()).filter(t => t);
                    if (roadmapFilters.tagsLogicMode === 'and') {
                        // AND logic: feature must have ALL selected tags
                        return roadmapFilters.tags.every(selectedTag => featureTags.includes(selectedTag));
                    } else {
                        // OR logic (default): feature must have ANY selected tag
                        return roadmapFilters.tags.some(selectedTag => featureTags.includes(selectedTag));
                    }
                });
            }
        }

        return features;
    }

    /**
     * Get Roadmap features filtered by all filters EXCEPT the specified one
     * Used for cross-filter dropdown population
     * @param {string} excludeFilter - Filter to exclude: 'priority', 'release', 'customer', 'state', 'team', 'iteration', 'tag', 'assignee'
     */
    function getRoadmapFeaturesExcludingFilter(excludeFilter) {
        let features = getRoadmapFeatures();

        // Always apply search filter
        features = applyGenericSearchFilter(features, roadmapFilters.search, { supportPipeSeparated: true });

        // Apply state filter (unless excluded)
        if (excludeFilter !== 'state' && roadmapFilters.states.length > 0) {
            features = features.filter(f => roadmapFilters.states.includes(f.state));
        }

        // Apply customer filter (unless excluded)
        if (excludeFilter !== 'customer' && roadmapFilters.customers.length > 0) {
            features = features.filter(f => {
                if (!f.customers) return roadmapFilters.customers.includes('(No Customer)');
                return roadmapFilters.customers.some(c => f.customers.includes(c));
            });
        }

        // Apply assignee filter (unless excluded)
        if (excludeFilter !== 'assignee' && roadmapFilters.assignees.length > 0) {
            features = features.filter(f => {
                const assignee = f.assignedTo || '(Unassigned)';
                return roadmapFilters.assignees.includes(assignee);
            });
        }

        // Apply team and iteration filters together (unless excluded)
        const applyTeam = excludeFilter !== 'team' && roadmapFilters.teams.length > 0;
        const applyIteration = excludeFilter !== 'iteration' && roadmapFilters.iterations.length > 0;
        if (applyTeam || applyIteration) {
            features = features.filter(f => {
                const slices = getDeliverySlicesForFeatures([f.id]);
                return slices.some(ds => {
                    const team = getLastPathSegment(ds.areaPath) || '(No Team)';
                    const iteration = getLastPathSegment(ds.iterationPath) || '(No Iteration)';
                    const teamMatch = !applyTeam || roadmapFilters.teams.includes(team);
                    const iterationMatch = !applyIteration || roadmapFilters.iterations.includes(iteration);
                    return teamMatch && iterationMatch;
                });
            });
        }

        // Apply priority filter (unless excluded)
        if (excludeFilter !== 'priority' && roadmapFilters.priorities.length > 0) {
            features = features.filter(f => {
                const priority = f.priority ? 'P' + f.priority : '(No Priority)';
                return roadmapFilters.priorities.includes(priority);
            });
        }

        // Apply release filter (unless excluded)
        if (excludeFilter !== 'release' && roadmapFilters.releases.length > 0) {
            const getFeatureReleaseCategory = (f) => {
                if (f.releaseVersion && f.releaseVersion.trim()) return f.releaseVersion.trim();
                return f.targetDate ? '(Needs Release)' : '(No Release)';
            };

            if (roadmapFilters.releasesExclusionMode) {
                const allAvailableReleases = new Set(['(No Release)', '(Needs Release)']);
                getRoadmapFeatures().forEach(f => {
                    if (f.releaseVersion && f.releaseVersion.trim()) {
                        allAvailableReleases.add(f.releaseVersion.trim());
                    }
                });
                const uncheckedReleases = [...allAvailableReleases].filter(r => !roadmapFilters.releases.includes(r));
                features = features.filter(f => !uncheckedReleases.includes(getFeatureReleaseCategory(f)));
            } else {
                features = features.filter(f => roadmapFilters.releases.includes(getFeatureReleaseCategory(f)));
            }
        }

        // Apply tag filter (unless excluded)
        if (excludeFilter !== 'tag' && roadmapFilters.tags.length > 0) {
            if (roadmapFilters.tagsExclusionMode) {
                const allAvailableTags = new Set();
                getRoadmapFeatures().forEach(f => {
                    const tags = (f.tags || '').split(';').map(t => t.trim()).filter(t => t);
                    tags.forEach(tag => allAvailableTags.add(tag));
                });
                const uncheckedTags = [...allAvailableTags].filter(t => !roadmapFilters.tags.includes(t));
                features = features.filter(f => {
                    const featureTags = (f.tags || '').split(';').map(t => t.trim()).filter(t => t);
                    return !featureTags.some(tag => uncheckedTags.includes(tag));
                });
            } else {
                features = features.filter(f => {
                    const featureTags = (f.tags || '').split(';').map(t => t.trim()).filter(t => t);
                    if (roadmapFilters.tagsLogicMode === 'and') {
                        return roadmapFilters.tags.every(selectedTag => featureTags.includes(selectedTag));
                    } else {
                        return roadmapFilters.tags.some(selectedTag => featureTags.includes(selectedTag));
                    }
                });
            }
        }

        return features;
    }

    // Get delivery slices filtered by current team/iteration filters
    function getFilteredDeliverySlices(featureIds) {
        let slices = getDeliverySlicesForFeatures(featureIds);

        // Apply team filter
        if (roadmapFilters.teams.length > 0) {
            slices = slices.filter(ds => {
                const team = getLastPathSegment(ds.areaPath) || '(No Team)';
                return roadmapFilters.teams.includes(team);
            });
        }

        // Apply iteration filter
        if (roadmapFilters.iterations.length > 0) {
            slices = slices.filter(ds => {
                const iteration = getLastPathSegment(ds.iterationPath) || '(No Iteration)';
                return roadmapFilters.iterations.includes(iteration);
            });
        }

        return slices;
    }

    function renderRoadmapView() {
        // Populate filter dropdowns on first render
        populateRoadmapFilterDropdowns();

        // If state was loaded from localStorage, sync dropdown checkboxes with loaded state
        if (stateWasLoaded) {
            syncRoadmapFilterDropdowns();
            stateWasLoaded = false; // Only sync once after state load
        }

        const features = getFilteredRoadmapFeatures();
        const allFeatures = getRoadmapFeatures();
        const countEl = document.getElementById('roadmap-count');
        const thead = document.getElementById('roadmap-table-head');
        const tbody = document.getElementById('roadmap-table-body');
        const effortCardsEl = document.getElementById('roadmap-effort-cards');

        // Update count (show filtered vs total if filtering)
        const isFiltered = roadmapFilters.search || roadmapFilters.states.length > 0 ||
                          roadmapFilters.customers.length > 0 || roadmapFilters.assignees.length > 0 ||
                          roadmapFilters.teams.length > 0 || roadmapFilters.iterations.length > 0 ||
                          roadmapFilters.priorities.length > 0 || roadmapFilters.releases.length > 0 ||
                          roadmapFilters.tags.length > 0;
        if (isFiltered) {
            countEl.innerHTML = `‚≠ê Feature Details (${features.length} of ${allFeatures.length})`;
        } else {
            countEl.innerHTML = `‚≠ê Feature Details (${features.length})`;
        }

        // Update clear button visibility
        const clearBtn = document.getElementById('roadmap-clear-filters-btn');
        if (clearBtn) {
            clearBtn.classList.toggle('hidden', !isFiltered);
        }

        // Calculate and render effort cards
        const featureIds = features.map(f => f.id);
        const filteredSlices = getFilteredDeliverySlices(featureIds);
        const { effortByTeam, totalEffort } = calculateEffortByTeam(filteredSlices);

        // Sort teams by effort (descending)
        const sortedTeams = Object.entries(effortByTeam)
            .sort((a, b) => b[1] - a[1]);

        // Calculate totals for the "All Teams" card
        const totalFeatures = features.length;
        const totalSlices = filteredSlices.length;
        const totalMembers = sortedTeams.reduce((sum, [team]) => sum + getRoadmapTeamMemberCount(team), 0);
        const totalCapacity = totalMembers * 22;

        // Build team cards HTML
        const teamCardsHtml = sortedTeams.map(([team, effort]) => {
            const lead = roadmapTeamLeads[team] || '';
            const memberCount = getRoadmapTeamMemberCount(team);
            const capacity = memberCount * 22;
            const { featureCount, sliceCount } = countItemsByTeam(features, filteredSlices, team);

            // Try to get lead photo if available
            const hasPhoto = typeof leadPhotos !== 'undefined' && leadPhotos[lead];
            const photoHtml = hasPhoto
                ? `<img src="data:image/jpeg;base64,${leadPhotos[lead]}" class="effort-card-lead-photo" alt="${lead}">`
                : `<div class="effort-card-lead-avatar">${getInitials(lead)}</div>`;

            // Get team color for this card
            const teamColor = typeof getTeamColor === 'function' ? getTeamColor(team) : '#94a3b8';

            // Check if this team is selected
            const isSelected = roadmapFilters.teams.length === 1 && roadmapFilters.teams[0] === team;
            const selectedClass = isSelected ? ' selected' : '';

            return `
                <div class="effort-card${selectedClass}" onclick="toggleRoadmapTeamCard('${team.replace(/'/g, "\\'")}')">
                    <div class="effort-card-header">
                        <div class="effort-card-label">${team}</div>
                    </div>
                    <div class="effort-card-value" style="color: ${teamColor}">${effort.toFixed(1)}<span class="effort-card-unit">d</span></div>
                    <div class="effort-card-capacity">of ${capacity}d monthly capacity</div>
                    <div class="effort-card-stats">
                        <span>${featureCount} Feature${featureCount !== 1 ? 's' : ''}</span>
                        <span>${sliceCount} Delivery Slice${sliceCount !== 1 ? 's' : ''}</span>
                    </div>
                    ${lead ? `
                    <div class="effort-card-footer">
                        ${photoHtml}
                        <span class="effort-card-lead-name">${lead}</span>
                    </div>
                    ` : ''}
                </div>
            `;
        }).join('');

        // Render effort cards
        effortCardsEl.innerHTML = `
            <div class="effort-card total" onclick="clearRoadmapTeamFilter()" title="Click to show all teams">
                <div class="effort-card-header">
                    <div class="effort-card-label">Total Effort</div>
                </div>
                <div class="effort-card-value">${totalEffort.toFixed(1)}<span class="effort-card-unit">days</span></div>
                <div class="effort-card-capacity">of ${totalCapacity}d monthly capacity</div>
                <div class="effort-card-stats">
                    <span>${totalFeatures} Feature${totalFeatures !== 1 ? 's' : ''}</span>
                    <span>${totalSlices} Delivery Slice${totalSlices !== 1 ? 's' : ''}</span>
                </div>
            </div>
            ${teamCardsHtml}
        `;

        // Define columns (ID, Title, State, Customers, Priority, Tags, Assigned To, Release, Effort)
        const roadmapColumns = [
            { key: 'id', label: 'ID', class: 'col-id' },
            { key: 'title', label: 'Title', class: 'col-title' },
            { key: 'state', label: 'State', class: 'col-state' },
            { key: 'customers', label: 'Customers', class: 'col-customers' },
            { key: 'priority', label: 'Priority', class: 'col-priority' },
            { key: 'tags', label: 'Tags', class: 'col-tags' },
            { key: 'assignedTo', label: 'Assigned To', class: 'col-assignee' },
            { key: 'releaseVersion', label: 'Release', class: 'col-release' },
            { key: 'effort', label: 'Effort', class: 'col-effort' }
        ];

        // Pre-calculate effort for each feature (sum of child delivery slices)
        // When team/iteration filters are active, only sum effort from matching slices
        const featureEffortMap = {};
        features.forEach(f => {
            const featureSlices = getDeliverySlicesForFeatures([f.id]);
            let relevantSlices = featureSlices;

            // If team filter is active, only count effort from that team
            if (roadmapFilters.teams.length > 0) {
                relevantSlices = relevantSlices.filter(ds => {
                    const dsTeam = getLastPathSegment(ds.areaPath) || '(No Team)';
                    return roadmapFilters.teams.includes(dsTeam);
                });
            }

            // If iteration filter is active, only count effort from that iteration
            if (roadmapFilters.iterations.length > 0) {
                relevantSlices = relevantSlices.filter(ds => {
                    const dsIteration = getLastPathSegment(ds.iterationPath) || '(No Iteration)';
                    return roadmapFilters.iterations.includes(dsIteration);
                });
            }

            featureEffortMap[f.id] = relevantSlices.reduce((sum, ds) => sum + (ds.effort || 0), 0);
        });

        // Render Strategy Summary (Section 1)
        renderStrategySummary(features, featureEffortMap);

        // Calculate effort label for header
        const teamLabel = roadmapFilters.teams.length === 1 ? roadmapFilters.teams[0] : 'All Teams';
        const iterationLabel = roadmapFilters.iterations.length === 1 ? roadmapFilters.iterations[0] : '';
        const effortFilterLabel = iterationLabel ? `${teamLabel} ¬∑ ${iterationLabel}` : teamLabel;

        // Custom cell renderer for Roadmap-specific columns (badges)
        const roadmapRenderCell = (item, col) => {
            const key = col.key;
            const colClass = col.class || `col-${key}`;

            if (key === 'id') {
                return `<td class="${colClass}"><a href="${item.url}" target="_blank" class="work-item-link" onclick="event.stopPropagation()">${item.id}</a></td>`;
            }
            if (key === 'title') {
                const slices = getDeliverySlicesForFeatures([item.id]);
                let badges = '';
                // Badge 0: Blocked tag
                const itemTags = (item.tags || '').split(';').map(t => t.trim().toLowerCase());
                if (itemTags.includes('blocked')) {
                    badges += `<span class="blocked-badge" title="This feature is tagged as Blocked">Blocked</span>`;
                }
                // Badge 1: No Delivery Slices
                if (slices.length === 0) {
                    badges += `<span class="no-slices-badge" title="This feature has no Delivery Slices">No slices</span>`;
                } else {
                    // Badge 2: Zero effort
                    const hasZeroEffort = slices.some(ds => !ds.effort || ds.effort === 0);
                    if (hasZeroEffort) {
                        const zeroEffortSlices = slices.filter(ds => !ds.effort || ds.effort === 0);
                        badges += `<span class="zero-effort-badge" title="${zeroEffortSlices.length} slice(s) with zero effort">0 effort</span>`;
                    }
                    // Badge 3: Multiple iterations
                    const iterationSet = new Set(slices.map(ds => getLastPathSegment(ds.iterationPath) || '(No Iteration)'));
                    if (iterationSet.size > 1) {
                        badges += `<span class="iteration-count-badge" title="${[...iterationSet].join(', ')}">${iterationSet.size} iterations</span>`;
                    }
                }
                return `<td class="${colClass}" title="${(item.title || '').replace(/"/g, '&quot;')}">${item.title || ''} ${badges}</td>`;
            }
            if (key === 'state') {
                return `<td class="${colClass}"><span class="state-badge ${getStateClass(item.state)}">${item.state || ''}</span></td>`;
            }
            if (key === 'customers') {
                return `<td class="${colClass}">${item.customers || ''}</td>`;
            }
            if (key === 'priority') {
                return `<td class="${colClass} priority-cell">${item.priority ? 'P' + item.priority : ''}</td>`;
            }
            if (key === 'tags') {
                const displayTags = (item.tags || '').split(';').map(t => t.trim()).filter(t => t).join(', ');
                return `<td class="${colClass} tags-cell" title="${displayTags}">${displayTags}</td>`;
            }
            if (key === 'assignedTo') {
                return `<td class="${colClass}">${item.assignedTo || ''}</td>`;
            }
            if (key === 'releaseVersion') {
                return `<td class="${colClass}">${item.releaseVersion || ''}</td>`;
            }
            if (key === 'effort') {
                const effort = featureEffortMap[item.id] || 0;
                return `<td class="${colClass} effort-value">${effort > 0 ? effort.toFixed(1) + 'd' : ''}</td>`;
            }
            return `<td class="${colClass}">${item[key] || ''}</td>`;
        };

        // Row click handler - show delivery slices + relationships
        const handleRoadmapRowClick = (item) => {
            const slices = getDeliverySlicesForFeatures([item.id]);
            const activeTeamFilter = roadmapFilters.teams.length === 1 ? roadmapFilters.teams[0] : null;
            const activeIterationFilter = roadmapFilters.iterations.length === 1 ? roadmapFilters.iterations[0] : null;
            showWorkItemDetailsModal(item, {
                deliverySlices: slices,
                activeTeamFilter,
                activeIterationFilter
            });
        };

        // Sort change handler
        const handleRoadmapSortChange = (column, direction) => {
            roadmapSortState.column = column;
            roadmapSortState.direction = direction;
            saveStateToStorage();
        };

        // Column resize handler
        const handleRoadmapColumnResize = (columnKey, width) => {
            roadmapColumnWidths[columnKey] = width;
            saveStateToStorage();
        };

        // Build the table using generic component
        buildGenericTable({
            containerId: 'roadmap-table-container',
            tableId: 'roadmap-table',
            icon: '‚≠ê',
            title: 'Feature Details',
            hideTitleBar: true,  // Title is in section header
            adoLink: 'https://dev.azure.com/ncryptedcloud/eShare/_backlogs/backlog/eShare%20Team/Features?showParents=false',
            adoLinkText: 'Link to ADO Feature Backlog',
            columns: roadmapColumns,
            items: features,
            sortState: roadmapSortState,
            defaultSort: { column: 'backlogPriority', direction: 'asc' },
            onSort: handleRoadmapSortChange,
            columnWidths: roadmapColumnWidths,
            onColumnResize: handleRoadmapColumnResize,
            hasEffort: true,
            effortMap: featureEffortMap,
            effortLabel: effortFilterLabel,
            onRowClick: handleRoadmapRowClick,
            rowClickHint: 'Click on a row to view delivery slices and relationships',
            renderCell: roadmapRenderCell,
            showTotalRow: true,
            totalColspan: 8
        });
    }

    function populateRoadmapFilterDropdowns() {
        const features = getRoadmapFeatures();
        const allSlices = getDeliverySlicesForFeatures(features.map(f => f.id));

        // Get unique values from features
        const states = [...new Set(features.map(f => f.state).filter(Boolean))].sort();
        const customersSet = new Set();
        features.forEach(f => {
            if (f.customers) {
                f.customers.split(';').forEach(c => {
                    const trimmed = c.trim();
                    if (trimmed) customersSet.add(trimmed);
                });
            } else {
                customersSet.add('(No Customer)');
            }
        });
        const customers = [...customersSet].sort();
        const assignees = [...new Set(features.map(f => f.assignedTo || '(Unassigned)'))].sort();

        // Get unique teams and iterations from delivery slices
        const teamsSet = new Set();
        const iterationsSet = new Set();
        allSlices.forEach(ds => {
            const team = getLastPathSegment(ds.areaPath);
            const iteration = getLastPathSegment(ds.iterationPath);
            if (team) teamsSet.add(team);
            else teamsSet.add('(No Team)');
            if (iteration) iterationsSet.add(iteration);
            else iterationsSet.add('(No Iteration)');
        });
        const teams = [...teamsSet].sort();
        const iterations = [...iterationsSet].sort();

        // Get unique priorities from features
        const prioritiesSet = new Set(['(No Priority)']);
        features.forEach(f => {
            if (f.priority) {
                prioritiesSet.add(String(f.priority));
            }
        });
        const priorities = [...prioritiesSet].sort((a, b) => {
            // Put "(No Priority)" last, then sort numerically
            if (a === '(No Priority)') return 1;
            if (b === '(No Priority)') return -1;
            return parseInt(a) - parseInt(b);
        });

        // Get unique release versions from features
        const releasesSet = new Set(['(No Release)']);  // Always include the "no release" option
        features.forEach(f => {
            if (f.releaseVersion && f.releaseVersion.trim()) {
                releasesSet.add(f.releaseVersion.trim());
            }
        });
        const releases = [...releasesSet].sort((a, b) => {
            // Put "(No Release)" first, then sort the rest alphabetically
            if (a === '(No Release)') return -1;
            if (b === '(No Release)') return 1;
            return a.localeCompare(b);
        });

        // Get unique tags from features
        const tagsSet = new Set();
        features.forEach(f => {
            if (f.tags) {
                f.tags.split(';').forEach(t => {
                    const trimmed = t.trim();
                    if (trimmed) tagsSet.add(trimmed);
                });
            }
        });
        const tags = [...tagsSet].sort();

        // Populate State dropdown using generic component (cross-filter aware)
        const stateMenu = document.getElementById('roadmap-state-menu');
        if (stateMenu) {
            const stateFilteredFeatures = getRoadmapFeaturesExcludingFilter('state');
            stateMenu.innerHTML = buildStateFilterDropdown({
                dashboardId: 'roadmap',
                items: stateFilteredFeatures,
                selectedStates: roadmapFilters.states
            });
        }

        // Populate Customer dropdown using generic component (cross-filter aware)
        const customerMenu = document.getElementById('roadmap-customer-menu');
        if (customerMenu) {
            const customerFilteredFeatures = getRoadmapFeaturesExcludingFilter('customer');
            customerMenu.innerHTML = buildCustomerFilterDropdown({
                dashboardId: 'roadmap',
                items: customerFilteredFeatures,
                selectedCustomers: roadmapFilters.customers
            });
        }

        // Populate Assignee dropdown (cross-filter aware with counts)
        const assigneeMenu = document.getElementById('roadmap-assignee-menu');
        if (assigneeMenu) {
            // Get features filtered by all filters EXCEPT assignee for cross-filter behavior
            const assigneeFilteredFeatures = getRoadmapFeaturesExcludingFilter('assignee');

            // Count features by assignee
            const assigneeCounts = {};
            assigneeFilteredFeatures.forEach(f => {
                const assignee = f.assignedTo || '(Unassigned)';
                assigneeCounts[assignee] = (assigneeCounts[assignee] || 0) + 1;
            });

            // Get sorted assignees with counts > 0
            const availableAssignees = Object.keys(assigneeCounts).sort((a, b) => {
                if (a === '(Unassigned)') return 1;
                if (b === '(Unassigned)') return -1;
                return a.localeCompare(b);
            });

            let assigneeHtml = `
                <div class="filter-dropdown-search">
                    <input type="text" placeholder="Search assignees..."
                           oninput="filterRoadmapDropdownOptions('assignee', this.value)"
                           onclick="event.stopPropagation();">
                </div>
                <div class="filter-dropdown-options" id="roadmap-assignee-options">
            `;

            availableAssignees.forEach(a => {
                const isChecked = roadmapFilters.assignees.includes(a);
                const escapedValue = a.replace(/"/g, '&quot;').replace(/'/g, "\\'");
                assigneeHtml += `
                    <label class="filter-dropdown-option" data-search-value="${a.toLowerCase()}" onclick="event.stopPropagation();">
                        <input type="checkbox" value="${a.replace(/"/g, '&quot;')}" ${isChecked ? 'checked' : ''}
                               onchange="handleRoadmapFilterChange('assignee', '${escapedValue}', this.checked)">
                        <span class="option-label">${a}</span>
                        <span class="option-count">${assigneeCounts[a]}</span>
                    </label>
                `;
            });

            assigneeHtml += `</div>`;
            assigneeHtml += `
                <div class="filter-dropdown-actions">
                    <button class="filter-btn-primary" onclick="selectAllRoadmapFilter('assignee')">Select All</button>
                    <button class="filter-btn-secondary" onclick="clearRoadmapFilter('assignee')">Clear</button>
                </div>
            `;
            assigneeMenu.innerHTML = assigneeHtml;
        }

        // Populate Team dropdown using generic component (cross-filter aware)
        const teamMenu = document.getElementById('roadmap-team-menu');
        if (teamMenu) {
            // Get features filtered by all filters EXCEPT team for cross-filter behavior
            const teamFilteredFeatures = getRoadmapFeaturesExcludingFilter('team');
            // Convert delivery slices to virtual items with team property for generic component
            const teamSlices = getDeliverySlicesForFeatures(teamFilteredFeatures.map(f => f.id));
            const teamItems = teamSlices.map(ds => ({
                team: getLastPathSegment(ds.areaPath) || null
            }));
            teamMenu.innerHTML = buildTeamFilterDropdown({
                dashboardId: 'roadmap',
                items: teamItems,
                selectedTeams: roadmapFilters.teams
            });
        }

        // Populate Iteration dropdown (cross-filter aware with counts)
        const iterationMenu = document.getElementById('roadmap-iteration-menu');
        if (iterationMenu) {
            // Get features filtered by all filters EXCEPT iteration for cross-filter behavior
            const iterationFilteredFeatures = getRoadmapFeaturesExcludingFilter('iteration');
            // Get delivery slices for these features to count iterations
            const iterationSlices = getDeliverySlicesForFeatures(iterationFilteredFeatures.map(f => f.id));

            // Count features by iteration (count unique feature IDs per iteration)
            const iterationFeatureCounts = {};
            iterationSlices.forEach(ds => {
                const iteration = getLastPathSegment(ds.iterationPath) || '(No Iteration)';
                if (!iterationFeatureCounts[iteration]) {
                    iterationFeatureCounts[iteration] = new Set();
                }
                iterationFeatureCounts[iteration].add(ds.parentId);
            });

            // Convert to count and sort
            const availableIterations = Object.keys(iterationFeatureCounts).sort((a, b) => {
                if (a === '(No Iteration)') return 1;
                if (b === '(No Iteration)') return -1;
                return a.localeCompare(b);
            });

            let iterationHtml = `
                <div class="filter-dropdown-search">
                    <input type="text" placeholder="Search iterations..."
                           oninput="filterRoadmapDropdownOptions('iteration', this.value)"
                           onclick="event.stopPropagation();">
                </div>
                <div class="filter-dropdown-options" id="roadmap-iteration-options">
            `;

            availableIterations.forEach(i => {
                const isChecked = roadmapFilters.iterations.includes(i);
                const count = iterationFeatureCounts[i].size;
                const escapedValue = i.replace(/"/g, '&quot;').replace(/'/g, "\\'");
                iterationHtml += `
                    <label class="filter-dropdown-option" data-search-value="${i.toLowerCase()}" onclick="event.stopPropagation();">
                        <input type="checkbox" value="${i.replace(/"/g, '&quot;')}" ${isChecked ? 'checked' : ''}
                               onchange="handleRoadmapFilterChange('iteration', '${escapedValue}', this.checked)">
                        <span class="option-label">${i}</span>
                        <span class="option-count">${count}</span>
                    </label>
                `;
            });

            iterationHtml += `</div>`;
            iterationHtml += `
                <div class="filter-dropdown-actions">
                    <button class="filter-btn-primary" onclick="selectAllRoadmapFilter('iteration')">Select All</button>
                    <button class="filter-btn-secondary" onclick="clearRoadmapFilter('iteration')">Clear</button>
                </div>
            `;
            iterationMenu.innerHTML = iterationHtml;
        }

        // Populate Priority dropdown using generic component (cross-filter aware)
        const priorityMenu = document.getElementById('roadmap-priority-menu');
        if (priorityMenu) {
            // Get features filtered by all filters EXCEPT priority for cross-filter behavior
            const priorityFilteredFeatures = getRoadmapFeaturesExcludingFilter('priority');
            priorityMenu.innerHTML = buildPriorityFilterDropdown({
                dashboardId: 'roadmap',
                items: priorityFilteredFeatures,
                selectedPriorities: roadmapFilters.priorities
            });
        }

        // Populate Release dropdown using generic component (cross-filter aware)
        const releaseMenu = document.getElementById('roadmap-release-menu');
        if (releaseMenu) {
            const releaseFilteredFeatures = getRoadmapFeaturesExcludingFilter('release');
            releaseMenu.innerHTML = buildReleaseFilterDropdown({
                dashboardId: 'roadmap',
                items: releaseFilteredFeatures,
                selectedReleases: roadmapFilters.releases
            });
        }

        // Populate Tag dropdown (cross-filter aware with counts)
        const tagMenu = document.getElementById('roadmap-tag-menu');
        if (tagMenu) {
            // Get features filtered by all filters EXCEPT tag for cross-filter behavior
            const tagFilteredFeatures = getRoadmapFeaturesExcludingFilter('tag');

            // Count features by tag
            const tagCounts = {};
            tagFilteredFeatures.forEach(f => {
                if (f.tags) {
                    f.tags.split(';').forEach(t => {
                        const tag = t.trim();
                        if (tag) {
                            tagCounts[tag] = (tagCounts[tag] || 0) + 1;
                        }
                    });
                }
            });

            // Get sorted tags with counts > 0
            const availableTags = Object.keys(tagCounts).sort((a, b) => a.localeCompare(b));

            let tagHtml = `
                <div class="filter-dropdown-search">
                    <input type="text" placeholder="Search tags..."
                           oninput="filterRoadmapDropdownOptions('tag', this.value)"
                           onclick="event.stopPropagation();">
                </div>
                <div class="tag-logic-toggle" onclick="event.stopPropagation();">
                    <span class="tag-logic-label">Match:</span>
                    <button class="tag-logic-btn ${roadmapFilters.tagsLogicMode === 'or' ? 'active' : ''}" onclick="setTagLogicMode('or')">Any (OR)</button>
                    <button class="tag-logic-btn ${roadmapFilters.tagsLogicMode === 'and' ? 'active' : ''}" onclick="setTagLogicMode('and')">All (AND)</button>
                </div>
                <div class="filter-dropdown-options" id="roadmap-tag-options">
            `;

            availableTags.forEach(t => {
                const isChecked = roadmapFilters.tags.includes(t);
                const escapedValue = t.replace(/"/g, '&quot;').replace(/'/g, "\\'");
                tagHtml += `
                    <label class="filter-dropdown-option" data-search-value="${t.toLowerCase()}" onclick="event.stopPropagation();">
                        <input type="checkbox" value="${t.replace(/"/g, '&quot;')}" ${isChecked ? 'checked' : ''}
                               onchange="handleRoadmapFilterChange('tag', '${escapedValue}', this.checked)">
                        <span class="option-label">${t}</span>
                        <span class="option-count">${tagCounts[t]}</span>
                    </label>
                `;
            });

            tagHtml += `</div>`;
            tagHtml += `
                <div class="filter-dropdown-actions">
                    <button class="filter-btn-primary" onclick="selectAllRoadmapFilter('tag')">Select All</button>
                    <button class="filter-btn-secondary" onclick="clearRoadmapFilter('tag')">Clear</button>
                </div>
            `;
            tagMenu.innerHTML = tagHtml;
        }
    }

    // Toggle between AND/OR logic for tag filter
    function setTagLogicMode(mode) {
        roadmapFilters.tagsLogicMode = mode;
        // Update button states
        document.querySelectorAll('.tag-logic-btn').forEach(btn => {
            btn.classList.toggle('active', btn.textContent.toLowerCase().includes(mode));
        });
        renderRoadmapView();
        saveStateToStorage(); // Persist logic mode change
    }

    // Sync all roadmap filter dropdown checkboxes with current filter state
    // Called after state is loaded from localStorage to update UI
    function syncRoadmapFilterDropdowns() {
        // Filters handled by dashboard-specific logic (excludes generic components)
        const filterTypes = ['assignee', 'iteration', 'tag'];
        const filterKeyMap = {
            'assignee': 'assignees',
            'iteration': 'iterations',
            'tag': 'tags'
        };

        filterTypes.forEach(type => {
            const optionsContainer = document.getElementById(`roadmap-${type}-options`);
            if (!optionsContainer) return;

            const filterKey = filterKeyMap[type];
            const selectedValues = roadmapFilters[filterKey] || [];

            optionsContainer.querySelectorAll('.filter-dropdown-option').forEach(opt => {
                const cb = opt.querySelector('input[type="checkbox"]');
                // Use value attribute for checkbox matching
                const matchValue = cb?.value || opt.querySelector('.option-label')?.textContent;
                if (cb && matchValue) {
                    cb.checked = selectedValues.includes(matchValue);
                }
            });

            updateRoadmapFilterDisplay(type);
        });

        // Sync generic components (customer, priority, release, state, team)
        syncGenericCustomerFilter('roadmap');
        syncGenericPriorityFilter('roadmap');
        syncGenericReleaseFilter('roadmap');
        syncGenericStateFilter('roadmap');
        syncGenericTeamFilter('roadmap');

        // Sync tag logic mode buttons
        document.querySelectorAll('.tag-logic-btn').forEach(btn => {
            const isOrBtn = btn.textContent.includes('OR');
            const isAndBtn = btn.textContent.includes('AND');
            btn.classList.toggle('active',
                (isOrBtn && roadmapFilters.tagsLogicMode === 'or') ||
                (isAndBtn && roadmapFilters.tagsLogicMode === 'and')
            );
        });

        // Sync search input using generic component
        syncGenericSearchFilter('roadmap');
    }

    function filterRoadmapDropdownOptions(filterType, searchText) {
        const optionsContainer = document.getElementById(`roadmap-${filterType}-options`);
        if (!optionsContainer) return;

        const options = optionsContainer.querySelectorAll('.filter-dropdown-option');
        const searchLower = searchText.toLowerCase();

        options.forEach(opt => {
            const label = opt.querySelector('.option-label')?.textContent || '';
            opt.style.display = label.toLowerCase().includes(searchLower) ? '' : 'none';
        });
    }

    // New handler for label-based filter options (onchange on checkbox)
    function handleRoadmapFilterChange(filterType, value, checked) {
        const filterKey = getFilterKey(filterType);

        if (checked) {
            if (!roadmapFilters[filterKey].includes(value)) {
                roadmapFilters[filterKey].push(value);
            }
        } else {
            roadmapFilters[filterKey] = roadmapFilters[filterKey].filter(v => v !== value);
            // Reset exclusion mode if all tags/releases are unchecked
            if (filterType === 'tag' && roadmapFilters.tags.length === 0) {
                roadmapFilters.tagsExclusionMode = false;
            }
            if (filterType === 'release' && roadmapFilters.releases.length === 0) {
                roadmapFilters.releasesExclusionMode = false;
            }
        }

        updateRoadmapFilterDisplay(filterType);
        renderRoadmapView();
        saveStateToStorage(); // Persist filter changes
    }

    // Legacy handler - kept for compatibility but now using handleRoadmapFilterChange
    function toggleRoadmapFilter(filterType, value, element) {
        const checkbox = element.querySelector('input[type="checkbox"]');
        checkbox.checked = !checkbox.checked;
        handleRoadmapFilterChange(filterType, value, checkbox.checked);
    }

    function getFilterKey(filterType) {
        const keyMap = {
            'state': 'states',
            'customer': 'customers',
            'assignee': 'assignees',
            'team': 'teams',
            'iteration': 'iterations',
            'priority': 'priorities',
            'release': 'releases',
            'tag': 'tags'
        };
        return keyMap[filterType] || filterType;
    }

    function getFilterLabel(filterType) {
        const labelMap = {
            'state': 'All States',
            'customer': 'All Customers',
            'assignee': 'All Assignees',
            'team': 'All Teams',
            'iteration': 'All Iterations',
            'priority': 'All Priorities',
            'release': 'All Releases',
            'tag': 'All Tags'
        };
        return labelMap[filterType] || 'All';
    }

    function updateRoadmapFilterDisplay(filterType) {
        const filterKey = getFilterKey(filterType);
        const displayEl = document.getElementById(`roadmap-${filterType}-display`);
        const selected = roadmapFilters[filterKey];

        if (selected.length === 0) {
            displayEl.textContent = getFilterLabel(filterType);
        } else if (selected.length === 1) {
            displayEl.textContent = selected[0];
        } else {
            displayEl.textContent = `${selected.length} selected`;
        }
    }

    function clearRoadmapFilter(filterType) {
        const filterKey = getFilterKey(filterType);
        roadmapFilters[filterKey] = [];

        // Reset exclusion mode when clearing tag/release filter
        if (filterType === 'tag') {
            roadmapFilters.tagsExclusionMode = false;
        }
        if (filterType === 'release') {
            roadmapFilters.releasesExclusionMode = false;
        }

        // Uncheck all checkboxes
        const optionsContainer = document.getElementById(`roadmap-${filterType}-options`);
        if (optionsContainer) {
            optionsContainer.querySelectorAll('input[type="checkbox"]').forEach(cb => cb.checked = false);
        }

        updateRoadmapFilterDisplay(filterType);
        renderRoadmapView();
        saveStateToStorage(); // Persist filter changes
    }

    function selectAllRoadmapFilter(filterType) {
        const filterKey = getFilterKey(filterType);
        const optionsContainer = document.getElementById(`roadmap-${filterType}-options`);
        if (!optionsContainer) return;

        // Check all visible checkboxes and collect their values
        const values = [];
        optionsContainer.querySelectorAll('.filter-dropdown-option').forEach(opt => {
            if (opt.style.display !== 'none') {
                const cb = opt.querySelector('input[type="checkbox"]');
                const label = opt.querySelector('.option-label')?.textContent;
                if (cb && label) {
                    cb.checked = true;
                    values.push(label);
                }
            }
        });

        roadmapFilters[filterKey] = values;

        // For tag/release filter, entering exclusion mode when Select All is clicked
        if (filterType === 'tag') {
            roadmapFilters.tagsExclusionMode = true;
        }
        if (filterType === 'release') {
            roadmapFilters.releasesExclusionMode = true;
        }

        updateRoadmapFilterDisplay(filterType);
        renderRoadmapView();
        saveStateToStorage(); // Persist filter changes
    }

    function closeRoadmapDropdown(dropdownId) {
        const menu = document.getElementById(dropdownId)?.querySelector('.filter-dropdown-menu');
        if (menu) menu.classList.remove('open');
    }

    // Toggle team filter when clicking on a team card
    function toggleRoadmapTeamCard(team) {
        // If this team is already selected alone, clear it
        if (roadmapFilters.teams.length === 1 && roadmapFilters.teams[0] === team) {
            roadmapFilters.teams = [];
        } else {
            // Select only this team
            roadmapFilters.teams = [team];
        }

        // Sync the team dropdown checkboxes
        syncRoadmapTeamDropdown();
        updateRoadmapFilterDisplay('team');
        renderRoadmapView();
        saveStateToStorage(); // Persist filter changes
    }

    // Clear team filter (when clicking Total card)
    function clearRoadmapTeamFilter() {
        roadmapFilters.teams = [];
        syncRoadmapTeamDropdown();
        updateRoadmapFilterDisplay('team');
        renderRoadmapView();
        saveStateToStorage(); // Persist filter changes
    }

    // Toggle Team Summary section collapse state
    function toggleRoadmapTeamSummary() {
        const section = document.getElementById('roadmap-section-teams');
        if (section) {
            section.classList.toggle('collapsed');
            roadmapTeamSummaryCollapsed = section.classList.contains('collapsed');
            saveStateToStorage(); // Persist collapse state
        }
    }

    // Sync the team dropdown checkboxes with roadmapFilters.teams
    function syncRoadmapTeamDropdown() {
        const optionsContainer = document.getElementById('roadmap-team-options');
        if (!optionsContainer) return;

        optionsContainer.querySelectorAll('.filter-dropdown-option').forEach(opt => {
            const cb = opt.querySelector('input[type="checkbox"]');
            const label = opt.querySelector('.option-label')?.textContent;
            if (cb && label) {
                cb.checked = roadmapFilters.teams.includes(label);
            }
        });
    }

    function clearAllRoadmapFilters() {
        // Clear search using generic component
        clearGenericSearch('roadmap');

        // Clear all filter arrays
        roadmapFilters.states = [];
        roadmapFilters.customers = [];
        roadmapFilters.assignees = [];
        roadmapFilters.teams = [];
        roadmapFilters.iterations = [];
        roadmapFilters.priorities = [];
        roadmapFilters.releases = [];
        roadmapFilters.releasesExclusionMode = false;
        roadmapFilters.tags = [];
        roadmapFilters.tagsExclusionMode = false;
        // Note: tagsLogicMode is not reset - user preference is preserved

        // Reset dashboard-specific dropdowns (excludes generic components)
        ['assignee', 'iteration', 'tag'].forEach(type => {
            const optionsContainer = document.getElementById(`roadmap-${type}-options`);
            if (optionsContainer) {
                optionsContainer.querySelectorAll('input[type="checkbox"]').forEach(cb => cb.checked = false);
            }
            updateRoadmapFilterDisplay(type);
        });

        // Reset generic component dropdowns (customer, priority, release, state, team)
        ['customer', 'priority', 'release', 'state', 'team'].forEach(type => {
            const optionsContainer = document.getElementById(`roadmap-${type}-options`);
            if (optionsContainer) {
                optionsContainer.querySelectorAll('input[type="checkbox"]').forEach(cb => cb.checked = false);
            }
        });
        updateGenericCustomerDisplay('roadmap');
        updateGenericPriorityDisplay('roadmap');
        updateGenericReleaseDisplay('roadmap');
        updateGenericStateDisplay('roadmap');
        updateGenericTeamDisplay('roadmap');

        renderRoadmapView();
        saveStateToStorage(); // Persist filter changes
    }

    function applyRoadmapFilters() {
        const searchInput = document.getElementById('roadmap-search-input');
        roadmapFilters.search = searchInput ? searchInput.value : '';
        renderRoadmapView();
        saveStateToStorage(); // Persist filter changes
    }

    function getRoadmapColumnClass(key) {
        const classMap = {
            'id': 'col-id',
            'title': 'col-title',
            'state': 'col-state',
            'customers': 'col-customers',
            'priority': 'col-priority',
            'tags': 'col-tags',
            'assignedTo': 'col-assignee',
            'releaseVersion': 'col-release',
            'effort': 'col-effort'
        };
        return classMap[key] || '';
    }

    function sortRoadmapTable(columnKey) {
        // Toggle direction if same column, otherwise set to asc
        if (roadmapSortState.column === columnKey) {
            roadmapSortState.direction = roadmapSortState.direction === 'asc' ? 'desc' : 'asc';
        } else {
            roadmapSortState.column = columnKey;
            roadmapSortState.direction = 'asc';
        }
        renderRoadmapView();
        saveStateToStorage(); // Persist sort changes
    }

    function getRoadmapSortIndicator(columnKey) {
        if (roadmapSortState.column !== columnKey) return '';
        return roadmapSortState.direction === 'asc' ? '‚ñ≤' : '‚ñº';
    }

    function sortRoadmapItems(items, column, direction, effortMap) {
        return [...items].sort((a, b) => {
            let aVal, bVal;

            // Handle effort column specially - uses calculated effort map
            if (column === 'effort' && effortMap) {
                aVal = effortMap[a.id] || 0;
                bVal = effortMap[b.id] || 0;
            } else {
                aVal = a[column];
                bVal = b[column];
            }

            // Handle null/undefined
            if (aVal == null) aVal = '';
            if (bVal == null) bVal = '';

            // Handle numbers (id, effort)
            if (column === 'id' || column === 'effort') {
                aVal = parseFloat(aVal) || 0;
                bVal = parseFloat(bVal) || 0;
            } else {
                // Handle strings
                aVal = String(aVal).toLowerCase();
                bVal = String(bVal).toLowerCase();
            }

            if (aVal < bVal) return direction === 'asc' ? -1 : 1;
            if (aVal > bVal) return direction === 'asc' ? 1 : -1;
            return 0;
        });
    }

    function resetRoadmapSort() {
        roadmapSortState.column = null;
        roadmapSortState.direction = 'asc';
        renderRoadmapView();
        saveStateToStorage(); // Persist sort changes
    }

    // Show delivery slices for a feature in a modal
    function drilldownFeatureSlices(featureId, featureTitle) {
        const slices = getDeliverySlicesForFeatures([featureId]);
        const modal = document.getElementById('feature-slices-modal');
        const titleEl = document.getElementById('feature-modal-title');
        const contentEl = document.getElementById('feature-modal-content');

        if (!modal || !titleEl || !contentEl) {
            console.error('[Roadmap] Modal elements not found');
            return;
        }

        // Set title
        titleEl.textContent = `Feature ${featureId}: ${featureTitle}`;

        if (slices.length === 0) {
            contentEl.innerHTML = `<div class="feature-modal-empty">No Delivery Slices found for this Feature.</div>`;
        } else {
            // Check if team/iteration filters are active
            const activeTeamFilter = roadmapFilters.teams.length === 1 ? roadmapFilters.teams[0] : null;
            const activeIterationFilter = roadmapFilters.iterations.length === 1 ? roadmapFilters.iterations[0] : null;

            // Sort slices: matching filters first, then others
            let sortedSlices = [...slices];
            sortedSlices.sort((a, b) => {
                const teamA = a.team || getLastPathSegment(a.areaPath) || '(No Team)';
                const teamB = b.team || getLastPathSegment(b.areaPath) || '(No Team)';
                const iterA = a.iteration || getLastPathSegment(a.iterationPath) || '(No Iteration)';
                const iterB = b.iteration || getLastPathSegment(b.iterationPath) || '(No Iteration)';

                // Calculate match score (higher = better match)
                const matchA = (activeTeamFilter && teamA === activeTeamFilter ? 2 : 0) +
                               (activeIterationFilter && iterA === activeIterationFilter ? 1 : 0);
                const matchB = (activeTeamFilter && teamB === activeTeamFilter ? 2 : 0) +
                               (activeIterationFilter && iterB === activeIterationFilter ? 1 : 0);

                return matchB - matchA;  // Higher score first
            });

            // Calculate effort summary
            let filteredEffort = 0;
            let totalEffort = 0;
            sortedSlices.forEach(ds => {
                const effort = ds.effort || 0;
                totalEffort += effort;
                const dsTeam = ds.team || getLastPathSegment(ds.areaPath) || '(No Team)';
                const dsIteration = ds.iteration || getLastPathSegment(ds.iterationPath) || '(No Iteration)';
                const teamMatch = !activeTeamFilter || dsTeam === activeTeamFilter;
                const iterationMatch = !activeIterationFilter || dsIteration === activeIterationFilter;
                if (teamMatch && iterationMatch) {
                    filteredEffort += effort;
                }
            });

            // Build effort summary HTML
            let effortSummaryHtml = '';
            const hasFilters = activeTeamFilter || activeIterationFilter;
            if (hasFilters) {
                const filterLabels = [];
                if (activeTeamFilter) filterLabels.push(activeTeamFilter);
                if (activeIterationFilter) filterLabels.push(activeIterationFilter);
                effortSummaryHtml = `
                    <div class="feature-modal-effort-summary">
                        <span class="effort-team-label">${filterLabels.join(' ¬∑ ')} Effort:</span>
                        <span class="effort-team-value">${filteredEffort.toFixed(1)}d</span>
                        <span class="effort-total-label">/ Total:</span>
                        <span class="effort-total-value">${totalEffort.toFixed(1)}d</span>
                    </div>
                `;
            } else {
                effortSummaryHtml = `
                    <div class="feature-modal-effort-summary">
                        <span class="effort-total-label">Total Effort:</span>
                        <span class="effort-total-value">${totalEffort.toFixed(1)}d</span>
                    </div>
                `;
            }

            // Build table rows
            const rows = sortedSlices.map(ds => {
                const iteration = ds.iteration || getLastPathSegment(ds.iterationPath) || '‚Äî';
                const team = ds.team || getLastPathSegment(ds.areaPath) || '‚Äî';

                // Determine if this row should be grayed out (doesn't match active filters)
                const teamMatch = !activeTeamFilter || team === activeTeamFilter;
                const iterationMatch = !activeIterationFilter || iteration === activeIterationFilter;
                const isOtherRow = !teamMatch || !iterationMatch;
                const rowClass = isOtherRow ? 'other-team-row' : '';

                return `
                    <tr class="${rowClass}">
                        <td class="feature-modal-col-id"><a href="${ds.url}" target="_blank" class="work-item-id">${ds.id}</a></td>
                        <td class="feature-modal-col-title" title="${(ds.title || '').replace(/"/g, '&quot;')}">${ds.title || ''}</td>
                        <td class="feature-modal-col-state"><span class="state-badge ${getStateClass(ds.state)}">${ds.state || ''}</span></td>
                        <td class="feature-modal-col-iteration">${iteration}</td>
                        <td class="feature-modal-col-team">${team}</td>
                        <td class="feature-modal-col-effort">${ds.effort || '‚Äî'}</td>
                        <td class="feature-modal-col-owner">${ds.assignedTo || '‚Äî'}</td>
                    </tr>
                `;
            }).join('');

            // Use separate header and body tables for fixed header
            contentEl.innerHTML = `
                ${effortSummaryHtml}
                <div class="feature-modal-table-container">
                    <div class="feature-modal-table-header">
                        <table>
                            <colgroup>
                                <col class="feature-modal-col-id">
                                <col class="feature-modal-col-title">
                                <col class="feature-modal-col-state">
                                <col class="feature-modal-col-iteration">
                                <col class="feature-modal-col-team">
                                <col class="feature-modal-col-effort">
                                <col class="feature-modal-col-owner">
                            </colgroup>
                            <thead>
                                <tr>
                                    <th>ID</th>
                                    <th>Title</th>
                                    <th>State</th>
                                    <th>Iteration</th>
                                    <th>Team</th>
                                    <th>Effort</th>
                                    <th>Owner</th>
                                </tr>
                            </thead>
                        </table>
                    </div>
                    <div class="feature-modal-table-body">
                        <table>
                            <colgroup>
                                <col class="feature-modal-col-id">
                                <col class="feature-modal-col-title">
                                <col class="feature-modal-col-state">
                                <col class="feature-modal-col-iteration">
                                <col class="feature-modal-col-team">
                                <col class="feature-modal-col-effort">
                                <col class="feature-modal-col-owner">
                            </colgroup>
                            <tbody>${rows}</tbody>
                        </table>
                    </div>
                </div>
            `;
        }

        // Show modal
        modal.style.display = 'flex';
    }

    // Scroll-to-close for roadmap dropdowns
    let roadmapScrollHandler = null;

    function setupRoadmapScrollToClose() {
        if (roadmapScrollHandler) return;

        roadmapScrollHandler = () => {
            // Close all roadmap dropdowns on scroll
            ['roadmap-state-dropdown', 'roadmap-customer-dropdown', 'roadmap-assignee-dropdown',
             'roadmap-team-dropdown', 'roadmap-iteration-dropdown', 'roadmap-release-dropdown', 'roadmap-tag-dropdown'].forEach(id => {
                const menu = document.getElementById(id)?.querySelector('.filter-dropdown-menu');
                if (menu && menu.classList.contains('open')) {
                    menu.classList.remove('open');
                }
            });
        };

        window.addEventListener('scroll', roadmapScrollHandler, { passive: true });
    }

    // Initialize scroll-to-close when DOM is ready
    if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', setupRoadmapScrollToClose);
    } else {
        setupRoadmapScrollToClose();
    }
</script>
