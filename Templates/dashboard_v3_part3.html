<script>
    // Executive View filter helper
    function getFilteredExecItems() {
        const teamFilter = document.getElementById('exec-team-filter')?.value || 'all';
        const typeFilter = document.getElementById('exec-type-filter')?.value || 'all';
        
        let items = workItems;
        
        if (teamFilter !== 'all') {
            items = items.filter(w => w.team === teamFilter);
        }
        
        if (typeFilter !== 'all') {
            items = items.filter(w => w.type === typeFilter);
        }
        
        return items;
    }
    
    function applyExecFilters() {
        renderExecutiveView();
    }
    
    // Executive View
    function renderExecutiveView() {
        const stats = document.getElementById('exec-stats');
        const insights = document.getElementById('exec-insights');
        const charts = document.getElementById('exec-charts');
        
        const filteredItems = getFilteredExecItems();
        const teamFilter = document.getElementById('exec-team-filter')?.value || 'all';
        const typeFilter = document.getElementById('exec-type-filter')?.value || 'all';
        const isFiltered = teamFilter !== 'all' || typeFilter !== 'all';
        
        // Calculate metrics
        const total = filteredItems.length;
        const done = filteredItems.filter(w => w.state === 'Done' || w.state === 'Closed').length;
        const inProgress = filteredItems.filter(w => w.state === 'In Progress').length;
        const bugs = filteredItems.filter(w => w.type === 'Bug');
        const openBugs = bugs.filter(b => b.state !== 'Done' && b.state !== 'Closed' && b.state !== 'Removed');
        const blocked = filteredItems.filter(w => (w.tags || '').toLowerCase().includes('blocked'));
        const unassigned = filteredItems.filter(w => !w.assignedTo && w.state !== 'Done' && w.state !== 'Closed' && w.state !== 'Removed');
        
        const filterNote = isFiltered ? ' (filtered)' : '';
        
        stats.innerHTML = `
            <div class="stat-card clickable" onclick="drilldownStat('total')">
                <div class="stat-label">Total Work Items${filterNote}</div>
                <div class="stat-value" style="color: var(--accent-cyan)">${total}</div>
                <div class="stat-subtitle">${done} completed (${total > 0 ? Math.round(done/total*100) : 0}%)</div>
            </div>
            <div class="stat-card clickable" onclick="drilldownStat('inProgress')">
                <div class="stat-label">In Progress</div>
                <div class="stat-value" style="color: var(--accent-blue)">${inProgress}</div>
                <div class="stat-subtitle">Active work items</div>
            </div>
            <div class="stat-card clickable" onclick="drilldownStat('openBugs')">
                <div class="stat-label">Open Bugs</div>
                <div class="stat-value" style="color: var(--accent-red)">${openBugs.length}</div>
                <div class="stat-subtitle">${bugs.length} total bugs</div>
            </div>
            <div class="stat-card clickable" onclick="drilldownStat('blocked')">
                <div class="stat-label">Blocked Items</div>
                <div class="stat-value" style="color: var(--accent-orange)">${blocked.length}</div>
                <div class="stat-subtitle">Need attention</div>
            </div>
            <div class="stat-card clickable" onclick="drilldownStat('unassigned')">
                <div class="stat-label">Unassigned</div>
                <div class="stat-value" style="color: var(--text-muted)">${unassigned.length}</div>
                <div class="stat-subtitle">Active items without owner</div>
            </div>
        `;
        
        // Key insights
        const novemberItems = filteredItems.filter(w => (w.iterationPath || '').includes('CY2025Q4-Nov'));
        const novemberDone = novemberItems.filter(w => w.state === 'Done' || w.state === 'Closed').length;
        const novemberPct = novemberItems.length > 0 ? Math.round(novemberDone / novemberItems.length * 100) : 0;
        const novemberRemaining = novemberItems.length - novemberDone;
        
        // Find most loaded person
        const assigneeCounts = countBy(filteredItems.filter(w => w.assignedTo && w.state !== 'Done' && w.state !== 'Closed'), 'assignedTo');
        const topAssignee = Object.entries(assigneeCounts).sort((a, b) => b[1] - a[1])[0];
        
        insights.innerHTML = `
            <div class="insights-title">‚ö° Key Insights${filterNote}</div>
            ${novemberItems.length > 0 ? `
            <div class="insight-item ${novemberPct < 60 ? 'warning' : ''}">
                <span class="insight-icon">${novemberPct < 60 ? '‚ö†Ô∏è' : 'üìä'}</span> 
                November completion at ${novemberPct}% (${novemberRemaining} items remaining of ${novemberItems.length})
            </div>
            ` : ''}
            <div class="insight-item critical"><span class="insight-icon">üî¥</span> ${openBugs.length} open bugs need resolution</div>
            <div class="insight-item warning"><span class="insight-icon">üë§</span> ${unassigned.length} active items without owners</div>
            <div class="insight-item warning"><span class="insight-icon">üö´</span> ${blocked.length} items are blocked</div>
            ${topAssignee ? `<div class="insight-item info"><span class="insight-icon">üìã</span> ${topAssignee[0]} has ${topAssignee[1]} active items assigned</div>` : ''}
        `;
        
        // Charts - sorted by value
        const byType = sortObjectByValue(countBy(filteredItems, 'type'));
        const byState = sortObjectByValue(countBy(filteredItems, 'state'));
        const byTeam = sortObjectByValue(countBy(filteredItems.filter(w => w.team && w.team !== 'eShare'), 'team'));
        
        // Get all unique values for filters
        const allTypes = Object.keys(byType);
        const allStates = ['New', 'Triaged', 'To Do', 'In Progress', 'Ready For Review', 'Done', 'Closed', 'Removed'];
        const allTeams = Object.keys(byTeam);
        
        // Apply chart filters
        const chartFilteredItems = getExecChartFilteredItems(filteredItems);
        const filteredByType = sortObjectByValue(countBy(chartFilteredItems, 'type'));
        const filteredByState = sortObjectByValue(countBy(chartFilteredItems, 'state'));
        const filteredByTeam = sortObjectByValue(countBy(chartFilteredItems.filter(w => w.team && w.team !== 'eShare'), 'team'));
        
        charts.innerHTML = `
            <div class="chart-card">
                <div class="chart-title">Work Items by Type</div>
                <div class="chart-container"><canvas id="exec-type-chart"></canvas></div>
                <div class="chart-filter">
                    <div class="multi-select-dropdown" id="exec-chart-type-dropdown">
                        <div class="multi-select-display" onclick="toggleExecFilter('type')">
                            <span id="exec-chart-type-display">All Types</span>
                            <span class="dropdown-arrow">‚ñº</span>
                        </div>
                        <div class="multi-select-options" id="exec-chart-type-options">
                            <label class="checkbox-option select-all-option"><input type="checkbox" id="exec-chart-type-select-all" onchange="toggleAllExecFilter('type', this.checked)"> <strong>Select All</strong></label>
                            <div class="checkbox-divider"></div>
                            ${allTypes.map(t => `<label class="checkbox-option"><input type="checkbox" value="${t}" onchange="updateExecFilter('type')"> ${t}</label>`).join('')}
                        </div>
                    </div>
                </div>
            </div>
            <div class="chart-card">
                <div class="chart-title">Work Items by State</div>
                <div class="chart-container"><canvas id="exec-state-chart"></canvas></div>
                <div class="chart-filter">
                    <div class="multi-select-dropdown" id="exec-chart-state-dropdown">
                        <div class="multi-select-display" onclick="toggleExecFilter('state')">
                            <span id="exec-chart-state-display">All States</span>
                            <span class="dropdown-arrow">‚ñº</span>
                        </div>
                        <div class="multi-select-options" id="exec-chart-state-options">
                            <label class="checkbox-option select-all-option"><input type="checkbox" id="exec-chart-state-select-all" onchange="toggleAllExecFilter('state', this.checked)"> <strong>Select All</strong></label>
                            <div class="checkbox-divider"></div>
                            ${allStates.map(s => `<label class="checkbox-option"><input type="checkbox" value="${s}" onchange="updateExecFilter('state')"> ${s}</label>`).join('')}
                        </div>
                    </div>
                </div>
            </div>
            <div class="chart-card">
                <div class="chart-title">Work Items by Team</div>
                <div class="chart-container"><canvas id="exec-team-chart"></canvas></div>
                <div class="chart-filter">
                    <div class="multi-select-dropdown" id="exec-chart-team-dropdown">
                        <div class="multi-select-display" onclick="toggleExecFilter('team')">
                            <span id="exec-chart-team-display">All Teams</span>
                            <span class="dropdown-arrow">‚ñº</span>
                        </div>
                        <div class="multi-select-options" id="exec-chart-team-options">
                            <label class="checkbox-option select-all-option"><input type="checkbox" id="exec-chart-team-select-all" onchange="toggleAllExecFilter('team', this.checked)"> <strong>Select All</strong></label>
                            <div class="checkbox-divider"></div>
                            ${allTeams.map(t => `<label class="checkbox-option"><input type="checkbox" value="${t}" onchange="updateExecFilter('team')"> ${t}</label>`).join('')}
                        </div>
                    </div>
                </div>
            </div>
        `;
        
        // Restore filter states after HTML rebuild
        restoreExecFilterStates();
        
        setTimeout(() => {
            createClickableChart('exec-type-chart', 'doughnut', filteredByType, 'type', null, chartFilteredItems);
            createClickableChart('exec-state-chart', 'doughnut', filteredByState, 'state', colors.states, chartFilteredItems);
            createClickableChart('exec-team-chart', 'bar', filteredByTeam, 'team', colors.teams, chartFilteredItems);
        }, 50);
    }
    
    function drilldownStat(statType) {
        const filteredItems = getFilteredExecItems();
        let items, title;
        
        switch(statType) {
            case 'total':
                items = filteredItems;
                title = 'All Work Items';
                break;
            case 'inProgress':
                items = filteredItems.filter(w => w.state === 'In Progress');
                title = 'In Progress Items';
                break;
            case 'openBugs':
                items = filteredItems.filter(w => w.type === 'Bug' && w.state !== 'Done' && w.state !== 'Closed' && w.state !== 'Removed');
                title = 'Open Bugs';
                break;
            case 'blocked':
                items = filteredItems.filter(w => (w.tags || '').toLowerCase().includes('blocked'));
                title = 'Blocked Items';
                break;
            case 'unassigned':
                items = filteredItems.filter(w => !w.assignedTo && w.state !== 'Done' && w.state !== 'Closed' && w.state !== 'Removed');
                title = 'Unassigned Active Items';
                break;
            default:
                return;
        }
        
        showDrilldown(title, items, getSliceFields(items));
    }
    
    // Team Lead View
    function renderTeamLeadView() {
        const stats = document.getElementById('team-stats');
        const insights = document.getElementById('team-insights');
        const charts = document.getElementById('team-charts');
        
        const teams = ['Frontend', 'Backend', 'QA', 'DevOps', 'Analytics', 'Govern', 'SCG', 'Staff'];
        
        // Team leads mapping (based on Org Chart)
        const teamLeads = {
            'Frontend': 'Andreas Davros',
            'Backend': 'Thanos Terzis',
            'QA': 'Kostas Tzoulas',
            'DevOps': 'Christos Sidiropoulos',
            'Analytics': 'Maya Dahan',
            'Govern': 'Maya Dahan',
            'SCG': 'Alexandros Papadakis',
            'Staff': 'John Paglierani',
            'Security & Compliance': 'Chakra Bokissam',
            'Customer Success': ''
        };
        
        // Get time-filtered items, then apply dropdown filters
        const timeFilteredItems = getActiveWorkItemsForPeriod(workItems, selectedTimePeriod);
        const filteredItems = getTeamLeadChartFilteredItems(timeFilteredItems);
        
        // Calculate stats based on fully filtered items
        const teamStats = teams.map(team => {
            const teamItems = filteredItems.filter(w => w.team === team);
            
            // Completed = items in Done/Closed state
            const completed = teamItems.filter(w => w.state === 'Done' || w.state === 'Closed').length;
            const active = teamItems.filter(w => w.state !== 'Done' && w.state !== 'Closed' && w.state !== 'Removed').length;
            const total = teamItems.length;
            const pct = total > 0 ? Math.round(completed / total * 100) : 0;
            
            // Calculate effort from filtered items
            const effort = teamItems.reduce((sum, w) => sum + (w.effort || 0), 0);
            
            // Count by type from filtered items
            const byType = {};
            teamItems.forEach(w => {
                byType[w.type] = (byType[w.type] || 0) + 1;
            });
            
            return { team, total, completed, active, pct, effort, byType, lead: teamLeads[team] };
        });
        
        const periodLabel = {
            'all': 'All Time',
            'quarter': 'This Quarter',
            'lastmonth': 'Last Month',
            'month': 'This Month',
            'lastweek': 'Last Week',
            'week': 'This Week'
        }[selectedTimePeriod];
        
        // Calculate "All Teams" totals
        const allTeamsTotal = teamStats.reduce((sum, t) => sum + t.total, 0);
        const allTeamsCompleted = teamStats.reduce((sum, t) => sum + t.completed, 0);
        const allTeamsActive = teamStats.reduce((sum, t) => sum + t.active, 0);
        const allTeamsEffort = teamStats.reduce((sum, t) => sum + t.effort, 0);
        const allTeamsPct = allTeamsTotal > 0 ? Math.round(allTeamsCompleted / allTeamsTotal * 100) : 0;
        
        // Aggregate type breakdown for All Teams
        const allTeamsByType = {};
        teamStats.forEach(t => {
            Object.entries(t.byType).forEach(([type, count]) => {
                allTeamsByType[type] = (allTeamsByType[type] || 0) + count;
            });
        });
        const allTeamsTypeBreakdown = Object.entries(allTeamsByType)
            .sort((a, b) => b[1] - a[1])
            .slice(0, 3)
            .map(([type, count]) => `${count} ${type}${count > 1 ? 's' : ''}`)
            .join(', ');
        
        // Get lead photos from leadPhotos object (defined in part4)
        const allTeamsCard = `
            <div class="stat-card team-stat-card clickable all-teams-card" onclick="expandTeamDetails('All Teams')">
                <div class="stat-label">All Teams</div>
                <div class="stat-value" style="color: var(--accent-cyan)">${allTeamsTotal}</div>
                <div class="stat-subtitle">${allTeamsCompleted} done ‚Ä¢ ${allTeamsActive} active</div>
                <div class="stat-subtitle" style="font-size: 0.65rem; color: var(--text-muted);">${allTeamsTypeBreakdown}</div>
            </div>
        `;
        
        stats.innerHTML = allTeamsCard + teamStats.map(t => {
            const leadPhoto = typeof leadPhotos !== 'undefined' && leadPhotos[t.lead] ? 
                `<img src="data:image/jpeg;base64,${leadPhotos[t.lead]}" class="team-lead-photo" alt="${t.lead}">` : 
                '';
            const typeBreakdown = Object.entries(t.byType)
                .sort((a, b) => b[1] - a[1])
                .slice(0, 3)
                .map(([type, count]) => `${count} ${type}${count > 1 ? 's' : ''}`)
                .join(', ');
            
            return `
                <div class="stat-card team-stat-card clickable" onclick="expandTeamDetails('${t.team}')">
                    <div class="stat-label">${t.team}</div>
                    <div class="stat-value" style="color: ${colors.teams[t.team] || 'var(--accent-cyan)'}">${t.total}</div>
                    <div class="stat-subtitle">${t.completed} done ‚Ä¢ ${t.active} active</div>
                    <div class="stat-subtitle" style="font-size: 0.65rem; color: var(--text-muted);">${typeBreakdown}</div>
                    ${t.lead ? `
                        <div class="team-lead-info">
                            ${leadPhoto}
                            <span class="team-lead-name">${t.lead}</span>
                        </div>
                    ` : ''}
                </div>
            `;
        }).join('');
        
        // Key insights for Team Lead (use filtered items)
        const mostLoadedTeam = teamStats.sort((a, b) => b.active - a.active)[0];
        const lowestCompletion = [...teamStats].sort((a, b) => a.pct - b.pct)[0];
        
        // Find individual with most items (from filtered items)
        const activeFilteredItems = filteredItems.filter(w => w.assignedTo && w.state !== 'Done' && w.state !== 'Closed' && w.state !== 'Removed');
        const byAssignee = countBy(activeFilteredItems, 'assignedTo');
        const sortedAssignees = Object.entries(byAssignee).sort((a, b) => b[1] - a[1]);
        const topAssignees = sortedAssignees.slice(0, 3);
        
        // Items completed this week (from filtered items based on period)
        const completedInPeriod = filteredItems.filter(w => w.state === 'Done' || w.state === 'Closed').length;
        
        insights.innerHTML = `
            <div class="insights-title">‚ö° Team Insights (${periodLabel})</div>
            <div class="insights-content">
                <div class="insight-item info"><span class="insight-icon">üìà</span> ${completedInPeriod} items completed in ${periodLabel.toLowerCase()}</div>
                <div class="insight-item warning"><span class="insight-icon">‚ö†Ô∏è</span> ${mostLoadedTeam.team} has the most active work (${mostLoadedTeam.active} items)</div>
                <div class="insight-item ${lowestCompletion.pct < 50 ? 'critical' : 'warning'}">
                    <span class="insight-icon">${lowestCompletion.pct < 50 ? 'üî¥' : 'üìä'}</span> 
                    ${lowestCompletion.team} has lowest completion rate (${lowestCompletion.pct}%)
                </div>
                ${topAssignees.map((a, i) => `
                    <div class="insight-item ${a[1] > 100 ? 'critical' : a[1] > 50 ? 'warning' : 'info'}">
                        <span class="insight-icon">${a[1] > 100 ? 'üö®' : 'üë§'}</span> 
                        ${a[0]} has ${a[1]} active items ${a[1] > 100 ? '(overloaded!)' : ''}
                    </div>
                `).join('')}
            </div>
        `;
        
        charts.innerHTML = `
            <div class="chart-card">
                <div class="chart-title">Team Completion Rates (${periodLabel})</div>
                <div class="chart-container"><canvas id="team-completion-chart"></canvas></div>
            </div>
            <div class="chart-card">
                <div class="chart-title">Active Work by Team (${periodLabel})</div>
                <div class="chart-container"><canvas id="team-active-chart"></canvas></div>
            </div>
            <div class="chart-card">
                <div class="chart-title">Effort by Team (${periodLabel})</div>
                <div class="chart-container"><canvas id="team-effort-chart"></canvas></div>
            </div>
        `;
        
        // Get unique values for distribution chart filters (from all items for filter options)
        const allTypes = [...new Set(workItems.map(w => w.type))].sort();
        const allStatesForTeam = ['New', 'Triaged', 'To Do', 'In Progress', 'Ready For Review', 'Done', 'Closed', 'Removed'];
        const allAssignees = [...new Set(workItems.map(w => w.assignedTo || '(Unassigned)'))].sort();
        const allPriorities = [...new Set(workItems.map(w => String(w.priority || '(Not Set)')))].sort();
        const allIterations = [...new Set(workItems.map(w => w.iterationPath || '(Not Set)'))].sort();
        
        // Use the same filtered items for distribution charts
        const chartFilteredItems = filteredItems;
        
        // Add distribution charts section
        const iterationOptionsHtml = allIterations.slice(0, 15).map(function(i) { const label = i.includes("\\") ? i.split("\\").pop() : i; return '<label class="checkbox-option"><input type="checkbox" value="' + i + '" onchange="updateTeamLeadChartFilter(\'iteration\')"> ' + label + '</label>'; }).join("");
        const distributionChartsHtml = `
            <div class="section-divider" style="margin-top: 2rem;">
                <h3>Work Item Distribution</h3>
            </div>
            <div class="charts-grid" id="team-distribution-charts">
                <div class="chart-card">
                    <div class="chart-title">Items by Type</div>
                    <div class="chart-container"><canvas id="teamlead-type-chart"></canvas></div>
                    <div class="chart-filter">
                        <div class="multi-select-dropdown" id="teamlead-chart-type-dropdown">
                            <div class="multi-select-display" onclick="toggleTeamLeadChartFilter('type')">
                                <span id="teamlead-chart-type-display">All Types</span>
                                <span class="dropdown-arrow">‚ñº</span>
                            </div>
                            <div class="multi-select-options" id="teamlead-chart-type-options">
                                <label class="checkbox-option select-all-option"><input type="checkbox" id="teamlead-chart-type-select-all" onchange="toggleAllTeamLeadChartFilter('type', this.checked)"> <strong>Select All</strong></label>
                                <div class="checkbox-divider"></div>
                                ${allTypes.map(t => `<label class="checkbox-option"><input type="checkbox" value="${t}" onchange="updateTeamLeadChartFilter('type')"> ${t}</label>`).join('')}
                            </div>
                        </div>
                    </div>
                </div>
                <div class="chart-card">
                    <div class="chart-title">Items by State</div>
                    <div class="chart-container"><canvas id="teamlead-state-chart"></canvas></div>
                    <div class="chart-filter">
                        <div class="multi-select-dropdown" id="teamlead-chart-state-dropdown">
                            <div class="multi-select-display" onclick="toggleTeamLeadChartFilter('state')">
                                <span id="teamlead-chart-state-display">All States</span>
                                <span class="dropdown-arrow">‚ñº</span>
                            </div>
                            <div class="multi-select-options" id="teamlead-chart-state-options">
                                <label class="checkbox-option select-all-option"><input type="checkbox" id="teamlead-chart-state-select-all" onchange="toggleAllTeamLeadChartFilter('state', this.checked)"> <strong>Select All</strong></label>
                                <div class="checkbox-divider"></div>
                                ${allStatesForTeam.map(s => `<label class="checkbox-option"><input type="checkbox" value="${s}" onchange="updateTeamLeadChartFilter('state')"> ${s}</label>`).join('')}
                            </div>
                        </div>
                    </div>
                </div>
                <div class="chart-card">
                    <div class="chart-title">Items by Assignee</div>
                    <div class="chart-container"><canvas id="teamlead-assignee-chart"></canvas></div>
                    <div class="chart-filter">
                        <div class="multi-select-dropdown" id="teamlead-chart-assignee-dropdown">
                            <div class="multi-select-display" onclick="toggleTeamLeadChartFilter('assignee')">
                                <span id="teamlead-chart-assignee-display">All Assignees</span>
                                <span class="dropdown-arrow">‚ñº</span>
                            </div>
                            <div class="multi-select-options" id="teamlead-chart-assignee-options">
                                <label class="checkbox-option select-all-option"><input type="checkbox" id="teamlead-chart-assignee-select-all" onchange="toggleAllTeamLeadChartFilter('assignee', this.checked)"> <strong>Select All</strong></label>
                                <div class="checkbox-divider"></div>
                                ${allAssignees.slice(0, 20).map(a => `<label class="checkbox-option"><input type="checkbox" value="${a}" onchange="updateTeamLeadChartFilter('assignee')"> ${a}</label>`).join('')}
                            </div>
                        </div>
                    </div>
                </div>
                <div class="chart-card">
                    <div class="chart-title">Items by Priority</div>
                    <div class="chart-container"><canvas id="teamlead-priority-chart"></canvas></div>
                    <div class="chart-filter">
                        <div class="multi-select-dropdown" id="teamlead-chart-priority-dropdown">
                            <div class="multi-select-display" onclick="toggleTeamLeadChartFilter('priority')">
                                <span id="teamlead-chart-priority-display">All Priorities</span>
                                <span class="dropdown-arrow">‚ñº</span>
                            </div>
                            <div class="multi-select-options" id="teamlead-chart-priority-options">
                                <label class="checkbox-option select-all-option"><input type="checkbox" id="teamlead-chart-priority-select-all" onchange="toggleAllTeamLeadChartFilter('priority', this.checked)"> <strong>Select All</strong></label>
                                <div class="checkbox-divider"></div>
                                ${allPriorities.map(p => `<label class="checkbox-option"><input type="checkbox" value="${p}" onchange="updateTeamLeadChartFilter('priority')"> ${p}</label>`).join('')}
                            </div>
                        </div>
                    </div>
                </div>
                <div class="chart-card">
                    <div class="chart-title">Items by Iteration</div>
                    <div class="chart-container"><canvas id="teamlead-iteration-chart"></canvas></div>
                    <div class="chart-filter">
                        <div class="multi-select-dropdown" id="teamlead-chart-iteration-dropdown">
                            <div class="multi-select-display" onclick="toggleTeamLeadChartFilter('iteration')">
                                <span id="teamlead-chart-iteration-display">All Iterations</span>
                                <span class="dropdown-arrow">‚ñº</span>
                            </div>
                            <div class="multi-select-options" id="teamlead-chart-iteration-options">
                                <label class="checkbox-option select-all-option"><input type="checkbox" id="teamlead-chart-iteration-select-all" onchange="toggleAllTeamLeadChartFilter('iteration', this.checked)"> <strong>Select All</strong></label>
                                <div class="checkbox-divider"></div>
                                ${iterationOptionsHtml}
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        `;
        document.getElementById('team-distribution-section').innerHTML = distributionChartsHtml;
        
        // Restore filter states
        restoreTeamLeadChartFilterStates();
        
        setTimeout(() => {
            // Sort by completion rate for display
            const sortedByCompletion = [...teamStats].sort((a, b) => b.pct - a.pct);
            
            createChart('team-completion-chart', 'bar', {
                labels: sortedByCompletion.map(t => t.team),
                datasets: [{
                    label: 'Completion %',
                    data: sortedByCompletion.map(t => t.pct),
                    backgroundColor: sortedByCompletion.map(t => colors.teams[t.team] || colors.primary[0])
                }]
            }, {
                scales: {
                    x: { ticks: { color: '#94a3b8' }, grid: { color: '#334155' } },
                    y: { 
                        ticks: { color: '#94a3b8' }, 
                        grid: { color: '#334155' }, 
                        max: 100,
                        title: { display: true, text: 'Completion %', color: '#94a3b8' }
                    }
                }
            });
            
            const sortedByActive = [...teamStats].sort((a, b) => b.active - a.active);
            createChart('team-active-chart', 'bar', {
                labels: sortedByActive.map(t => t.team),
                datasets: [{
                    label: 'Active Items',
                    data: sortedByActive.map(t => t.active),
                    backgroundColor: sortedByActive.map(t => colors.teams[t.team] || colors.primary[0])
                }]
            }, {
                scales: {
                    x: { ticks: { color: '#94a3b8' }, grid: { color: '#334155' } },
                    y: { 
                        ticks: { color: '#94a3b8' }, 
                        grid: { color: '#334155' },
                        title: { display: true, text: 'Count', color: '#94a3b8' }
                    }
                }
            });
            
            const sortedByEffort = [...teamStats].sort((a, b) => b.effort - a.effort);
            createChart('team-effort-chart', 'bar', {
                labels: sortedByEffort.map(t => t.team),
                datasets: [{
                    label: 'Effort (days)',
                    data: sortedByEffort.map(t => t.effort.toFixed(1)),
                    backgroundColor: sortedByEffort.map(t => colors.teams[t.team] || colors.primary[0])
                }]
            }, {
                scales: {
                    x: { ticks: { color: '#94a3b8' }, grid: { color: '#334155' } },
                    y: { 
                        ticks: { color: '#94a3b8' }, 
                        grid: { color: '#334155' },
                        title: { display: true, text: 'Days', color: '#94a3b8' }
                    }
                }
            });
            
            // Distribution charts
            const byType = sortObjectByValue(countBy(chartFilteredItems, 'type'));
            createChart('teamlead-type-chart', 'doughnut', {
                labels: Object.keys(byType),
                datasets: [{ data: Object.values(byType), backgroundColor: colors.primary }]
            });
            
            const byState = sortObjectByValue(countBy(chartFilteredItems, 'state'));
            createChart('teamlead-state-chart', 'doughnut', {
                labels: Object.keys(byState),
                datasets: [{ data: Object.values(byState), backgroundColor: Object.keys(byState).map(s => colors.states[s] || colors.primary[0]) }]
            });
            
            const byAssignee = sortObjectByValue(countBy(chartFilteredItems.filter(w => w.assignedTo), 'assignedTo'));
            const topAssigneesChart = Object.fromEntries(Object.entries(byAssignee).slice(0, 10));
            createChart('teamlead-assignee-chart', 'doughnut', {
                labels: Object.keys(topAssigneesChart),
                datasets: [{ data: Object.values(topAssigneesChart), backgroundColor: colors.primary }]
            });
            
            const byPriority = sortObjectByValue(countBy(chartFilteredItems, 'priority'));
            createChart('teamlead-priority-chart', 'doughnut', {
                labels: Object.keys(byPriority).map(p => p ? `Priority ${p}` : '(Not Set)'),
                datasets: [{ data: Object.values(byPriority), backgroundColor: [colors.priority['1'], colors.priority['2'], colors.priority['3'], colors.priority['4'], '#64748b'] }]
            });
            
            const byIteration = sortObjectByValue(countBy(chartFilteredItems, 'iterationPath'));
            const topIterations = Object.fromEntries(Object.entries(byIteration).slice(0, 8));
            const iterationLabels = Object.keys(topIterations).map(i => {
                if (!i) return '(Not Set)';
                const parts = i.split('\\');
                return parts[parts.length - 1] || i;
            });
            createChart('teamlead-iteration-chart', 'doughnut', {
                labels: iterationLabels,
                datasets: [{ data: Object.values(topIterations), backgroundColor: colors.primary }]
            });
        }, 50);
    }
    
    function drilldownTeam(team) {
        const items = workItems.filter(w => w.team === team);
        showDrilldown(`Team: ${team}`, items, getSliceFields(items));
    }
    
    // Customers View filter helper
    function getFilteredCustomerItems() {
        const teamFilter = document.getElementById('customer-team-filter')?.value || 'all';
        const selectedStates = getSelectedCustomerStates();
        
        let items = workItems;
        
        if (teamFilter !== 'all') {
            items = items.filter(w => w.team === teamFilter);
        }
        
        if (selectedStates.length > 0) {
            items = items.filter(w => selectedStates.includes(w.state));
        }
        
        return items;
    }
    
    function applyCustomerFilters() {
        renderCustomersView();
    }
    
    // Customers View
    function renderCustomersView() {
        const stats = document.getElementById('customer-stats');
        const insights = document.getElementById('customer-insights');
        const charts = document.getElementById('customer-charts');
        
        const allItems = getFilteredCustomerItems();
        const teamFilter = document.getElementById('customer-team-filter')?.value || 'all';
        const selectedStates = getSelectedCustomerStates();
        const isFiltered = teamFilter !== 'all' || selectedStates.length > 0;
        const filterNote = isFiltered ? ' (filtered)' : '';
        
        const customerItems = allItems.filter(w => w.customers);
        const issues = allItems.filter(w => w.type === 'Issue');
        const customerCounts = countBy(customerItems, 'customers');
        const topCustomers = Object.entries(customerCounts).sort((a, b) => b[1] - a[1]).slice(0, 6);
        
        const triaged = issues.filter(i => i.state === 'Triaged').length;
        const issuesDone = issues.filter(i => i.state === 'Done' || i.state === 'Closed').length;
        
        stats.innerHTML = `
            <div class="stat-card clickable" onclick="drilldownCustomerStat('all')">
                <div class="stat-label">Customer-Linked Items${filterNote}</div>
                <div class="stat-value" style="color: var(--accent-cyan)">${customerItems.length}</div>
                <div class="stat-subtitle">${allItems.length > 0 ? Math.round(customerItems.length / allItems.length * 100) : 0}% of work</div>
            </div>
            <div class="stat-card clickable" onclick="drilldownCustomerStat('issues')">
                <div class="stat-label">Customer Issues</div>
                <div class="stat-value" style="color: var(--accent-orange)">${issues.length}</div>
                <div class="stat-subtitle">${triaged} triaged, ${issuesDone} resolved</div>
            </div>
            ${topCustomers.slice(0, 4).map(([customer, count]) => `
                <div class="stat-card clickable" onclick="drilldownCustomer('${customer.replace(/'/g, "\\'")}')">
                    <div class="stat-label">${customer}</div>
                    <div class="stat-value" style="color: var(--accent-purple)">${count}</div>
                    <div class="stat-subtitle">work items</div>
                </div>
            `).join('')}
        `;
        
        // Customer insights
        const issuesByCustomer = {};
        issues.forEach(i => {
            const c = i.customers || '(No Customer)';
            if (!issuesByCustomer[c]) issuesByCustomer[c] = { total: 0, open: 0 };
            issuesByCustomer[c].total++;
            if (i.state !== 'Done' && i.state !== 'Closed') issuesByCustomer[c].open++;
        });
        const topIssueCustomers = Object.entries(issuesByCustomer)
            .sort((a, b) => b[1].open - a[1].open)
            .slice(0, 3);
        
        insights.innerHTML = `
            <div class="insights-title">‚ö° Customer Insights${filterNote}</div>
            <div class="insight-item info"><span class="insight-icon">üìä</span> ${customerItems.length} work items linked to customers</div>
            <div class="insight-item warning"><span class="insight-icon">‚ö†Ô∏è</span> ${triaged} customer issues awaiting triage decisions</div>
            ${topIssueCustomers.map(([customer, data]) => `
                <div class="insight-item ${data.open > 20 ? 'critical' : 'info'}">
                    <span class="insight-icon">üè¢</span> ${customer}: ${data.open} open issues (${data.total} total)
                </div>
            `).join('')}
        `;
        
        // Get unique values for filters
        const allCategories = [...new Set(issues.map(i => i.ticketCategory || '(Not Set)'))].sort();
        const allStatesForFilter = ['New', 'Triaged', 'To Do', 'In Progress', 'Ready For Review', 'Done', 'Closed', 'Removed'];
        const allCustomersSet = new Set();
        customerItems.forEach(w => {
            if (w.customers) {
                w.customers.split(';').forEach(c => {
                    const trimmed = c.trim();
                    if (trimmed) allCustomersSet.add(trimmed);
                });
            }
        });
        const allCustomersForFilter = [...allCustomersSet].sort();
        
        // Apply chart filters
        const chartFilteredIssues = getCustomerChartFilteredItems(issues);
        const chartFilteredCustomerItems = getCustomerChartFilteredItems(customerItems);
        
        // Recalculate top customers with filters
        const filteredCustomerCounts = {};
        const selectedCustomers = customerChartFilters.customer || [];
        chartFilteredCustomerItems.forEach(w => {
            if (w.customers) {
                w.customers.split(';').forEach(c => {
                    const trimmed = c.trim();
                    if (trimmed) {
                        // Only count if no customers selected, or this customer is selected
                        if (selectedCustomers.length === 0 || selectedCustomers.includes(trimmed)) {
                            filteredCustomerCounts[trimmed] = (filteredCustomerCounts[trimmed] || 0) + 1;
                        }
                    }
                });
            }
        });
        const filteredTopCustomers = Object.entries(filteredCustomerCounts).sort((a, b) => b[1] - a[1]).slice(0, 6);
        
        charts.innerHTML = `
            <div class="chart-card">
                <div class="chart-title">Top Customers by Work Items</div>
                <div class="chart-container"><canvas id="customer-top-chart"></canvas></div>
                <div class="chart-filter">
                    <div class="multi-select-dropdown" id="customer-chart-customer-dropdown">
                        <div class="multi-select-display" onclick="toggleCustomerChartFilter('customer')">
                            <span id="customer-chart-customer-display">All Customers</span>
                            <span class="dropdown-arrow">‚ñº</span>
                        </div>
                        <div class="multi-select-options" id="customer-chart-customer-options">
                            <label class="checkbox-option select-all-option"><input type="checkbox" id="customer-chart-customer-select-all" onchange="toggleAllCustomerChartFilter('customer', this.checked)"> <strong>Select All</strong></label>
                            <div class="checkbox-divider"></div>
                            ${allCustomersForFilter.map(c => `<label class="checkbox-option"><input type="checkbox" value="${c}" onchange="updateCustomerChartFilter('customer')"> ${c}</label>`).join('')}
                        </div>
                    </div>
                </div>
            </div>
            <div class="chart-card">
                <div class="chart-title">Issues by Category</div>
                <div class="chart-container"><canvas id="customer-category-chart"></canvas></div>
                <div class="chart-filter">
                    <div class="multi-select-dropdown" id="customer-chart-category-dropdown">
                        <div class="multi-select-display" onclick="toggleCustomerChartFilter('category')">
                            <span id="customer-chart-category-display">All Categories</span>
                            <span class="dropdown-arrow">‚ñº</span>
                        </div>
                        <div class="multi-select-options" id="customer-chart-category-options">
                            <label class="checkbox-option select-all-option"><input type="checkbox" id="customer-chart-category-select-all" onchange="toggleAllCustomerChartFilter('category', this.checked)"> <strong>Select All</strong></label>
                            <div class="checkbox-divider"></div>
                            ${allCategories.map(c => `<label class="checkbox-option"><input type="checkbox" value="${c}" onchange="updateCustomerChartFilter('category')"> ${c}</label>`).join('')}
                        </div>
                    </div>
                </div>
            </div>
            <div class="chart-card">
                <div class="chart-title">Issues Pipeline</div>
                <div class="chart-container"><canvas id="customer-pipeline-chart"></canvas></div>
                <div class="chart-filter">
                    <div class="multi-select-dropdown" id="customer-chart-state-dropdown">
                        <div class="multi-select-display" onclick="toggleCustomerChartFilter('state')">
                            <span id="customer-chart-state-display">All States</span>
                            <span class="dropdown-arrow">‚ñº</span>
                        </div>
                        <div class="multi-select-options" id="customer-chart-state-options">
                            <label class="checkbox-option select-all-option"><input type="checkbox" id="customer-chart-state-select-all" onchange="toggleAllCustomerChartFilter('state', this.checked)"> <strong>Select All</strong></label>
                            <div class="checkbox-divider"></div>
                            ${allStatesForFilter.map(s => `<label class="checkbox-option"><input type="checkbox" value="${s}" onchange="updateCustomerChartFilter('state')"> ${s}</label>`).join('')}
                        </div>
                    </div>
                </div>
            </div>
        `;
        
        // Restore filter states
        restoreCustomerChartFilterStates();
        
        setTimeout(() => {
            const sortedCustomers = sortObjectByValue(Object.fromEntries(filteredTopCustomers));
            createChart('customer-top-chart', 'bar', {
                labels: Object.keys(sortedCustomers),
                datasets: [{
                    data: Object.values(sortedCustomers),
                    backgroundColor: colors.primary
                }]
            }, {
                onClick: (evt, elements) => {
                    if (elements.length > 0) {
                        drilldownCustomer(Object.keys(sortedCustomers)[elements[0].index]);
                    }
                },
                indexAxis: 'y',
                plugins: { legend: { display: false } },
                scales: {
                    x: { ticks: { color: '#94a3b8' }, grid: { color: '#334155' } },
                    y: { ticks: { color: '#94a3b8' }, grid: { display: false } }
                }
            });
            
            const byCategory = sortObjectByValue(countBy(chartFilteredIssues, 'ticketCategory'));
            createClickableChart('customer-category-chart', 'doughnut', byCategory, 'ticketCategory', null, chartFilteredIssues);
            
            const byState = sortObjectByValue(countBy(chartFilteredIssues, 'state'));
            createClickableChart('customer-pipeline-chart', 'doughnut', byState, 'state', colors.states, chartFilteredIssues);
        }, 50);
    }
    
    function drilldownCustomerStat(type) {
        const allItems = getFilteredCustomerItems();
        let items, title;
        if (type === 'all') {
            items = allItems.filter(w => w.customers);
            title = 'Customer-Linked Items';
        } else {
            items = allItems.filter(w => w.type === 'Issue');
            title = 'Customer Issues';
        }
        showDrilldown(title, items, getSliceFields(items));
    }
    
    function drilldownCustomer(customer) {
        const allItems = getFilteredCustomerItems();
        const items = allItems.filter(w => w.customers === customer);
        showDrilldown(`Customer: ${customer}`, items, getSliceFields(items));
    }

    // ==================== FEATURE ROADMAP VIEW ====================

    // Roadmap state
    let roadmapSortState = {
        column: null,  // null means use default backlog priority order
        direction: 'asc'
    };

    // Roadmap filter state
    // Roadmap filters - all filters start empty (no defaults)
    let roadmapFilters = {
        search: '',
        states: [],
        customers: [],
        assignees: [],
        teams: [],
        iterations: [],
        releases: [],
        releasesExclusionMode: false,  // Track if we started from "Select All" for release filter
        tags: [],
        tagsExclusionMode: false,  // Track if we started from "Select All" for tag filter
        tagsLogicMode: 'or'  // 'and' or 'or' - controls how multiple tag selections are combined
    };

    // Helper to extract last segment from backslash-delimited path
    function getLastPathSegment(path) {
        if (!path) return '';
        const parts = path.split('\\');
        return parts[parts.length - 1].trim();
    }

    // Get all Delivery Slices that are children of the given feature IDs
    function getDeliverySlicesForFeatures(featureIds) {
        const featureIdSet = new Set(featureIds.map(id => String(id)));
        return workItems.filter(w => {
            if (w.type !== 'Delivery Slice') return false;
            // Check if parent is one of our features
            return w.parentId && featureIdSet.has(String(w.parentId));
        });
    }

    // Calculate effort by team from delivery slices
    function calculateEffortByTeam(deliverySlices) {
        const effortByTeam = {};
        let totalEffort = 0;

        deliverySlices.forEach(ds => {
            const effort = ds.effort || 0;
            const team = getLastPathSegment(ds.areaPath) || '(No Team)';

            if (!effortByTeam[team]) {
                effortByTeam[team] = 0;
            }
            effortByTeam[team] += effort;
            totalEffort += effort;
        });

        return { effortByTeam, totalEffort };
    }

    // Team leads mapping
    const roadmapTeamLeads = {
        'Frontend': 'Andreas Davros',
        'Backend': 'Thanos Terzis',
        'QA': 'Kostas Tzoulas',
        'DevOps': 'Christos Sidiropoulos',
        'Analytics': 'Maya Dahan',
        'Govern': 'Maya Dahan',
        'SCG': 'Alexandros Papadakis',
        'Staff': 'John Paglierani',
        'Security & Compliance': 'Chakra Bokissam',
        'Customer Success': ''
    };

    // Get team member count for capacity calculation
    function getRoadmapTeamMemberCount(teamName) {
        if (typeof orgChartData === 'undefined') return 0;

        // Find the org chart entry that contains this team
        // Note: t.team may be "Analytics & Govern" for leads who manage multiple teams
        const teamData = orgChartData.find(t => {
            // Split combined team names and check if any matches
            const teams = t.team.split(' & ').map(name => name.split(' (')[0].trim());
            return teams.includes(teamName) || t.team === teamName;
        });

        if (!teamData) return 0;

        // Count only members from this specific team (plus lead if they manage just this team)
        let count = 0;

        // Check if lead manages only this team (not multiple teams)
        const leadTeams = teamData.team.split(' & ').map(name => name.split(' (')[0].trim());
        if (leadTeams.length === 1 && leadTeams[0] === teamName) {
            count = 1; // Include the lead
        }

        // Count active members from this specific team
        teamData.members.forEach(m => {
            if (m.status !== 'Former' && m.team === teamName) {
                count++;
            }
        });

        return count;
    }

    // Get initials from name
    function getInitials(name) {
        if (!name) return '?';
        const parts = name.trim().split(' ');
        if (parts.length === 1) return parts[0][0].toUpperCase();
        return (parts[0][0] + parts[parts.length - 1][0]).toUpperCase();
    }

    // Count features and delivery slices by team
    function countItemsByTeam(features, slices, team) {
        // Count features that have at least one slice from this team
        const featureIdsWithTeam = new Set();
        slices.forEach(ds => {
            const dsTeam = getLastPathSegment(ds.areaPath) || '(No Team)';
            if (dsTeam === team && ds.parentId) {
                featureIdsWithTeam.add(String(ds.parentId));
            }
        });
        const featureCount = features.filter(f => featureIdsWithTeam.has(String(f.id))).length;

        // Count slices from this team
        const sliceCount = slices.filter(ds => {
            const dsTeam = getLastPathSegment(ds.areaPath) || '(No Team)';
            return dsTeam === team;
        }).length;

        return { featureCount, sliceCount };
    }

    function getRoadmapFeatures() {
        // Return all Features - release version filtering is now handled by the Release filter dropdown
        // Tag filtering (including Candidate) is handled by the Tag filter dropdown
        return workItems.filter(w => w.type === 'Feature');
    }

    function getFilteredRoadmapFeatures() {
        let features = getRoadmapFeatures();

        // Apply search filter (searches both Title and ID)
        if (roadmapFilters.search) {
            const searchLower = roadmapFilters.search.toLowerCase();
            features = features.filter(f =>
                (f.title || '').toLowerCase().includes(searchLower) ||
                String(f.id).includes(roadmapFilters.search)
            );
        }

        // Apply state filter
        if (roadmapFilters.states.length > 0) {
            features = features.filter(f => roadmapFilters.states.includes(f.state));
        }

        // Apply customer filter
        if (roadmapFilters.customers.length > 0) {
            features = features.filter(f => {
                if (!f.customers) return roadmapFilters.customers.includes('(No Customer)');
                return roadmapFilters.customers.some(c => f.customers.includes(c));
            });
        }

        // Apply assignee filter
        if (roadmapFilters.assignees.length > 0) {
            features = features.filter(f => {
                const assignee = f.assignedTo || '(Unassigned)';
                return roadmapFilters.assignees.includes(assignee);
            });
        }

        // Apply team and iteration filters together (based on delivery slices)
        // When both are active, a feature must have at least one slice that matches BOTH filters
        if (roadmapFilters.teams.length > 0 || roadmapFilters.iterations.length > 0) {
            features = features.filter(f => {
                const slices = getDeliverySlicesForFeatures([f.id]);
                return slices.some(ds => {
                    const team = getLastPathSegment(ds.areaPath) || '(No Team)';
                    const iteration = getLastPathSegment(ds.iterationPath) || '(No Iteration)';

                    // Check team filter (if active)
                    const teamMatch = roadmapFilters.teams.length === 0 || roadmapFilters.teams.includes(team);
                    // Check iteration filter (if active)
                    const iterationMatch = roadmapFilters.iterations.length === 0 || roadmapFilters.iterations.includes(iteration);

                    // Slice must match both filters (when active)
                    return teamMatch && iterationMatch;
                });
            });
        }

        // Apply release version filter
        if (roadmapFilters.releases.length > 0) {
            if (roadmapFilters.releasesExclusionMode) {
                // Exclusion mode: Started from "Select All", now excluding unchecked releases
                // Get all available releases to determine what's unchecked
                const allAvailableReleases = new Set(['(No Release)']);
                getRoadmapFeatures().forEach(f => {
                    if (f.releaseVersion && f.releaseVersion.trim()) {
                        allAvailableReleases.add(f.releaseVersion.trim());
                    }
                });
                const uncheckedReleases = [...allAvailableReleases].filter(r => !roadmapFilters.releases.includes(r));

                features = features.filter(f => {
                    const featureRelease = (f.releaseVersion && f.releaseVersion.trim()) || '(No Release)';
                    // Exclude features that have any unchecked release
                    return !uncheckedReleases.includes(featureRelease);
                });
            } else {
                // Inclusion mode: Show features that have any of the selected releases
                features = features.filter(f => {
                    const featureRelease = (f.releaseVersion && f.releaseVersion.trim()) || '(No Release)';
                    return roadmapFilters.releases.includes(featureRelease);
                });
            }
        }

        // Apply tag filter
        if (roadmapFilters.tags.length > 0) {
            if (roadmapFilters.tagsExclusionMode) {
                // Exclusion mode: Started from "Select All", now excluding unchecked tags
                // Get all available tags to determine what's unchecked
                const allAvailableTags = new Set();
                getRoadmapFeatures().forEach(f => {
                    if (f.tags) {
                        f.tags.split(';').forEach(t => {
                            const trimmed = t.trim();
                            if (trimmed) allAvailableTags.add(trimmed);
                        });
                    }
                });
                const uncheckedTags = [...allAvailableTags].filter(t => !roadmapFilters.tags.includes(t));

                features = features.filter(f => {
                    const featureTags = (f.tags || '').split(';').map(t => t.trim()).filter(t => t);
                    // Exclude features that have any unchecked tag
                    return !featureTags.some(tag => uncheckedTags.includes(tag));
                });
            } else {
                // Inclusion mode: logic depends on tagsLogicMode setting
                features = features.filter(f => {
                    const featureTags = (f.tags || '').split(';').map(t => t.trim()).filter(t => t);
                    if (roadmapFilters.tagsLogicMode === 'and') {
                        // AND logic: feature must have ALL selected tags
                        return roadmapFilters.tags.every(selectedTag => featureTags.includes(selectedTag));
                    } else {
                        // OR logic (default): feature must have ANY selected tag
                        return roadmapFilters.tags.some(selectedTag => featureTags.includes(selectedTag));
                    }
                });
            }
        }

        return features;
    }

    // Get delivery slices filtered by current team/iteration filters
    function getFilteredDeliverySlices(featureIds) {
        let slices = getDeliverySlicesForFeatures(featureIds);

        // Apply team filter
        if (roadmapFilters.teams.length > 0) {
            slices = slices.filter(ds => {
                const team = getLastPathSegment(ds.areaPath) || '(No Team)';
                return roadmapFilters.teams.includes(team);
            });
        }

        // Apply iteration filter
        if (roadmapFilters.iterations.length > 0) {
            slices = slices.filter(ds => {
                const iteration = getLastPathSegment(ds.iterationPath) || '(No Iteration)';
                return roadmapFilters.iterations.includes(iteration);
            });
        }

        return slices;
    }

    function renderRoadmapView() {
        // Populate filter dropdowns on first render
        populateRoadmapFilterDropdowns();

        // If state was loaded from localStorage, sync dropdown checkboxes with loaded state
        if (stateWasLoaded) {
            syncRoadmapFilterDropdowns();
            stateWasLoaded = false; // Only sync once after state load
        }

        const features = getFilteredRoadmapFeatures();
        const allFeatures = getRoadmapFeatures();
        const countEl = document.getElementById('roadmap-count');
        const thead = document.getElementById('roadmap-table-head');
        const tbody = document.getElementById('roadmap-table-body');
        const effortCardsEl = document.getElementById('roadmap-effort-cards');

        // Update count (show filtered vs total if filtering)
        const isFiltered = roadmapFilters.search || roadmapFilters.states.length > 0 ||
                          roadmapFilters.customers.length > 0 || roadmapFilters.assignees.length > 0 ||
                          roadmapFilters.teams.length > 0 || roadmapFilters.iterations.length > 0 ||
                          roadmapFilters.releases.length > 0 || roadmapFilters.tags.length > 0;
        if (isFiltered) {
            countEl.textContent = `${features.length} of ${allFeatures.length} features`;
        } else {
            countEl.textContent = `${features.length} feature${features.length !== 1 ? 's' : ''}`;
        }

        // Update clear button visibility
        const clearBtn = document.getElementById('roadmap-clear-filters-btn');
        if (clearBtn) {
            clearBtn.classList.toggle('hidden', !isFiltered);
        }

        // Calculate and render effort cards
        const featureIds = features.map(f => f.id);
        const filteredSlices = getFilteredDeliverySlices(featureIds);
        const { effortByTeam, totalEffort } = calculateEffortByTeam(filteredSlices);

        // Sort teams by effort (descending)
        const sortedTeams = Object.entries(effortByTeam)
            .sort((a, b) => b[1] - a[1]);

        // Calculate totals for the "All Teams" card
        const totalFeatures = features.length;
        const totalSlices = filteredSlices.length;
        const totalMembers = sortedTeams.reduce((sum, [team]) => sum + getRoadmapTeamMemberCount(team), 0);
        const totalCapacity = totalMembers * 22;

        // Build team cards HTML
        const teamCardsHtml = sortedTeams.map(([team, effort]) => {
            const lead = roadmapTeamLeads[team] || '';
            const memberCount = getRoadmapTeamMemberCount(team);
            const capacity = memberCount * 22;
            const { featureCount, sliceCount } = countItemsByTeam(features, filteredSlices, team);

            // Try to get lead photo if available
            const hasPhoto = typeof leadPhotos !== 'undefined' && leadPhotos[lead];
            const photoHtml = hasPhoto
                ? `<img src="data:image/jpeg;base64,${leadPhotos[lead]}" class="effort-card-lead-photo" alt="${lead}">`
                : `<div class="effort-card-lead-avatar">${getInitials(lead)}</div>`;

            // Get team color for this card
            const teamColor = typeof getTeamColor === 'function' ? getTeamColor(team) : '#94a3b8';

            // Check if this team is selected
            const isSelected = roadmapFilters.teams.length === 1 && roadmapFilters.teams[0] === team;
            const selectedClass = isSelected ? ' selected' : '';

            return `
                <div class="effort-card${selectedClass}" onclick="toggleRoadmapTeamCard('${team.replace(/'/g, "\\'")}')">
                    <div class="effort-card-header">
                        <div class="effort-card-label">${team}</div>
                    </div>
                    <div class="effort-card-value" style="color: ${teamColor}">${effort.toFixed(1)}<span class="effort-card-unit">d</span></div>
                    <div class="effort-card-capacity">of ${capacity}d monthly capacity</div>
                    <div class="effort-card-stats">
                        <span>${featureCount} Feature${featureCount !== 1 ? 's' : ''}</span>
                        <span>${sliceCount} Delivery Slice${sliceCount !== 1 ? 's' : ''}</span>
                    </div>
                    ${lead ? `
                    <div class="effort-card-footer">
                        ${photoHtml}
                        <span class="effort-card-lead-name">${lead}</span>
                    </div>
                    ` : ''}
                </div>
            `;
        }).join('');

        // Render effort cards
        effortCardsEl.innerHTML = `
            <div class="effort-card total" onclick="clearRoadmapTeamFilter()" title="Click to show all teams">
                <div class="effort-card-header">
                    <div class="effort-card-label">Total Effort</div>
                </div>
                <div class="effort-card-value">${totalEffort.toFixed(1)}<span class="effort-card-unit">days</span></div>
                <div class="effort-card-capacity">of ${totalCapacity}d monthly capacity</div>
                <div class="effort-card-stats">
                    <span>${totalFeatures} Feature${totalFeatures !== 1 ? 's' : ''}</span>
                    <span>${totalSlices} Delivery Slice${totalSlices !== 1 ? 's' : ''}</span>
                </div>
            </div>
            ${teamCardsHtml}
        `;

        // Define columns (ID, Title, State, Customers, Tags, Assigned To, Release, Effort)
        const columns = [
            { key: 'id', label: 'ID' },
            { key: 'title', label: 'Title' },
            { key: 'state', label: 'State' },
            { key: 'customers', label: 'Customers' },
            { key: 'tags', label: 'Tags' },
            { key: 'assignedTo', label: 'Assigned To' },
            { key: 'releaseVersion', label: 'Release' },
            { key: 'effort', label: 'Effort' }
        ];

        // Pre-calculate effort for each feature (sum of child delivery slices)
        // When team/iteration filters are active, only sum effort from matching slices
        const featureEffortMap = {};
        features.forEach(f => {
            const featureSlices = getDeliverySlicesForFeatures([f.id]);
            let relevantSlices = featureSlices;

            // If team filter is active, only count effort from that team
            if (roadmapFilters.teams.length > 0) {
                relevantSlices = relevantSlices.filter(ds => {
                    const dsTeam = getLastPathSegment(ds.areaPath) || '(No Team)';
                    return roadmapFilters.teams.includes(dsTeam);
                });
            }

            // If iteration filter is active, only count effort from that iteration
            if (roadmapFilters.iterations.length > 0) {
                relevantSlices = relevantSlices.filter(ds => {
                    const dsIteration = getLastPathSegment(ds.iterationPath) || '(No Iteration)';
                    return roadmapFilters.iterations.includes(dsIteration);
                });
            }

            featureEffortMap[f.id] = relevantSlices.reduce((sum, ds) => sum + (ds.effort || 0), 0);
        });

        // Calculate total effort (for the total row)
        const totalTableEffort = Object.values(featureEffortMap).reduce((sum, e) => sum + e, 0);

        // Sort features
        let sortedFeatures = [...features];
        if (roadmapSortState.column) {
            // User-selected sort
            sortedFeatures = sortRoadmapItems(sortedFeatures, roadmapSortState.column, roadmapSortState.direction, featureEffortMap);
        } else {
            // Default: sort by backlog priority (lower value = higher priority)
            sortedFeatures.sort((a, b) => {
                const aPri = a.backlogPriority || Number.MAX_VALUE;
                const bPri = b.backlogPriority || Number.MAX_VALUE;
                return aPri - bPri;
            });
        }

        // Build header
        const showResetBtn = roadmapSortState.column !== null;
        thead.innerHTML = `<tr>
            ${columns.map(c => `
                <th class="sortable-header resizable-header ${getRoadmapColumnClass(c.key)}" onclick="sortRoadmapTable('${c.key}')">
                    ${c.label}
                    <span class="sort-indicator">${getRoadmapSortIndicator(c.key)}</span>
                    <div class="resize-handle" onmousedown="startResize(event, this)"></div>
                </th>
            `).join('')}
            ${showResetBtn ? `<th style="width: 140px;"><button class="reset-sort-btn" onclick="resetRoadmapSort()">Reset to Backlog Priority</button></th>` : ''}
        </tr>`;

        // Build body - rows are clickable to show delivery slices
        tbody.innerHTML = sortedFeatures.map(item => {
            const slices = getDeliverySlicesForFeatures([item.id]);

            // Build badges
            let badges = '';

            // Badge 0: Blocked tag (highest priority warning)
            const tags = (item.tags || '').split(';').map(t => t.trim().toLowerCase());
            if (tags.includes('blocked')) {
                badges += `<span class="blocked-badge" title="This feature is tagged as Blocked">Blocked</span>`;
            }

            // Badge 1: No Delivery Slices
            if (slices.length === 0) {
                badges += `<span class="no-slices-badge" title="This feature has no Delivery Slices">No slices</span>`;
            } else {
                // Badge 2: Zero effort (only if there are slices)
                const hasZeroEffort = slices.some(ds => !ds.effort || ds.effort === 0);
                if (hasZeroEffort) {
                    const zeroEffortSlices = slices.filter(ds => !ds.effort || ds.effort === 0);
                    badges += `<span class="zero-effort-badge" title="${zeroEffortSlices.length} slice(s) with zero effort">0 effort</span>`;
                }

                // Badge 3: Multiple iterations
                const iterationSet = new Set(slices.map(ds => getLastPathSegment(ds.iterationPath) || '(No Iteration)'));
                const iterationCount = iterationSet.size;
                if (iterationCount > 1) {
                    badges += `<span class="iteration-count-badge" title="${[...iterationSet].join(', ')}">${iterationCount} iterations</span>`;
                }
            }

            const featureEffort = featureEffortMap[item.id] || 0;
            // Format tags for display (remove duplicates, sort, join with comma)
            const displayTags = (item.tags || '').split(';').map(t => t.trim()).filter(t => t).join(', ');
            return `
            <tr class="clickable-row" data-feature-id="${item.id}" data-feature-title="${(item.title || '').replace(/"/g, '&quot;')}">
                <td><a href="${item.url}" target="_blank" class="work-item-id">${item.id}</a></td>
                <td class="work-item-title" title="${(item.title || '').replace(/"/g, '&quot;')}">${item.title || ''} ${badges}</td>
                <td><span class="state-badge ${getStateClass(item.state)}">${item.state || ''}</span></td>
                <td>${item.customers || ''}</td>
                <td class="tags-cell" title="${displayTags}">${displayTags}</td>
                <td>${item.assignedTo || ''}</td>
                <td>${item.releaseVersion || ''}</td>
                <td class="effort-value">${featureEffort > 0 ? featureEffort.toFixed(1) + 'd' : ''}</td>
                ${showResetBtn ? '<td></td>' : ''}
            </tr>
        `;
        }).join('');

        // Add total row (colspan = 7 for columns before Effort: ID, Title, State, Customers, Tags, Assigned To, Release)
        tbody.innerHTML += `
            <tr class="total-row">
                <td colspan="7" style="text-align: right; font-weight: 600; color: var(--text-secondary);">Total Effort:</td>
                <td class="effort-value" style="font-weight: 700; color: var(--accent-cyan);">${totalTableEffort.toFixed(1)}d</td>
                ${showResetBtn ? '<td></td>' : ''}
            </tr>
        `;

        // Update inline effort summary above table
        const effortSummaryEl = document.getElementById('roadmap-table-effort-summary');
        if (effortSummaryEl) {
            const teamLabel = roadmapFilters.teams.length === 1 ? roadmapFilters.teams[0] : 'All Teams';
            const iterationLabel = roadmapFilters.iterations.length === 1 ? roadmapFilters.iterations[0] : '';
            const filterLabel = iterationLabel ? `${teamLabel} ¬∑ ${iterationLabel}` : teamLabel;
            effortSummaryEl.innerHTML = `Table Total: <strong>${totalTableEffort.toFixed(1)}d</strong> (${filterLabel})`;
        }

        // Ensure click handler is attached
        setupRoadmapTableClickHandler();
    }

    // Set up click delegation on the roadmap table body (once)
    function setupRoadmapTableClickHandler() {
        const tbody = document.getElementById('roadmap-table-body');
        if (!tbody || tbody.dataset.clickHandlerAttached) return;

        tbody.addEventListener('click', function(e) {
            // Don't trigger if clicking on a link
            if (e.target.tagName === 'A' || e.target.closest('a')) return;

            // Find the clicked row
            const row = e.target.closest('.clickable-row');
            if (!row) return;

            const featureId = parseInt(row.dataset.featureId);
            const featureTitle = row.dataset.featureTitle;
            if (featureId) {
                drilldownFeatureSlices(featureId, featureTitle);
            }
        });

        tbody.dataset.clickHandlerAttached = 'true';
    }

    // Initialize click handler when DOM is ready
    if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', setupRoadmapTableClickHandler);
    } else {
        setupRoadmapTableClickHandler();
    }

    function populateRoadmapFilterDropdowns() {
        const features = getRoadmapFeatures();
        const allSlices = getDeliverySlicesForFeatures(features.map(f => f.id));

        // Get unique values from features
        const states = [...new Set(features.map(f => f.state).filter(Boolean))].sort();
        const customersSet = new Set();
        features.forEach(f => {
            if (f.customers) {
                f.customers.split(';').forEach(c => {
                    const trimmed = c.trim();
                    if (trimmed) customersSet.add(trimmed);
                });
            } else {
                customersSet.add('(No Customer)');
            }
        });
        const customers = [...customersSet].sort();
        const assignees = [...new Set(features.map(f => f.assignedTo || '(Unassigned)'))].sort();

        // Get unique teams and iterations from delivery slices
        const teamsSet = new Set();
        const iterationsSet = new Set();
        allSlices.forEach(ds => {
            const team = getLastPathSegment(ds.areaPath);
            const iteration = getLastPathSegment(ds.iterationPath);
            if (team) teamsSet.add(team);
            else teamsSet.add('(No Team)');
            if (iteration) iterationsSet.add(iteration);
            else iterationsSet.add('(No Iteration)');
        });
        const teams = [...teamsSet].sort();
        const iterations = [...iterationsSet].sort();

        // Get unique release versions from features
        const releasesSet = new Set(['(No Release)']);  // Always include the "no release" option
        features.forEach(f => {
            if (f.releaseVersion && f.releaseVersion.trim()) {
                releasesSet.add(f.releaseVersion.trim());
            }
        });
        const releases = [...releasesSet].sort((a, b) => {
            // Put "(No Release)" first, then sort the rest alphabetically
            if (a === '(No Release)') return -1;
            if (b === '(No Release)') return 1;
            return a.localeCompare(b);
        });

        // Get unique tags from features
        const tagsSet = new Set();
        features.forEach(f => {
            if (f.tags) {
                f.tags.split(';').forEach(t => {
                    const trimmed = t.trim();
                    if (trimmed) tagsSet.add(trimmed);
                });
            }
        });
        const tags = [...tagsSet].sort();

        // Populate State dropdown
        const stateMenu = document.getElementById('roadmap-state-menu');
        if (stateMenu && !stateMenu.dataset.populated) {
            stateMenu.innerHTML = `
                <div class="filter-dropdown-search">
                    <input type="text" placeholder="Search states..." oninput="filterRoadmapDropdownOptions('state', this.value)">
                </div>
                <div class="filter-dropdown-options" id="roadmap-state-options">
                    ${states.map(s => `
                        <label class="filter-dropdown-option" onclick="event.stopPropagation();">
                            <input type="checkbox" ${roadmapFilters.states.includes(s) ? 'checked' : ''} onchange="handleRoadmapFilterChange('state', '${s}', this.checked)">
                            <span class="option-label">${s}</span>
                        </label>
                    `).join('')}
                </div>
                <div class="filter-dropdown-actions">
                    <button class="filter-btn-primary" onclick="selectAllRoadmapFilter('state')">Select All</button>
                    <button class="filter-btn-secondary" onclick="clearRoadmapFilter('state')">Clear</button>
                </div>
            `;
            stateMenu.dataset.populated = 'true';
        }

        // Populate Customer dropdown
        const customerMenu = document.getElementById('roadmap-customer-menu');
        if (customerMenu && !customerMenu.dataset.populated) {
            customerMenu.innerHTML = `
                <div class="filter-dropdown-search">
                    <input type="text" placeholder="Search customers..." oninput="filterRoadmapDropdownOptions('customer', this.value)">
                </div>
                <div class="filter-dropdown-options" id="roadmap-customer-options">
                    ${customers.map(c => `
                        <label class="filter-dropdown-option" onclick="event.stopPropagation();">
                            <input type="checkbox" ${roadmapFilters.customers.includes(c) ? 'checked' : ''} onchange="handleRoadmapFilterChange('customer', '${c.replace(/'/g, "\\'")}', this.checked)">
                            <span class="option-label">${c}</span>
                        </label>
                    `).join('')}
                </div>
                <div class="filter-dropdown-actions">
                    <button class="filter-btn-primary" onclick="selectAllRoadmapFilter('customer')">Select All</button>
                    <button class="filter-btn-secondary" onclick="clearRoadmapFilter('customer')">Clear</button>
                </div>
            `;
            customerMenu.dataset.populated = 'true';
        }

        // Populate Assignee dropdown
        const assigneeMenu = document.getElementById('roadmap-assignee-menu');
        if (assigneeMenu && !assigneeMenu.dataset.populated) {
            assigneeMenu.innerHTML = `
                <div class="filter-dropdown-search">
                    <input type="text" placeholder="Search assignees..." oninput="filterRoadmapDropdownOptions('assignee', this.value)">
                </div>
                <div class="filter-dropdown-options" id="roadmap-assignee-options">
                    ${assignees.map(a => `
                        <label class="filter-dropdown-option" onclick="event.stopPropagation();">
                            <input type="checkbox" ${roadmapFilters.assignees.includes(a) ? 'checked' : ''} onchange="handleRoadmapFilterChange('assignee', '${a.replace(/'/g, "\\'")}', this.checked)">
                            <span class="option-label">${a}</span>
                        </label>
                    `).join('')}
                </div>
                <div class="filter-dropdown-actions">
                    <button class="filter-btn-primary" onclick="selectAllRoadmapFilter('assignee')">Select All</button>
                    <button class="filter-btn-secondary" onclick="clearRoadmapFilter('assignee')">Clear</button>
                </div>
            `;
            assigneeMenu.dataset.populated = 'true';
        }

        // Populate Team dropdown
        const teamMenu = document.getElementById('roadmap-team-menu');
        if (teamMenu && !teamMenu.dataset.populated) {
            teamMenu.innerHTML = `
                <div class="filter-dropdown-search">
                    <input type="text" placeholder="Search teams..." oninput="filterRoadmapDropdownOptions('team', this.value)">
                </div>
                <div class="filter-dropdown-options" id="roadmap-team-options">
                    ${teams.map(t => `
                        <label class="filter-dropdown-option" onclick="event.stopPropagation();">
                            <input type="checkbox" ${roadmapFilters.teams.includes(t) ? 'checked' : ''} onchange="handleRoadmapFilterChange('team', '${t.replace(/'/g, "\\'")}', this.checked)">
                            <span class="option-label">${t}</span>
                        </label>
                    `).join('')}
                </div>
                <div class="filter-dropdown-actions">
                    <button class="filter-btn-primary" onclick="selectAllRoadmapFilter('team')">Select All</button>
                    <button class="filter-btn-secondary" onclick="clearRoadmapFilter('team')">Clear</button>
                </div>
            `;
            teamMenu.dataset.populated = 'true';
        }

        // Populate Iteration dropdown
        const iterationMenu = document.getElementById('roadmap-iteration-menu');
        if (iterationMenu && !iterationMenu.dataset.populated) {
            iterationMenu.innerHTML = `
                <div class="filter-dropdown-search">
                    <input type="text" placeholder="Search iterations..." oninput="filterRoadmapDropdownOptions('iteration', this.value)">
                </div>
                <div class="filter-dropdown-options" id="roadmap-iteration-options">
                    ${iterations.map(i => `
                        <label class="filter-dropdown-option" onclick="event.stopPropagation();">
                            <input type="checkbox" ${roadmapFilters.iterations.includes(i) ? 'checked' : ''} onchange="handleRoadmapFilterChange('iteration', '${i.replace(/'/g, "\\'")}', this.checked)">
                            <span class="option-label">${i}</span>
                        </label>
                    `).join('')}
                </div>
                <div class="filter-dropdown-actions">
                    <button class="filter-btn-primary" onclick="selectAllRoadmapFilter('iteration')">Select All</button>
                    <button class="filter-btn-secondary" onclick="clearRoadmapFilter('iteration')">Clear</button>
                </div>
            `;
            iterationMenu.dataset.populated = 'true';
        }

        // Populate Release dropdown
        const releaseMenu = document.getElementById('roadmap-release-menu');
        if (releaseMenu && !releaseMenu.dataset.populated) {
            releaseMenu.innerHTML = `
                <div class="filter-dropdown-search">
                    <input type="text" placeholder="Search releases..." oninput="filterRoadmapDropdownOptions('release', this.value)">
                </div>
                <div class="filter-dropdown-options" id="roadmap-release-options">
                    ${releases.map(r => `
                        <label class="filter-dropdown-option" onclick="event.stopPropagation();">
                            <input type="checkbox" ${roadmapFilters.releases.includes(r) ? 'checked' : ''} onchange="handleRoadmapFilterChange('release', '${r.replace(/'/g, "\\'")}', this.checked)">
                            <span class="option-label">${r}</span>
                        </label>
                    `).join('')}
                </div>
                <div class="filter-dropdown-actions">
                    <button class="filter-btn-primary" onclick="selectAllRoadmapFilter('release')">Select All</button>
                    <button class="filter-btn-secondary" onclick="clearRoadmapFilter('release')">Clear</button>
                </div>
            `;
            releaseMenu.dataset.populated = 'true';
        }

        // Populate Tag dropdown
        const tagMenu = document.getElementById('roadmap-tag-menu');
        if (tagMenu && !tagMenu.dataset.populated) {
            tagMenu.innerHTML = `
                <div class="filter-dropdown-search">
                    <input type="text" placeholder="Search tags..." oninput="filterRoadmapDropdownOptions('tag', this.value)">
                </div>
                <div class="tag-logic-toggle" onclick="event.stopPropagation();">
                    <span class="tag-logic-label">Match:</span>
                    <button class="tag-logic-btn ${roadmapFilters.tagsLogicMode === 'or' ? 'active' : ''}" onclick="setTagLogicMode('or')">Any (OR)</button>
                    <button class="tag-logic-btn ${roadmapFilters.tagsLogicMode === 'and' ? 'active' : ''}" onclick="setTagLogicMode('and')">All (AND)</button>
                </div>
                <div class="filter-dropdown-options" id="roadmap-tag-options">
                    ${tags.map(t => `
                        <label class="filter-dropdown-option" onclick="event.stopPropagation();">
                            <input type="checkbox" ${roadmapFilters.tags.includes(t) ? 'checked' : ''} onchange="handleRoadmapFilterChange('tag', '${t.replace(/'/g, "\\'")}', this.checked)">
                            <span class="option-label">${t}</span>
                        </label>
                    `).join('')}
                </div>
                <div class="filter-dropdown-actions">
                    <button class="filter-btn-primary" onclick="selectAllRoadmapFilter('tag')">Select All</button>
                    <button class="filter-btn-secondary" onclick="clearRoadmapFilter('tag')">Clear</button>
                </div>
            `;
            tagMenu.dataset.populated = 'true';
        }
    }

    // Toggle between AND/OR logic for tag filter
    function setTagLogicMode(mode) {
        roadmapFilters.tagsLogicMode = mode;
        // Update button states
        document.querySelectorAll('.tag-logic-btn').forEach(btn => {
            btn.classList.toggle('active', btn.textContent.toLowerCase().includes(mode));
        });
        renderRoadmapView();
        saveStateToStorage(); // Persist logic mode change
    }

    // Sync all roadmap filter dropdown checkboxes with current filter state
    // Called after state is loaded from localStorage to update UI
    function syncRoadmapFilterDropdowns() {
        const filterTypes = ['state', 'customer', 'assignee', 'team', 'iteration', 'release', 'tag'];
        const filterKeyMap = {
            'state': 'states',
            'customer': 'customers',
            'assignee': 'assignees',
            'team': 'teams',
            'iteration': 'iterations',
            'release': 'releases',
            'tag': 'tags'
        };

        filterTypes.forEach(type => {
            const optionsContainer = document.getElementById(`roadmap-${type}-options`);
            if (!optionsContainer) return;

            const filterKey = filterKeyMap[type];
            const selectedValues = roadmapFilters[filterKey] || [];

            optionsContainer.querySelectorAll('.filter-dropdown-option').forEach(opt => {
                const cb = opt.querySelector('input[type="checkbox"]');
                const label = opt.querySelector('.option-label')?.textContent;
                if (cb && label) {
                    cb.checked = selectedValues.includes(label);
                }
            });

            updateRoadmapFilterDisplay(type);
        });

        // Sync tag logic mode buttons
        document.querySelectorAll('.tag-logic-btn').forEach(btn => {
            const isOrBtn = btn.textContent.includes('OR');
            const isAndBtn = btn.textContent.includes('AND');
            btn.classList.toggle('active',
                (isOrBtn && roadmapFilters.tagsLogicMode === 'or') ||
                (isAndBtn && roadmapFilters.tagsLogicMode === 'and')
            );
        });

        // Sync search input
        const searchInput = document.getElementById('roadmap-search-input');
        if (searchInput && roadmapFilters.search) {
            searchInput.value = roadmapFilters.search;
        }
    }

    function filterRoadmapDropdownOptions(filterType, searchText) {
        const optionsContainer = document.getElementById(`roadmap-${filterType}-options`);
        if (!optionsContainer) return;

        const options = optionsContainer.querySelectorAll('.filter-dropdown-option');
        const searchLower = searchText.toLowerCase();

        options.forEach(opt => {
            const label = opt.querySelector('.option-label')?.textContent || '';
            opt.style.display = label.toLowerCase().includes(searchLower) ? '' : 'none';
        });
    }

    // New handler for label-based filter options (onchange on checkbox)
    function handleRoadmapFilterChange(filterType, value, checked) {
        const filterKey = getFilterKey(filterType);

        if (checked) {
            if (!roadmapFilters[filterKey].includes(value)) {
                roadmapFilters[filterKey].push(value);
            }
        } else {
            roadmapFilters[filterKey] = roadmapFilters[filterKey].filter(v => v !== value);
            // Reset exclusion mode if all tags/releases are unchecked
            if (filterType === 'tag' && roadmapFilters.tags.length === 0) {
                roadmapFilters.tagsExclusionMode = false;
            }
            if (filterType === 'release' && roadmapFilters.releases.length === 0) {
                roadmapFilters.releasesExclusionMode = false;
            }
        }

        updateRoadmapFilterDisplay(filterType);
        renderRoadmapView();
        saveStateToStorage(); // Persist filter changes
    }

    // Legacy handler - kept for compatibility but now using handleRoadmapFilterChange
    function toggleRoadmapFilter(filterType, value, element) {
        const checkbox = element.querySelector('input[type="checkbox"]');
        checkbox.checked = !checkbox.checked;
        handleRoadmapFilterChange(filterType, value, checkbox.checked);
    }

    function getFilterKey(filterType) {
        const keyMap = {
            'state': 'states',
            'customer': 'customers',
            'assignee': 'assignees',
            'team': 'teams',
            'iteration': 'iterations',
            'release': 'releases',
            'tag': 'tags'
        };
        return keyMap[filterType] || filterType;
    }

    function getFilterLabel(filterType) {
        const labelMap = {
            'state': 'All States',
            'customer': 'All Customers',
            'assignee': 'All Assignees',
            'team': 'All Teams',
            'iteration': 'All Iterations',
            'release': 'All Releases',
            'tag': 'All Tags'
        };
        return labelMap[filterType] || 'All';
    }

    function updateRoadmapFilterDisplay(filterType) {
        const filterKey = getFilterKey(filterType);
        const displayEl = document.getElementById(`roadmap-${filterType}-display`);
        const selected = roadmapFilters[filterKey];

        if (selected.length === 0) {
            displayEl.textContent = getFilterLabel(filterType);
        } else if (selected.length === 1) {
            displayEl.textContent = selected[0];
        } else {
            displayEl.textContent = `${selected.length} selected`;
        }
    }

    function clearRoadmapFilter(filterType) {
        const filterKey = getFilterKey(filterType);
        roadmapFilters[filterKey] = [];

        // Reset exclusion mode when clearing tag/release filter
        if (filterType === 'tag') {
            roadmapFilters.tagsExclusionMode = false;
        }
        if (filterType === 'release') {
            roadmapFilters.releasesExclusionMode = false;
        }

        // Uncheck all checkboxes
        const optionsContainer = document.getElementById(`roadmap-${filterType}-options`);
        if (optionsContainer) {
            optionsContainer.querySelectorAll('input[type="checkbox"]').forEach(cb => cb.checked = false);
        }

        updateRoadmapFilterDisplay(filterType);
        renderRoadmapView();
        saveStateToStorage(); // Persist filter changes
    }

    function selectAllRoadmapFilter(filterType) {
        const filterKey = getFilterKey(filterType);
        const optionsContainer = document.getElementById(`roadmap-${filterType}-options`);
        if (!optionsContainer) return;

        // Check all visible checkboxes and collect their values
        const values = [];
        optionsContainer.querySelectorAll('.filter-dropdown-option').forEach(opt => {
            if (opt.style.display !== 'none') {
                const cb = opt.querySelector('input[type="checkbox"]');
                const label = opt.querySelector('.option-label')?.textContent;
                if (cb && label) {
                    cb.checked = true;
                    values.push(label);
                }
            }
        });

        roadmapFilters[filterKey] = values;

        // For tag/release filter, entering exclusion mode when Select All is clicked
        if (filterType === 'tag') {
            roadmapFilters.tagsExclusionMode = true;
        }
        if (filterType === 'release') {
            roadmapFilters.releasesExclusionMode = true;
        }

        updateRoadmapFilterDisplay(filterType);
        renderRoadmapView();
        saveStateToStorage(); // Persist filter changes
    }

    function closeRoadmapDropdown(dropdownId) {
        const menu = document.getElementById(dropdownId)?.querySelector('.filter-dropdown-menu');
        if (menu) menu.classList.remove('open');
    }

    // Toggle team filter when clicking on a team card
    function toggleRoadmapTeamCard(team) {
        // If this team is already selected alone, clear it
        if (roadmapFilters.teams.length === 1 && roadmapFilters.teams[0] === team) {
            roadmapFilters.teams = [];
        } else {
            // Select only this team
            roadmapFilters.teams = [team];
        }

        // Sync the team dropdown checkboxes
        syncRoadmapTeamDropdown();
        updateRoadmapFilterDisplay('team');
        renderRoadmapView();
        saveStateToStorage(); // Persist filter changes
    }

    // Clear team filter (when clicking Total card)
    function clearRoadmapTeamFilter() {
        roadmapFilters.teams = [];
        syncRoadmapTeamDropdown();
        updateRoadmapFilterDisplay('team');
        renderRoadmapView();
        saveStateToStorage(); // Persist filter changes
    }

    // Sync the team dropdown checkboxes with roadmapFilters.teams
    function syncRoadmapTeamDropdown() {
        const optionsContainer = document.getElementById('roadmap-team-options');
        if (!optionsContainer) return;

        optionsContainer.querySelectorAll('.filter-dropdown-option').forEach(opt => {
            const cb = opt.querySelector('input[type="checkbox"]');
            const label = opt.querySelector('.option-label')?.textContent;
            if (cb && label) {
                cb.checked = roadmapFilters.teams.includes(label);
            }
        });
    }

    function clearAllRoadmapFilters() {
        // Clear search
        const searchInput = document.getElementById('roadmap-search-input');
        if (searchInput) searchInput.value = '';
        roadmapFilters.search = '';

        // Clear all filter arrays
        roadmapFilters.states = [];
        roadmapFilters.customers = [];
        roadmapFilters.assignees = [];
        roadmapFilters.teams = [];
        roadmapFilters.iterations = [];
        roadmapFilters.releases = [];
        roadmapFilters.releasesExclusionMode = false;
        roadmapFilters.tags = [];
        roadmapFilters.tagsExclusionMode = false;
        // Note: tagsLogicMode is not reset - user preference is preserved

        // Reset all dropdowns
        ['state', 'customer', 'assignee', 'team', 'iteration', 'release', 'tag'].forEach(type => {
            const optionsContainer = document.getElementById(`roadmap-${type}-options`);
            if (optionsContainer) {
                optionsContainer.querySelectorAll('input[type="checkbox"]').forEach(cb => cb.checked = false);
            }
            updateRoadmapFilterDisplay(type);
        });

        renderRoadmapView();
        saveStateToStorage(); // Persist filter changes
    }

    function applyRoadmapFilters() {
        const searchInput = document.getElementById('roadmap-search-input');
        roadmapFilters.search = searchInput ? searchInput.value : '';
        renderRoadmapView();
        saveStateToStorage(); // Persist filter changes
    }

    function getRoadmapColumnClass(key) {
        const classMap = {
            'id': 'col-id',
            'title': 'col-title',
            'state': 'col-state',
            'customers': 'col-customers',
            'tags': 'col-tags',
            'assignedTo': 'col-assignee',
            'releaseVersion': 'col-release',
            'effort': 'col-effort'
        };
        return classMap[key] || '';
    }

    function sortRoadmapTable(columnKey) {
        // Toggle direction if same column, otherwise set to asc
        if (roadmapSortState.column === columnKey) {
            roadmapSortState.direction = roadmapSortState.direction === 'asc' ? 'desc' : 'asc';
        } else {
            roadmapSortState.column = columnKey;
            roadmapSortState.direction = 'asc';
        }
        renderRoadmapView();
        saveStateToStorage(); // Persist sort changes
    }

    function getRoadmapSortIndicator(columnKey) {
        if (roadmapSortState.column !== columnKey) return '';
        return roadmapSortState.direction === 'asc' ? '‚ñ≤' : '‚ñº';
    }

    function sortRoadmapItems(items, column, direction, effortMap) {
        return [...items].sort((a, b) => {
            let aVal, bVal;

            // Handle effort column specially - uses calculated effort map
            if (column === 'effort' && effortMap) {
                aVal = effortMap[a.id] || 0;
                bVal = effortMap[b.id] || 0;
            } else {
                aVal = a[column];
                bVal = b[column];
            }

            // Handle null/undefined
            if (aVal == null) aVal = '';
            if (bVal == null) bVal = '';

            // Handle numbers (id, effort)
            if (column === 'id' || column === 'effort') {
                aVal = parseFloat(aVal) || 0;
                bVal = parseFloat(bVal) || 0;
            } else {
                // Handle strings
                aVal = String(aVal).toLowerCase();
                bVal = String(bVal).toLowerCase();
            }

            if (aVal < bVal) return direction === 'asc' ? -1 : 1;
            if (aVal > bVal) return direction === 'asc' ? 1 : -1;
            return 0;
        });
    }

    function resetRoadmapSort() {
        roadmapSortState.column = null;
        roadmapSortState.direction = 'asc';
        renderRoadmapView();
        saveStateToStorage(); // Persist sort changes
    }

    // Show delivery slices for a feature in a modal
    function drilldownFeatureSlices(featureId, featureTitle) {
        const slices = getDeliverySlicesForFeatures([featureId]);
        const modal = document.getElementById('feature-slices-modal');
        const titleEl = document.getElementById('feature-modal-title');
        const contentEl = document.getElementById('feature-modal-content');

        if (!modal || !titleEl || !contentEl) {
            console.error('[Roadmap] Modal elements not found');
            return;
        }

        // Set title
        titleEl.textContent = `Feature ${featureId}: ${featureTitle}`;

        if (slices.length === 0) {
            contentEl.innerHTML = `<div class="feature-modal-empty">No Delivery Slices found for this Feature.</div>`;
        } else {
            // Check if team/iteration filters are active
            const activeTeamFilter = roadmapFilters.teams.length === 1 ? roadmapFilters.teams[0] : null;
            const activeIterationFilter = roadmapFilters.iterations.length === 1 ? roadmapFilters.iterations[0] : null;

            // Sort slices: matching filters first, then others
            let sortedSlices = [...slices];
            sortedSlices.sort((a, b) => {
                const teamA = a.team || getLastPathSegment(a.areaPath) || '(No Team)';
                const teamB = b.team || getLastPathSegment(b.areaPath) || '(No Team)';
                const iterA = a.iteration || getLastPathSegment(a.iterationPath) || '(No Iteration)';
                const iterB = b.iteration || getLastPathSegment(b.iterationPath) || '(No Iteration)';

                // Calculate match score (higher = better match)
                const matchA = (activeTeamFilter && teamA === activeTeamFilter ? 2 : 0) +
                               (activeIterationFilter && iterA === activeIterationFilter ? 1 : 0);
                const matchB = (activeTeamFilter && teamB === activeTeamFilter ? 2 : 0) +
                               (activeIterationFilter && iterB === activeIterationFilter ? 1 : 0);

                return matchB - matchA;  // Higher score first
            });

            // Calculate effort summary
            let filteredEffort = 0;
            let totalEffort = 0;
            sortedSlices.forEach(ds => {
                const effort = ds.effort || 0;
                totalEffort += effort;
                const dsTeam = ds.team || getLastPathSegment(ds.areaPath) || '(No Team)';
                const dsIteration = ds.iteration || getLastPathSegment(ds.iterationPath) || '(No Iteration)';
                const teamMatch = !activeTeamFilter || dsTeam === activeTeamFilter;
                const iterationMatch = !activeIterationFilter || dsIteration === activeIterationFilter;
                if (teamMatch && iterationMatch) {
                    filteredEffort += effort;
                }
            });

            // Build effort summary HTML
            let effortSummaryHtml = '';
            const hasFilters = activeTeamFilter || activeIterationFilter;
            if (hasFilters) {
                const filterLabels = [];
                if (activeTeamFilter) filterLabels.push(activeTeamFilter);
                if (activeIterationFilter) filterLabels.push(activeIterationFilter);
                effortSummaryHtml = `
                    <div class="feature-modal-effort-summary">
                        <span class="effort-team-label">${filterLabels.join(' ¬∑ ')} Effort:</span>
                        <span class="effort-team-value">${filteredEffort.toFixed(1)}d</span>
                        <span class="effort-total-label">/ Total:</span>
                        <span class="effort-total-value">${totalEffort.toFixed(1)}d</span>
                    </div>
                `;
            } else {
                effortSummaryHtml = `
                    <div class="feature-modal-effort-summary">
                        <span class="effort-total-label">Total Effort:</span>
                        <span class="effort-total-value">${totalEffort.toFixed(1)}d</span>
                    </div>
                `;
            }

            // Build table rows
            const rows = sortedSlices.map(ds => {
                const iteration = ds.iteration || getLastPathSegment(ds.iterationPath) || '‚Äî';
                const team = ds.team || getLastPathSegment(ds.areaPath) || '‚Äî';

                // Determine if this row should be grayed out (doesn't match active filters)
                const teamMatch = !activeTeamFilter || team === activeTeamFilter;
                const iterationMatch = !activeIterationFilter || iteration === activeIterationFilter;
                const isOtherRow = !teamMatch || !iterationMatch;
                const rowClass = isOtherRow ? 'other-team-row' : '';

                return `
                    <tr class="${rowClass}">
                        <td class="feature-modal-col-id"><a href="${ds.url}" target="_blank" class="work-item-id">${ds.id}</a></td>
                        <td class="feature-modal-col-title" title="${(ds.title || '').replace(/"/g, '&quot;')}">${ds.title || ''}</td>
                        <td class="feature-modal-col-state"><span class="state-badge ${getStateClass(ds.state)}">${ds.state || ''}</span></td>
                        <td class="feature-modal-col-iteration">${iteration}</td>
                        <td class="feature-modal-col-team">${team}</td>
                        <td class="feature-modal-col-effort">${ds.effort || '‚Äî'}</td>
                        <td class="feature-modal-col-owner">${ds.assignedTo || '‚Äî'}</td>
                    </tr>
                `;
            }).join('');

            // Use separate header and body tables for fixed header
            contentEl.innerHTML = `
                ${effortSummaryHtml}
                <div class="feature-modal-table-container">
                    <div class="feature-modal-table-header">
                        <table>
                            <colgroup>
                                <col class="feature-modal-col-id">
                                <col class="feature-modal-col-title">
                                <col class="feature-modal-col-state">
                                <col class="feature-modal-col-iteration">
                                <col class="feature-modal-col-team">
                                <col class="feature-modal-col-effort">
                                <col class="feature-modal-col-owner">
                            </colgroup>
                            <thead>
                                <tr>
                                    <th>ID</th>
                                    <th>Title</th>
                                    <th>State</th>
                                    <th>Iteration</th>
                                    <th>Team</th>
                                    <th>Effort</th>
                                    <th>Owner</th>
                                </tr>
                            </thead>
                        </table>
                    </div>
                    <div class="feature-modal-table-body">
                        <table>
                            <colgroup>
                                <col class="feature-modal-col-id">
                                <col class="feature-modal-col-title">
                                <col class="feature-modal-col-state">
                                <col class="feature-modal-col-iteration">
                                <col class="feature-modal-col-team">
                                <col class="feature-modal-col-effort">
                                <col class="feature-modal-col-owner">
                            </colgroup>
                            <tbody>${rows}</tbody>
                        </table>
                    </div>
                </div>
            `;
        }

        // Show modal
        modal.style.display = 'flex';
    }

    // Scroll-to-close for roadmap dropdowns
    let roadmapScrollHandler = null;

    function setupRoadmapScrollToClose() {
        if (roadmapScrollHandler) return;

        roadmapScrollHandler = () => {
            // Close all roadmap dropdowns on scroll
            ['roadmap-state-dropdown', 'roadmap-customer-dropdown', 'roadmap-assignee-dropdown',
             'roadmap-team-dropdown', 'roadmap-iteration-dropdown', 'roadmap-release-dropdown', 'roadmap-tag-dropdown'].forEach(id => {
                const menu = document.getElementById(id)?.querySelector('.filter-dropdown-menu');
                if (menu && menu.classList.contains('open')) {
                    menu.classList.remove('open');
                }
            });
        };

        window.addEventListener('scroll', roadmapScrollHandler, { passive: true });
    }

    // Initialize scroll-to-close when DOM is ready
    if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', setupRoadmapScrollToClose);
    } else {
        setupRoadmapScrollToClose();
    }
</script>
