    <script>
    // Work items data will be injected here
    const workItems = WORK_ITEMS_PLACEHOLDER;

    // Work item links data (Parent/Child/Related relationships from WorkItemLinks.csv)
    const workItemLinks = WORK_ITEM_LINKS_PLACEHOLDER;

    // CSV validation data (injected from generator for data source validation)
    const csvValidationData = CSV_VALIDATION_DATA_PLACEHOLDER;

    // State management
    let currentView = 'executive';
    let drilldownStack = [];
    let multiSelectState = { field: null, values: new Set() };
    let activeCharts = {};
    let selectedReleases = []; // Array for multi-select
    let selectedTimePeriod = 'all';

    // ==================== STATE PERSISTENCE (localStorage) ====================
    // Use pathname-based key to keep DEV and PROD states independent
    const STORAGE_KEY = 'eshare-devops-dashboard-state-' + (window.location.pathname.includes('eSHARE-DevOps-Dashboard.html') ? 'dev' : 'prod');

    // Save current state to localStorage
    function saveStateToStorage() {
        try {
            const state = {
                currentView: currentView,
                // Roadmap view state
                roadmapFilters: typeof roadmapFilters !== 'undefined' ? roadmapFilters : null,
                roadmapSortState: typeof roadmapSortState !== 'undefined' ? roadmapSortState : null,
                roadmapTeamSummaryCollapsed: typeof roadmapTeamSummaryCollapsed !== 'undefined' ? roadmapTeamSummaryCollapsed : true,
                // Releases view state
                releaseHeaderFilters: typeof releaseHeaderFilters !== 'undefined' ? releaseHeaderFilters : null,
                releasesSearchFilter: typeof releasesSearchFilter !== 'undefined' ? releasesSearchFilter : '',
                selectedReleases: typeof selectedReleases !== 'undefined' ? selectedReleases : [],
                // Executive view state
                execChartFilters: typeof execChartFilters !== 'undefined' ? execChartFilters : null,
                execTeamFilter: document.getElementById('exec-team-filter')?.value || 'all',
                execTypeFilter: document.getElementById('exec-type-filter')?.value || 'all',
                // Customers view state (v80: Issues only, with filters for customers, categories, states, priorities, releases)
                customersFilters: typeof customersFilters !== 'undefined' ? customersFilters : null,
                customersSortState: typeof customersSortState !== 'undefined' ? customersSortState : null,
                customersColumnWidths: typeof customersColumnWidths !== 'undefined' ? customersColumnWidths : {},
                // Bugs view state
                bugsChartFilters: typeof bugsChartFilters !== 'undefined' ? bugsChartFilters : null,
                bugTrendFilters: typeof bugTrendFilters !== 'undefined' ? bugTrendFilters : null,
                selectedBugDateRange: typeof selectedBugDateRange !== 'undefined' ? selectedBugDateRange : 'quarter',
                bugTrendStartDate: document.getElementById('bug-trend-start')?.value || '',
                bugTrendEndDate: document.getElementById('bug-trend-end')?.value || '',
                // Teams view state
                teamLeadChartFilters: typeof teamLeadChartFilters !== 'undefined' ? teamLeadChartFilters : null,
                currentTeamDetails: typeof currentTeamDetails !== 'undefined' ? currentTeamDetails : null,
                selectedTimePeriod: typeof selectedTimePeriod !== 'undefined' ? selectedTimePeriod : 'all',
                engFilters: typeof engFilters !== 'undefined' ? engFilters : null,
                selectedEngineers: typeof selectedEngineers !== 'undefined' ? selectedEngineers : [],
                // Tasks view state
                tasksParentTypeFilter: document.getElementById('tasks-parent-type-filter')?.value || 'all',
                tasksTeamFilter: document.getElementById('tasks-team-filter')?.value || 'all',
                tasksStateFilter: typeof getSelectedTasksStates !== 'undefined' ? getSelectedTasksStates() : [],
                // Details view state
                detailsTypeFilter: document.getElementById('details-type-filter')?.value || 'all',
                detailsTeamFilter: document.getElementById('details-team-filter')?.value || 'all',
                detailsStateFilter: typeof getSelectedDetailsStates !== 'undefined' ? getSelectedDetailsStates() : [],
                // Validation view state
                validationTypeFilter: document.getElementById('validation-type-filter')?.value || 'all',
                validationTeamFilter: document.getElementById('validation-team-filter')?.value || 'all',
                validationStateFilter: typeof getSelectedValidationStates !== 'undefined' ? getSelectedValidationStates() : [],
                timestamp: Date.now()
            };
            localStorage.setItem(STORAGE_KEY, JSON.stringify(state));
        } catch (e) {
            console.warn('[State] Failed to save state to localStorage:', e);
        }
    }

    // Load state from localStorage
    function loadStateFromStorage() {
        try {
            const stored = localStorage.getItem(STORAGE_KEY);
            if (!stored) return null;

            const state = JSON.parse(stored);
            // State expires after 24 hours
            if (Date.now() - state.timestamp > 24 * 60 * 60 * 1000) {
                localStorage.removeItem(STORAGE_KEY);
                return null;
            }
            return state;
        } catch (e) {
            console.warn('[State] Failed to load state from localStorage:', e);
            return null;
        }
    }

    // Flag to indicate state was loaded and dropdowns need syncing
    let stateWasLoaded = false;
    let releasesStateWasLoaded = false;
    let executiveStateWasLoaded = false;
    let customersStateWasLoaded = false;
    let bugsStateWasLoaded = false;
    let teamsStateWasLoaded = false;
    let tasksStateWasLoaded = false;
    let detailsStateWasLoaded = false;
    let validationStateWasLoaded = false;

    // Loaded state storage (used for DOM restoration after render)
    let loadedStateCache = null;

    // Apply loaded state (called after all components are initialized)
    function applyLoadedState(state) {
        if (!state) return;

        // Cache state for DOM restoration after render
        loadedStateCache = state;

        // Restore roadmap filters if available
        if (state.roadmapFilters && typeof roadmapFilters !== 'undefined') {
            Object.assign(roadmapFilters, state.roadmapFilters);
            stateWasLoaded = true;
        }

        // Restore roadmap sort state if available
        if (state.roadmapSortState && typeof roadmapSortState !== 'undefined') {
            Object.assign(roadmapSortState, state.roadmapSortState);
        }

        // Restore Team Summary collapse state
        if (typeof state.roadmapTeamSummaryCollapsed !== 'undefined' && typeof roadmapTeamSummaryCollapsed !== 'undefined') {
            roadmapTeamSummaryCollapsed = state.roadmapTeamSummaryCollapsed;
            // Apply collapse state to DOM after render
            setTimeout(() => {
                const section = document.getElementById('roadmap-section-teams');
                if (section) {
                    section.classList.toggle('collapsed', roadmapTeamSummaryCollapsed);
                }
            }, 0);
        }

        // Restore Releases view state
        if (state.releaseHeaderFilters && typeof releaseHeaderFilters !== 'undefined') {
            Object.assign(releaseHeaderFilters, state.releaseHeaderFilters);
            releasesStateWasLoaded = true;
        }
        if (typeof state.releasesSearchFilter !== 'undefined' && typeof releasesSearchFilter !== 'undefined') {
            releasesSearchFilter = state.releasesSearchFilter;
        }
        if (state.selectedReleases && typeof selectedReleases !== 'undefined') {
            selectedReleases = [...state.selectedReleases];
        }

        // Restore Executive view state
        if (state.execChartFilters && typeof execChartFilters !== 'undefined') {
            Object.assign(execChartFilters, state.execChartFilters);
        }
        // Always mark as loaded if we have any executive state (even if default values)
        if (typeof state.execTeamFilter !== 'undefined' || typeof state.execTypeFilter !== 'undefined') {
            executiveStateWasLoaded = true;
        }

        // Restore Customers view state
        if (state.customersFilters && typeof customersFilters !== 'undefined') {
            Object.assign(customersFilters, state.customersFilters);
        }
        if (state.customersSortState && typeof customersSortState !== 'undefined') {
            Object.assign(customersSortState, state.customersSortState);
        }
        if (state.customersColumnWidths && typeof customersColumnWidths !== 'undefined') {
            Object.assign(customersColumnWidths, state.customersColumnWidths);
        }
        // Always mark as loaded if we have any customer state
        if (state.customersFilters || state.customersSortState || state.customersColumnWidths) {
            customersStateWasLoaded = true;
        }

        // Restore Bugs view state
        if (state.bugsChartFilters && typeof bugsChartFilters !== 'undefined') {
            Object.assign(bugsChartFilters, state.bugsChartFilters);
        }
        if (state.bugTrendFilters && typeof bugTrendFilters !== 'undefined') {
            Object.assign(bugTrendFilters, state.bugTrendFilters);
        }
        if (typeof state.selectedBugDateRange !== 'undefined' && typeof selectedBugDateRange !== 'undefined') {
            selectedBugDateRange = state.selectedBugDateRange;
        }
        // Always mark as loaded if we have any bugs state
        if (typeof state.selectedBugDateRange !== 'undefined' || state.bugTrendFilters || typeof state.bugTrendStartDate !== 'undefined') {
            bugsStateWasLoaded = true;
        }

        // Restore Teams view state
        if (state.teamLeadChartFilters && typeof teamLeadChartFilters !== 'undefined') {
            Object.assign(teamLeadChartFilters, state.teamLeadChartFilters);
        }
        if (typeof state.currentTeamDetails !== 'undefined' && typeof currentTeamDetails !== 'undefined') {
            currentTeamDetails = state.currentTeamDetails;
        }
        if (typeof state.selectedTimePeriod !== 'undefined' && typeof selectedTimePeriod !== 'undefined') {
            selectedTimePeriod = state.selectedTimePeriod;
        }
        if (state.engFilters && typeof engFilters !== 'undefined') {
            Object.assign(engFilters, state.engFilters);
        }
        if (state.selectedEngineers && typeof selectedEngineers !== 'undefined') {
            selectedEngineers = [...state.selectedEngineers];
        }
        // Always mark as loaded if we have any teams state
        if (typeof state.selectedTimePeriod !== 'undefined' || state.teamLeadChartFilters || state.engFilters) {
            teamsStateWasLoaded = true;
        }

        // Mark Tasks view state for restoration - always if we have any tasks state
        if (typeof state.tasksParentTypeFilter !== 'undefined' || typeof state.tasksTeamFilter !== 'undefined' || state.tasksStateFilter) {
            tasksStateWasLoaded = true;
        }

        // Mark Details view state for restoration - always if we have any details state
        if (typeof state.detailsTypeFilter !== 'undefined' || typeof state.detailsTeamFilter !== 'undefined' || state.detailsStateFilter) {
            detailsStateWasLoaded = true;
        }

        // Mark Validation view state for restoration - always if we have any validation state
        if (typeof state.validationTypeFilter !== 'undefined' || typeof state.validationTeamFilter !== 'undefined' || state.validationStateFilter) {
            validationStateWasLoaded = true;
        }

        // Restore view (will be applied during initialization)
        if (state.currentView) {
            currentView = state.currentView;
        }
    }
    
    // Color palettes
    const colors = {
        primary: ['#22d3ee', '#a78bfa', '#34d399', '#fb923c', '#f87171', '#60a5fa', '#f472b6', '#fbbf24', '#4ade80', '#818cf8'],
        states: {
            'Done': '#34d399',
            'Closed': '#34d399',
            'In Progress': '#60a5fa',
            'New': '#94a3b8',
            'To Do': '#94a3b8',
            'Triaged': '#fb923c',
            'Removed': '#f87171',
            'Ready For Review': '#a78bfa'
        },
        teams: {
            'Frontend': '#60a5fa',
            'Backend': '#34d399',
            'QA': '#fb923c',
            'DevOps': '#a78bfa',
            'Analytics': '#f472b6',
            'Govern': '#22d3ee',
            'Customer Success': '#fbbf24',
            'eShare': '#94a3b8',
            'SCG': '#f87171'
        },
        bugTypes: {
            'Customer Related': '#f87171',
            'Product Quality': '#fb923c',
            'Technical & Infrastructure': '#a78bfa'
        },
        priority: {
            '1': '#f87171',
            '2': '#fb923c',
            '3': '#fbbf24',
            '4': '#94a3b8'
        }
    };
    
    // ==================== HEADER HELPERS ====================
    
    // Toggle mobile navigation
    function toggleMobileNav() {
        document.getElementById('nav-mobile').classList.toggle('open');
    }
    
    // Toggle filter dropdown
    function toggleFilterDropdown(dropdownId) {
        const menu = document.querySelector(`#${dropdownId} .filter-dropdown-menu`);
        const isOpen = menu.classList.contains('open');
        
        // Close all dropdowns first
        document.querySelectorAll('.filter-dropdown-menu').forEach(m => m.classList.remove('open'));
        document.querySelectorAll('.info-panel').forEach(p => p.classList.remove('open'));
        
        // Toggle the clicked one
        if (!isOpen) {
            menu.classList.add('open');
            openDropdownId = dropdownId;
        } else {
            openDropdownId = null;
        }
    }
    
    // Toggle header info panel
    function toggleHeaderInfo(panelId) {
        const panel = document.getElementById(panelId);
        const isOpen = panel.classList.contains('open');
        
        // Close all panels and dropdowns first
        document.querySelectorAll('.info-panel').forEach(p => p.classList.remove('open'));
        document.querySelectorAll('.filter-dropdown-menu').forEach(m => m.classList.remove('open'));
        openDropdownId = null;
        
        // Toggle the clicked one
        if (!isOpen) {
            panel.classList.add('open');
        }
    }
    
    // Track which dropdown is currently open
    let openDropdownId = null;
    
    // Track if any release filter dropdown was open
    let releaseFilterDropdownWasOpen = false;
    
    // Close dropdowns when clicking outside
    document.addEventListener('click', function(e) {
        if (!e.target.closest('.filter-dropdown') && !e.target.closest('.filter-row-info')) {
            openDropdownId = null;
            document.querySelectorAll('.filter-dropdown-menu').forEach(m => m.classList.remove('open'));
            document.querySelectorAll('.info-panel').forEach(p => p.classList.remove('open'));
        }
    });

    // Close dropdowns when scrolling the window
    window.addEventListener('scroll', function() {
        if (openDropdownId) {
            openDropdownId = null;
            document.querySelectorAll('.filter-dropdown-menu').forEach(m => m.classList.remove('open'));
            document.querySelectorAll('.info-panel').forEach(p => p.classList.remove('open'));
        }
    }, { passive: true });

    // Re-open a dropdown after re-render
    function reopenDropdown() {
        if (openDropdownId) {
            const menu = document.querySelector(`#${openDropdownId} .filter-dropdown-menu`);
            if (menu) {
                menu.classList.add('open');
            }
        }
    }
    
    // Update release header filter display text
    function updateReleaseHeaderDisplay() {
        const display = document.getElementById('release-filter-display');
        if (!display) return;
        
        const totalOptions = document.querySelectorAll('#release-filter-menu .filter-dropdown-option input[type="checkbox"]').length;
        
        if (selectedReleases.length === 0) {
            display.textContent = 'All Releases';
        } else if (selectedReleases.length === 1) {
            display.textContent = selectedReleases[0];
        } else if (selectedReleases.length <= 2) {
            display.textContent = selectedReleases.join(', ');
        } else {
            display.textContent = `${selectedReleases.length} releases selected`;
        }
    }
    
    // Handle release checkbox change - standard multi-select behavior
    function handleReleaseCheckboxChange(releaseVersion, checked, event) {
        event.stopPropagation(); // Keep dropdown open
        openDropdownId = 'release-filter-dropdown';

        // Save scroll position before re-render
        const optionsContainer = document.getElementById('release-dropdown-options');
        const scrollTop = optionsContainer ? optionsContainer.scrollTop : 0;

        if (checked) {
            if (!selectedReleases.includes(releaseVersion)) {
                selectedReleases.push(releaseVersion);
            }
        } else {
            selectedReleases = selectedReleases.filter(r => r !== releaseVersion);
        }

        updateReleaseHeaderDisplay();
        updateClearFiltersButton();
        saveStateToStorage();
        renderReleasesView();
        reopenDropdown();

        // Restore scroll position after re-render
        const newOptionsContainer = document.getElementById('release-dropdown-options');
        if (newOptionsContainer) {
            newOptionsContainer.scrollTop = scrollTop;
        }
    }

    // Select all releases - re-render immediately
    function selectAllReleases(event) {
        if (event) event.stopPropagation();
        openDropdownId = 'release-filter-dropdown';
        const checkboxes = document.querySelectorAll('#release-filter-menu .filter-dropdown-option input[type="checkbox"]');
        selectedReleases = [];
        checkboxes.forEach(cb => {
            cb.checked = true;
            selectedReleases.push(cb.dataset.release);
        });
        updateReleaseHeaderDisplay();
        updateClearFiltersButton();
        saveStateToStorage();
        renderReleasesView();
        reopenDropdown();
    }

    // Clear release selection - re-render immediately
    function clearReleaseSelection(event) {
        if (event) event.stopPropagation();
        openDropdownId = 'release-filter-dropdown';
        document.querySelectorAll('#release-filter-menu .filter-dropdown-option input[type="checkbox"]').forEach(cb => {
            cb.checked = false;
        });
        selectedReleases = [];
        updateReleaseHeaderDisplay();
        updateClearFiltersButton();
        saveStateToStorage();
        renderReleasesView();
        reopenDropdown();
    }
    
    // ==================== RELEASE HEADER FILTERS ====================
    
    // Store header filter selections
    let releaseHeaderFilters = {
        type: [],
        bugtype: [],
        state: [],
        team: [],
        customer: [],
        priority: []
    };

    // Releases search filter
    let releasesSearchFilter = '';
    
    // Filter dropdown options by search text
    function filterDropdownOptions(filterType, searchText) {
        const searchLower = searchText.toLowerCase().trim();
        const optionsContainer = document.getElementById(`release-${filterType}-options`);
        if (!optionsContainer) return;

        const options = optionsContainer.querySelectorAll('.filter-dropdown-option');
        options.forEach(option => {
            const searchValue = option.getAttribute('data-search-value') || '';
            if (searchLower === '' || searchValue.includes(searchLower)) {
                option.style.display = '';
            } else {
                option.style.display = 'none';
            }
        });
    }

    // Filter Release dropdown options (special case with different structure)
    function filterReleaseDropdownOptions(searchText) {
        const searchLower = searchText.toLowerCase().trim();
        const optionsContainer = document.getElementById('release-dropdown-options');
        if (!optionsContainer) return;

        const options = optionsContainer.querySelectorAll('.filter-dropdown-option');
        options.forEach(option => {
            const searchValue = option.getAttribute('data-search-value') || '';
            if (searchLower === '' || searchValue.includes(searchLower)) {
                option.style.display = '';
            } else {
                option.style.display = 'none';
            }
        });
    }

    // Update header filter when checkbox changes - re-render immediately
    function updateReleaseHeaderFilter(filterType, event) {
        if (event) event.stopPropagation();
        openDropdownId = `release-${filterType}-header-dropdown`;
        const checkboxes = document.querySelectorAll(`#release-${filterType}-header-menu input[data-filter="${filterType}"]:checked`);
        releaseHeaderFilters[filterType] = Array.from(checkboxes).map(cb => cb.value);
        updateReleaseHeaderFilterDisplay(filterType);
        updateClearFiltersButton();
        saveStateToStorage();
        renderReleasesView();
        reopenDropdown();
    }
    
    // Update display text for header filter
    function updateReleaseHeaderFilterDisplay(filterType) {
        const display = document.getElementById(`release-${filterType}-header-display`);
        if (!display) return;
        
        const labels = {
            type: 'All Types',
            bugtype: 'All Bug Types',
            state: 'All States',
            team: 'All Teams',
            customer: 'All Customers'
        };
        
        const selected = releaseHeaderFilters[filterType];
        const totalCheckboxes = document.querySelectorAll(`#release-${filterType}-header-menu input[data-filter="${filterType}"]`).length;
        
        if (selected.length === 0 || selected.length === totalCheckboxes) {
            display.textContent = labels[filterType];
        } else if (selected.length === 1) {
            display.textContent = selected[0];
        } else {
            display.textContent = `${selected.length} selected`;
        }
    }
    
    // Select all for header filter - re-render immediately
    function selectAllHeaderFilter(filterType, event) {
        if (event) event.stopPropagation();
        openDropdownId = `release-${filterType}-header-dropdown`;
        const checkboxes = document.querySelectorAll(`#release-${filterType}-header-menu input[data-filter="${filterType}"]`);
        releaseHeaderFilters[filterType] = [];
        checkboxes.forEach(cb => {
            cb.checked = true;
            releaseHeaderFilters[filterType].push(cb.value);
        });
        updateReleaseHeaderFilterDisplay(filterType);
        updateClearFiltersButton();
        saveStateToStorage();
        renderReleasesView();
        reopenDropdown();
    }

    // Clear header filter - re-render immediately
    function clearHeaderFilter(filterType, event) {
        if (event) event.stopPropagation();
        openDropdownId = `release-${filterType}-header-dropdown`;
        document.querySelectorAll(`#release-${filterType}-header-menu input[data-filter="${filterType}"]`).forEach(cb => {
            cb.checked = false;
        });
        releaseHeaderFilters[filterType] = [];
        updateReleaseHeaderFilterDisplay(filterType);
        updateClearFiltersButton();
        saveStateToStorage();
        renderReleasesView();
        reopenDropdown();
    }

    // Filter Type options by search text
    function filterReleaseTypeOptions(searchText) {
        const container = document.getElementById('release-type-options');
        if (!container) return;
        const searchLower = searchText.toLowerCase();
        container.querySelectorAll('.filter-dropdown-option').forEach(opt => {
            const searchValue = opt.dataset.searchValue || '';
            opt.style.display = searchValue.includes(searchLower) ? '' : 'none';
        });
    }

    // Filter Bug Type options by search text
    function filterReleaseBugTypeOptions(searchText) {
        const container = document.getElementById('release-bugtype-options');
        if (!container) return;
        const searchLower = searchText.toLowerCase();
        container.querySelectorAll('.filter-dropdown-option').forEach(opt => {
            const searchValue = opt.dataset.searchValue || '';
            opt.style.display = searchValue.includes(searchLower) ? '' : 'none';
        });
    }

    // Check if any release filters are active
    function hasActiveReleaseFilters() {
        if (hasGenericSearchFilter('releases')) return true;
        if (selectedReleases.length > 0) return true;
        if (releaseHeaderFilters.type.length > 0) return true;
        if (releaseHeaderFilters.bugtype.length > 0) return true;
        if (releaseHeaderFilters.state.length > 0) return true;
        if (releaseHeaderFilters.team.length > 0) return true;
        if (releaseHeaderFilters.customer.length > 0) return true;
        if (releaseHeaderFilters.priority.length > 0) return true;
        return false;
    }
    
    // Clear all release filters
    function clearAllReleaseFilters() {
        // Clear search using generic component
        clearGenericSearch('releases');

        // Clear release selection
        selectedReleases = [];
        document.querySelectorAll('#release-filter-menu .filter-dropdown-option input[type="checkbox"]').forEach(cb => {
            cb.checked = false;
        });
        updateReleaseHeaderDisplay();

        // Clear header filters (except customer which uses generic component)
        ['type', 'bugtype', 'state', 'team'].forEach(filterType => {
            document.querySelectorAll(`#release-${filterType}-header-menu input[data-filter="${filterType}"]`).forEach(cb => {
                cb.checked = false;
            });
            releaseHeaderFilters[filterType] = [];
            updateReleaseHeaderFilterDisplay(filterType);
        });

        // Clear customer using generic component
        clearGenericCustomer('releases');

        // Clear priority using generic component
        clearGenericPriority('releases');

        // Hide clear button
        const clearBtn = document.getElementById('release-clear-filters-btn');
        if (clearBtn) clearBtn.classList.add('hidden');

        saveStateToStorage();
        renderReleasesView();
    }

    // Sync Releases view dropdowns with loaded state
    function syncReleasesFilterDropdowns() {
        // Restore search input using generic component
        syncGenericSearchFilter('releases');

        // Sync release selection checkboxes
        document.querySelectorAll('#release-dropdown-options input[type="checkbox"]').forEach(cb => {
            cb.checked = selectedReleases.includes(cb.value);
        });
        updateReleaseHeaderDisplay();

        // Sync header filter checkboxes (type, bugtype - not generic filters)
        ['type', 'bugtype'].forEach(filterType => {
            document.querySelectorAll(`#release-${filterType}-header-menu input[data-filter="${filterType}"]`).forEach(cb => {
                cb.checked = releaseHeaderFilters[filterType].includes(cb.value);
            });
            updateReleaseHeaderFilterDisplay(filterType);
        });

        // Sync generic filter components
        syncGenericCustomerFilter('releases');
        syncGenericPriorityFilter('releases');
        syncGenericStateFilter('releases');
        syncGenericTeamFilter('releases');

        updateClearFiltersButton();
    }

    // Update clear button visibility
    function updateClearFiltersButton() {
        const clearBtn = document.getElementById('release-clear-filters-btn');
        if (clearBtn) {
            if (hasActiveReleaseFilters()) {
                clearBtn.classList.remove('hidden');
            } else {
                clearBtn.classList.add('hidden');
            }
        }
    }
    
    // Get filtered release items based on header filters
    function getHeaderFilteredReleaseItems(items) {
        // Apply generic search filter first
        let filtered = applyGenericSearchFilter(items, releasesSearchFilter);

        return filtered.filter(item => {
            // Type filter
            if (releaseHeaderFilters.type.length > 0) {
                let typeMatch = false;
                if (releaseHeaderFilters.type.includes('Feature') && item.type === 'Feature') typeMatch = true;
                if (releaseHeaderFilters.type.includes('Issue') && item.type === 'Issue') typeMatch = true;
                if (releaseHeaderFilters.type.includes('CustomerBug') && item.type === 'Bug' && item.bugType === 'Customer Related') typeMatch = true;
                if (releaseHeaderFilters.type.includes('InternalBug') && item.type === 'Bug' && item.bugType !== 'Customer Related') typeMatch = true;
                if (!typeMatch) return false;
            }
            
            // Bug type filter - when active, only Bugs can match (Features/Issues are excluded)
            if (releaseHeaderFilters.bugtype.length > 0) {
                if (item.type !== 'Bug') return false; // Non-bugs are excluded when bugtype filter is active
                if (!releaseHeaderFilters.bugtype.includes(item.bugType)) return false;
            }
            
            // State filter
            if (releaseHeaderFilters.state.length > 0) {
                if (!releaseHeaderFilters.state.includes(item.state)) return false;
            }
            
            // Team filter
            if (releaseHeaderFilters.team.length > 0) {
                if (!releaseHeaderFilters.team.includes(item.team || '(Not Set)')) return false;
            }
            
            // Customer filter - item must have at least one of the selected customers
            if (releaseHeaderFilters.customer.length > 0) {
                if (!item.customers) return false;
                const itemCustomers = item.customers.split(';').map(c => c.trim()).filter(c => c);
                const hasMatchingCustomer = itemCustomers.some(c => releaseHeaderFilters.customer.includes(c));
                if (!hasMatchingCustomer) return false;
            }

            // Priority filter
            if (releaseHeaderFilters.priority.length > 0) {
                const itemPriority = item.priority ? 'P' + item.priority : '(No Priority)';
                if (!releaseHeaderFilters.priority.includes(itemPriority)) return false;
            }

            return true;
        });
    }

    // ==================== GENERIC RELEASE FILTER COMPONENT ====================
    // Shared Release filter dropdown used by Releases, Roadmap, and Customers dashboards

    /**
     * Compute release info from work items
     * @param {Array} items - Work items to analyze
     * @returns {Object} { releases: [...], releaseInfo: {...}, noReleaseCount: number, needsReleaseCount: number }
     */
    function computeReleaseInfo(items) {
        const releaseInfo = {};
        let noReleaseCount = 0;      // Items with no release AND no target date
        let needsReleaseCount = 0;   // Items with target date but no release (needs attention)

        items.forEach(item => {
            const rv = item.releaseVersion;
            if (!rv) {
                // No release version - categorize based on whether it has a target date
                if (item.targetDate) {
                    needsReleaseCount++;  // Has date but needs release assignment
                } else {
                    noReleaseCount++;     // No release, no date
                }
                return;
            }
            if (!releaseInfo[rv]) {
                releaseInfo[rv] = { dates: new Set(), count: 0, items: [] };
            }
            if (item.targetDate) {
                releaseInfo[rv].dates.add(item.targetDate.split('T')[0]); // Just the date part
            }
            releaseInfo[rv].count++;
            releaseInfo[rv].items.push(item);
        });

        // Sort releases by date (earliest first), then alphabetically
        const releases = Object.keys(releaseInfo).sort((a, b) => {
            const datesA = [...releaseInfo[a].dates].sort();
            const datesB = [...releaseInfo[b].dates].sort();
            const dateA = datesA[0] || 'ZZZZ';
            const dateB = datesB[0] || 'ZZZZ';
            if (dateA !== dateB) return dateA.localeCompare(dateB);
            return a.localeCompare(b);
        });

        return { releases, releaseInfo, noReleaseCount, needsReleaseCount };
    }

    /**
     * Build Release filter dropdown HTML (generic component)
     * @param {Object} config - Configuration object
     * @param {string} config.dashboardId - 'releases', 'roadmap', or 'customers'
     * @param {Array} config.items - Work items to build options from
     * @param {Array} config.selectedReleases - Currently selected release versions
     * @param {string} config.searchFilter - Current search filter (optional, for highlighting)
     * @returns {string} HTML string for dropdown content
     */
    function buildReleaseFilterDropdown(config) {
        const { dashboardId, items, selectedReleases, searchFilter = '' } = config;
        const { releases, releaseInfo, noReleaseCount, needsReleaseCount } = computeReleaseInfo(items);

        const menuId = `${dashboardId}-release-menu`;
        const optionsId = `${dashboardId}-release-options`;

        let html = `
            <div class="filter-dropdown-search">
                <input type="text" placeholder="Search releases..."
                       oninput="filterGenericReleaseOptions('${optionsId}', this.value)"
                       onclick="event.stopPropagation();">
            </div>
            <div class="filter-dropdown-options" id="${optionsId}">
        `;

        // Regular releases with dates (at the top)
        releases.forEach(r => {
            const info = releaseInfo[r];
            const isChecked = selectedReleases.includes(r);
            let dateDisplay;
            if (info.dates.size === 1) {
                dateDisplay = [...info.dates][0];
            } else if (info.dates.size > 1) {
                dateDisplay = 'Multiple dates';
            } else {
                dateDisplay = 'No date';
            }

            const escapedRelease = r.replace(/"/g, '&quot;');
            const escapedReleaseJs = r.replace(/'/g, "\\'").replace(/"/g, '&quot;');
            html += `
                <label class="filter-dropdown-option" data-search-value="${r.toLowerCase()}" onclick="event.stopPropagation();">
                    <input type="checkbox" value="${escapedRelease}" ${isChecked ? 'checked' : ''}
                           onchange="handleGenericReleaseChange('${dashboardId}', '${escapedReleaseJs}', this.checked, event)">
                    <span class="option-label">${r}</span>
                    <span class="option-meta">${dateDisplay}</span>
                </label>
            `;
        });

        // ⚠️ Needs Release - items with target date but no release version (warning)
        if (needsReleaseCount > 0) {
            const isChecked = selectedReleases.includes('(Needs Release)');
            html += `
                <label class="filter-dropdown-option warning" data-search-value="needs release" onclick="event.stopPropagation();">
                    <input type="checkbox" value="(Needs Release)" ${isChecked ? 'checked' : ''}
                           onchange="handleGenericReleaseChange('${dashboardId}', '(Needs Release)', this.checked, event)">
                    <span class="option-label">⚠️ Needs Release</span>
                    <span class="option-meta">${needsReleaseCount} items</span>
                </label>
            `;
        }

        // (No Release) option - items with no release AND no target date
        if (noReleaseCount > 0) {
            const isChecked = selectedReleases.includes('(No Release)');
            html += `
                <label class="filter-dropdown-option" data-search-value="no release not set" onclick="event.stopPropagation();">
                    <input type="checkbox" value="(No Release)" ${isChecked ? 'checked' : ''}
                           onchange="handleGenericReleaseChange('${dashboardId}', '(No Release)', this.checked, event)">
                    <span class="option-label">(No Release)</span>
                    <span class="option-meta">${noReleaseCount} items</span>
                </label>
            `;
        }

        html += `</div>`;
        html += `
            <div class="filter-dropdown-actions">
                <button class="filter-btn-primary" onclick="selectAllGenericRelease('${dashboardId}', event)">Select All</button>
                <button class="filter-btn-secondary" onclick="clearGenericRelease('${dashboardId}', event)">Clear</button>
            </div>
        `;

        return html;
    }

    /**
     * Filter release dropdown options by search text
     */
    function filterGenericReleaseOptions(optionsId, searchText) {
        const searchLower = searchText.toLowerCase().trim();
        const optionsContainer = document.getElementById(optionsId);
        if (!optionsContainer) return;

        const options = optionsContainer.querySelectorAll('.filter-dropdown-option');
        options.forEach(option => {
            const searchValue = option.getAttribute('data-search-value') || '';
            option.style.display = (searchLower === '' || searchValue.includes(searchLower)) ? '' : 'none';
        });
    }

    /**
     * Handle release checkbox change - routes to appropriate dashboard handler
     */
    function handleGenericReleaseChange(dashboardId, releaseVersion, checked, event) {
        event.stopPropagation();

        // Save scroll position before re-render
        const optionsId = `${dashboardId}-release-options`;
        const optionsContainer = document.getElementById(optionsId);
        const scrollTop = optionsContainer ? optionsContainer.scrollTop : 0;

        // Route to dashboard-specific logic
        if (dashboardId === 'releases') {
            // Releases dashboard uses selectedReleases array
            openDropdownId = 'release-filter-dropdown';
            if (checked) {
                if (!selectedReleases.includes(releaseVersion)) selectedReleases.push(releaseVersion);
            } else {
                selectedReleases = selectedReleases.filter(r => r !== releaseVersion);
            }
            updateReleaseHeaderDisplay();
            updateClearFiltersButton();
            saveStateToStorage();
            renderReleasesView();
        } else if (dashboardId === 'roadmap') {
            // Roadmap dashboard uses roadmapFilters.releases
            openDropdownId = 'roadmap-release-dropdown';
            if (checked) {
                if (!roadmapFilters.releases.includes(releaseVersion)) roadmapFilters.releases.push(releaseVersion);
            } else {
                roadmapFilters.releases = roadmapFilters.releases.filter(r => r !== releaseVersion);
            }
            roadmapFilters.releasesExclusionMode = false; // Switch to inclusion mode on manual selection
            updateGenericReleaseDisplay('roadmap');
            // Note: Clear button visibility is updated in renderRoadmapView()
            saveStateToStorage();
            renderRoadmapView();
        } else if (dashboardId === 'customers') {
            // Customers dashboard uses customersFilters.releases
            openDropdownId = 'customers-release-dropdown';
            if (checked) {
                if (!customersFilters.releases.includes(releaseVersion)) customersFilters.releases.push(releaseVersion);
            } else {
                customersFilters.releases = customersFilters.releases.filter(r => r !== releaseVersion);
            }
            updateGenericReleaseDisplay('customers');
            updateCustomersClearButton();
            saveStateToStorage();
            renderCustomersView();
        }

        reopenDropdown();

        // Restore scroll position after re-render
        const newOptionsContainer = document.getElementById(optionsId);
        if (newOptionsContainer) newOptionsContainer.scrollTop = scrollTop;
    }

    /**
     * Select all releases for a dashboard
     */
    function selectAllGenericRelease(dashboardId, event) {
        if (event) event.stopPropagation();

        const optionsId = `${dashboardId}-release-options`;
        const checkboxes = document.querySelectorAll(`#${optionsId} input[type="checkbox"]`);
        const allValues = Array.from(checkboxes).map(cb => cb.value);

        if (dashboardId === 'releases') {
            openDropdownId = 'release-filter-dropdown';
            selectedReleases = allValues;
            checkboxes.forEach(cb => cb.checked = true);
            updateReleaseHeaderDisplay();
            updateClearFiltersButton();
            saveStateToStorage();
            renderReleasesView();
        } else if (dashboardId === 'roadmap') {
            openDropdownId = 'roadmap-release-dropdown';
            roadmapFilters.releases = allValues;
            roadmapFilters.releasesExclusionMode = true; // Switch to exclusion mode on Select All
            checkboxes.forEach(cb => cb.checked = true);
            updateGenericReleaseDisplay('roadmap');
            // Note: Clear button visibility is updated in renderRoadmapView()
            saveStateToStorage();
            renderRoadmapView();
        } else if (dashboardId === 'customers') {
            openDropdownId = 'customers-release-dropdown';
            customersFilters.releases = allValues;
            checkboxes.forEach(cb => cb.checked = true);
            updateGenericReleaseDisplay('customers');
            updateCustomersClearButton();
            saveStateToStorage();
            renderCustomersView();
        }

        reopenDropdown();
    }

    /**
     * Clear release selection for a dashboard
     */
    function clearGenericRelease(dashboardId, event) {
        if (event) event.stopPropagation();

        const optionsId = `${dashboardId}-release-options`;
        const checkboxes = document.querySelectorAll(`#${optionsId} input[type="checkbox"]`);
        checkboxes.forEach(cb => cb.checked = false);

        if (dashboardId === 'releases') {
            openDropdownId = 'release-filter-dropdown';
            selectedReleases = [];
            updateReleaseHeaderDisplay();
            updateClearFiltersButton();
            saveStateToStorage();
            renderReleasesView();
        } else if (dashboardId === 'roadmap') {
            openDropdownId = 'roadmap-release-dropdown';
            roadmapFilters.releases = [];
            roadmapFilters.releasesExclusionMode = false;
            updateGenericReleaseDisplay('roadmap');
            // Note: Clear button visibility is updated in renderRoadmapView()
            saveStateToStorage();
            renderRoadmapView();
        } else if (dashboardId === 'customers') {
            openDropdownId = 'customers-release-dropdown';
            customersFilters.releases = [];
            updateGenericReleaseDisplay('customers');
            updateCustomersClearButton();
            saveStateToStorage();
            renderCustomersView();
        }

        reopenDropdown();
    }

    /**
     * Update release filter display text for a dashboard
     */
    function updateGenericReleaseDisplay(dashboardId) {
        let displayId, selected;
        if (dashboardId === 'roadmap') {
            displayId = 'roadmap-release-display';
            selected = roadmapFilters.releases;
        } else if (dashboardId === 'customers') {
            displayId = 'customers-release-display';
            selected = customersFilters.releases;
        } else {
            return; // Releases dashboard uses updateReleaseHeaderDisplay()
        }

        const display = document.getElementById(displayId);
        if (!display) return;

        if (selected.length === 0) {
            display.textContent = 'All Releases';
        } else if (selected.length === 1) {
            display.textContent = selected[0];
        } else if (selected.length <= 2) {
            display.textContent = selected.join(', ');
        } else {
            display.textContent = `${selected.length} releases`;
        }
    }

    /**
     * Populate a release filter menu with the generic dropdown
     */
    function populateGenericReleaseFilter(dashboardId, items, selectedReleases) {
        const menuId = dashboardId === 'releases' ? 'release-filter-menu' : `${dashboardId}-release-menu`;
        const menu = document.getElementById(menuId);
        if (!menu) return;

        menu.innerHTML = buildReleaseFilterDropdown({
            dashboardId,
            items,
            selectedReleases
        });
    }

    /**
     * Sync release filter checkboxes with current state (after loading from localStorage)
     */
    function syncGenericReleaseFilter(dashboardId) {
        let selected;
        if (dashboardId === 'releases') {
            selected = selectedReleases;
        } else if (dashboardId === 'roadmap') {
            selected = roadmapFilters.releases;
        } else if (dashboardId === 'customers') {
            selected = customersFilters.releases;
        } else {
            return;
        }

        const optionsId = `${dashboardId}-release-options`;
        const checkboxes = document.querySelectorAll(`#${optionsId} input[type="checkbox"]`);
        checkboxes.forEach(cb => {
            cb.checked = selected.includes(cb.value);
        });

        if (dashboardId !== 'releases') {
            updateGenericReleaseDisplay(dashboardId);
        }
    }

    // ==================== END GENERIC RELEASE FILTER COMPONENT ====================

    // ==================== GENERIC SEARCH FILTER COMPONENT ====================
    // Shared Search filter used by Releases, Roadmap, and Customers dashboards
    // Searches both Title and ID fields

    /**
     * Apply search filter to items
     * @param {Array} items - Work items to filter
     * @param {string} searchTerm - Search term to match
     * @param {Object} options - Optional configuration
     * @param {boolean} options.supportPipeSeparated - Support pipe-separated ID lists (default: false)
     * @returns {Array} Filtered items
     */
    function applyGenericSearchFilter(items, searchTerm, options = {}) {
        if (!searchTerm) return items;

        const { supportPipeSeparated = false } = options;

        // Check for pipe-separated ID list (Roadmap feature)
        if (supportPipeSeparated && searchTerm.includes('|')) {
            const ids = searchTerm.split('|').map(id => id.trim());
            return items.filter(item => ids.includes(String(item.id)));
        }

        // Regular search - searches both Title and ID
        const searchLower = searchTerm.toLowerCase();
        return items.filter(item => {
            const titleMatch = (item.title || '').toLowerCase().includes(searchLower);
            const idMatch = String(item.id).includes(searchTerm);
            return titleMatch || idMatch;
        });
    }

    /**
     * Handle search input change for a dashboard
     * @param {string} dashboardId - 'releases', 'roadmap', or 'customers'
     */
    function handleGenericSearchChange(dashboardId) {
        const inputId = `${dashboardId}-search-input`;
        const searchInput = document.getElementById(inputId);
        const searchValue = searchInput ? searchInput.value : '';

        // Update the appropriate state variable
        if (dashboardId === 'releases') {
            releasesSearchFilter = searchValue;
            updateClearFiltersButton();
            saveStateToStorage();
            renderReleasesView();
        } else if (dashboardId === 'roadmap') {
            roadmapFilters.search = searchValue;
            renderRoadmapView();
            saveStateToStorage();
        } else if (dashboardId === 'customers') {
            customersFilters.search = searchValue;
            saveStateToStorage();
            renderCustomersView();
            updateCustomersClearButton();
        }
    }

    /**
     * Clear search filter for a dashboard
     * @param {string} dashboardId - 'releases', 'roadmap', or 'customers'
     */
    function clearGenericSearch(dashboardId) {
        const inputId = `${dashboardId}-search-input`;
        const searchInput = document.getElementById(inputId);
        if (searchInput) searchInput.value = '';

        // Update the appropriate state variable
        if (dashboardId === 'releases') {
            releasesSearchFilter = '';
        } else if (dashboardId === 'roadmap') {
            roadmapFilters.search = '';
        } else if (dashboardId === 'customers') {
            customersFilters.search = '';
        }
    }

    /**
     * Get current search value for a dashboard
     * @param {string} dashboardId - 'releases', 'roadmap', or 'customers'
     * @returns {string} Current search value
     */
    function getGenericSearchValue(dashboardId) {
        if (dashboardId === 'releases') {
            return releasesSearchFilter || '';
        } else if (dashboardId === 'roadmap') {
            return roadmapFilters.search || '';
        } else if (dashboardId === 'customers') {
            return customersFilters.search || '';
        }
        return '';
    }

    /**
     * Sync search input with current state (after loading from localStorage)
     * @param {string} dashboardId - 'releases', 'roadmap', or 'customers'
     */
    function syncGenericSearchFilter(dashboardId) {
        const inputId = `${dashboardId}-search-input`;
        const searchInput = document.getElementById(inputId);
        if (!searchInput) return;

        const searchValue = getGenericSearchValue(dashboardId);
        searchInput.value = searchValue;
    }

    /**
     * Check if search filter is active for a dashboard
     * @param {string} dashboardId - 'releases', 'roadmap', or 'customers'
     * @returns {boolean} True if search filter has a value
     */
    function hasGenericSearchFilter(dashboardId) {
        return getGenericSearchValue(dashboardId) !== '';
    }

    // ==================== END GENERIC SEARCH FILTER COMPONENT ====================

    // ==================== GENERIC CUSTOMER FILTER COMPONENT ====================
    // Shared Customer filter dropdown used by Releases, Roadmap, and Customers dashboards

    /**
     * Compute customer info from work items
     * @param {Array} items - Work items to analyze
     * @returns {Object} { customers: [...], customerInfo: {...}, noCustomerCount: number }
     */
    function computeCustomerInfo(items) {
        const customerInfo = {};
        let noCustomerCount = 0;

        items.forEach(item => {
            if (!item.customers) {
                noCustomerCount++;
                return;
            }
            // Customers field is semicolon-separated
            const itemCustomers = item.customers.split(';').map(c => c.trim()).filter(c => c);
            if (itemCustomers.length === 0) {
                noCustomerCount++;
                return;
            }
            itemCustomers.forEach(c => {
                if (!customerInfo[c]) {
                    customerInfo[c] = { count: 0, items: [] };
                }
                customerInfo[c].count++;
                customerInfo[c].items.push(item);
            });
        });

        // Sort customers alphabetically
        const customers = Object.keys(customerInfo).sort((a, b) =>
            a.toLowerCase().localeCompare(b.toLowerCase())
        );

        return { customers, customerInfo, noCustomerCount };
    }

    /**
     * Build Customer filter dropdown HTML (generic component)
     * @param {Object} config - Configuration object
     * @param {string} config.dashboardId - 'releases', 'roadmap', or 'customers'
     * @param {Array} config.items - Work items to build options from
     * @param {Array} config.selectedCustomers - Currently selected customers
     * @returns {string} HTML string for dropdown content
     */
    function buildCustomerFilterDropdown(config) {
        const { dashboardId, items, selectedCustomers } = config;
        const { customers, customerInfo, noCustomerCount } = computeCustomerInfo(items);

        const optionsId = `${dashboardId}-customer-options`;

        let html = `
            <div class="filter-dropdown-search">
                <input type="text" placeholder="Search customers..."
                       oninput="filterGenericCustomerOptions('${optionsId}', this.value)"
                       onclick="event.stopPropagation();">
            </div>
            <div class="filter-dropdown-options" id="${optionsId}">
        `;

        // "(No Customer)" option first
        if (noCustomerCount > 0) {
            const isChecked = selectedCustomers.includes('(No Customer)');
            html += `
                <label class="filter-dropdown-option" data-search-value="(no customer)" onclick="event.stopPropagation();">
                    <input type="checkbox" value="(No Customer)" ${isChecked ? 'checked' : ''}
                           onchange="handleGenericCustomerChange('${dashboardId}', '(No Customer)', this.checked, event)">
                    <span class="option-label">(No Customer)</span>
                    <span class="option-count">${noCustomerCount}</span>
                </label>
            `;
        }

        // Customer options sorted alphabetically
        customers.forEach(c => {
            const info = customerInfo[c];
            const isChecked = selectedCustomers.includes(c);
            const escapedCustomer = c.replace(/"/g, '&quot;');
            const escapedCustomerJs = c.replace(/'/g, "\\'").replace(/"/g, '&quot;');

            html += `
                <label class="filter-dropdown-option" data-search-value="${c.toLowerCase()}" onclick="event.stopPropagation();">
                    <input type="checkbox" value="${escapedCustomer}" ${isChecked ? 'checked' : ''}
                           onchange="handleGenericCustomerChange('${dashboardId}', '${escapedCustomerJs}', this.checked, event)">
                    <span class="option-label">${c}</span>
                    <span class="option-count">${info.count}</span>
                </label>
            `;
        });

        html += `</div>`;
        html += `
            <div class="filter-dropdown-actions">
                <button class="filter-btn-primary" onclick="selectAllGenericCustomer('${dashboardId}', event)">Select All</button>
                <button class="filter-btn-secondary" onclick="clearGenericCustomer('${dashboardId}', event)">Clear</button>
            </div>
        `;

        return html;
    }

    /**
     * Filter customer options by search text
     */
    function filterGenericCustomerOptions(optionsId, searchText) {
        const container = document.getElementById(optionsId);
        if (!container) return;

        const searchLower = searchText.toLowerCase();
        container.querySelectorAll('.filter-dropdown-option').forEach(opt => {
            const searchValue = opt.dataset.searchValue || '';
            opt.style.display = searchValue.includes(searchLower) ? '' : 'none';
        });
    }

    /**
     * Handle customer checkbox change
     */
    function handleGenericCustomerChange(dashboardId, customer, checked, event) {
        if (event) event.stopPropagation();

        // Save scroll position
        const optionsId = `${dashboardId}-customer-options`;
        const optionsContainer = document.getElementById(optionsId);
        const scrollTop = optionsContainer ? optionsContainer.scrollTop : 0;

        let selectedCustomers;
        let openDropdownId;

        if (dashboardId === 'releases') {
            openDropdownId = 'release-customer-header-dropdown';
            if (checked) {
                if (!releaseHeaderFilters.customer.includes(customer)) {
                    releaseHeaderFilters.customer.push(customer);
                }
            } else {
                releaseHeaderFilters.customer = releaseHeaderFilters.customer.filter(c => c !== customer);
            }
            selectedCustomers = releaseHeaderFilters.customer;
            updateGenericCustomerDisplay(dashboardId);
            updateClearFiltersButton();
            saveStateToStorage();
            renderReleasesView();
        } else if (dashboardId === 'roadmap') {
            openDropdownId = 'roadmap-customer-dropdown';
            if (checked) {
                if (!roadmapFilters.customers.includes(customer)) {
                    roadmapFilters.customers.push(customer);
                }
            } else {
                roadmapFilters.customers = roadmapFilters.customers.filter(c => c !== customer);
            }
            selectedCustomers = roadmapFilters.customers;
            updateGenericCustomerDisplay(dashboardId);
            renderRoadmapView();
            saveStateToStorage();
        } else if (dashboardId === 'customers') {
            openDropdownId = 'customers-customer-dropdown';
            if (checked) {
                if (!customersFilters.customers.includes(customer)) {
                    customersFilters.customers.push(customer);
                }
            } else {
                customersFilters.customers = customersFilters.customers.filter(c => c !== customer);
            }
            selectedCustomers = customersFilters.customers;
            updateGenericCustomerDisplay(dashboardId);
            saveStateToStorage();
            renderCustomersView();
            updateCustomersClearButton();
        }

        // Re-open dropdown and restore scroll position
        setTimeout(() => {
            const dropdown = document.getElementById(openDropdownId);
            if (dropdown) {
                dropdown.classList.add('open');
                const newOptionsContainer = document.getElementById(optionsId);
                if (newOptionsContainer) newOptionsContainer.scrollTop = scrollTop;
            }
        }, 10);
    }

    /**
     * Select all customers for a dashboard
     */
    function selectAllGenericCustomer(dashboardId, event) {
        if (event) event.stopPropagation();

        const optionsId = `${dashboardId}-customer-options`;
        const checkboxes = document.querySelectorAll(`#${optionsId} input[type="checkbox"]`);
        const allCustomers = [];
        checkboxes.forEach(cb => {
            cb.checked = true;
            allCustomers.push(cb.value);
        });

        if (dashboardId === 'releases') {
            releaseHeaderFilters.customer = allCustomers;
            updateGenericCustomerDisplay(dashboardId);
            updateClearFiltersButton();
            saveStateToStorage();
            renderReleasesView();
        } else if (dashboardId === 'roadmap') {
            roadmapFilters.customers = allCustomers;
            updateGenericCustomerDisplay(dashboardId);
            renderRoadmapView();
            saveStateToStorage();
        } else if (dashboardId === 'customers') {
            customersFilters.customers = allCustomers;
            updateGenericCustomerDisplay(dashboardId);
            saveStateToStorage();
            renderCustomersView();
            updateCustomersClearButton();
        }
    }

    /**
     * Clear customer selection for a dashboard
     */
    function clearGenericCustomer(dashboardId, event) {
        if (event) event.stopPropagation();

        const optionsId = `${dashboardId}-customer-options`;
        const checkboxes = document.querySelectorAll(`#${optionsId} input[type="checkbox"]`);
        checkboxes.forEach(cb => cb.checked = false);

        if (dashboardId === 'releases') {
            releaseHeaderFilters.customer = [];
            updateGenericCustomerDisplay(dashboardId);
            updateClearFiltersButton();
            saveStateToStorage();
            renderReleasesView();
        } else if (dashboardId === 'roadmap') {
            roadmapFilters.customers = [];
            updateGenericCustomerDisplay(dashboardId);
            renderRoadmapView();
            saveStateToStorage();
        } else if (dashboardId === 'customers') {
            customersFilters.customers = [];
            updateGenericCustomerDisplay(dashboardId);
            saveStateToStorage();
            renderCustomersView();
            updateCustomersClearButton();
        }
    }

    /**
     * Update customer filter display text
     */
    function updateGenericCustomerDisplay(dashboardId) {
        let displayId, selectedCustomers;

        if (dashboardId === 'releases') {
            displayId = 'release-customer-display';
            selectedCustomers = releaseHeaderFilters.customer;
        } else if (dashboardId === 'roadmap') {
            displayId = 'roadmap-customer-display';
            selectedCustomers = roadmapFilters.customers;
        } else if (dashboardId === 'customers') {
            displayId = 'customers-customer-display';
            selectedCustomers = customersFilters.customers;
        } else {
            return;
        }

        const display = document.getElementById(displayId);
        if (!display) return;

        if (selectedCustomers.length === 0) {
            display.textContent = 'All Customers';
        } else if (selectedCustomers.length === 1) {
            display.textContent = selectedCustomers[0];
        } else {
            display.textContent = `${selectedCustomers.length} selected`;
        }
    }

    /**
     * Sync customer filter checkboxes with current state (after loading from localStorage)
     */
    function syncGenericCustomerFilter(dashboardId) {
        let selectedCustomers;

        if (dashboardId === 'releases') {
            selectedCustomers = releaseHeaderFilters.customer;
        } else if (dashboardId === 'roadmap') {
            selectedCustomers = roadmapFilters.customers;
        } else if (dashboardId === 'customers') {
            selectedCustomers = customersFilters.customers;
        } else {
            return;
        }

        const optionsId = `${dashboardId}-customer-options`;
        const checkboxes = document.querySelectorAll(`#${optionsId} input[type="checkbox"]`);
        checkboxes.forEach(cb => {
            cb.checked = selectedCustomers.includes(cb.value);
        });

        updateGenericCustomerDisplay(dashboardId);
    }

    // ==================== END GENERIC CUSTOMER FILTER COMPONENT ====================

    // ==================== GENERIC PRIORITY FILTER COMPONENT ====================
    // Shared Priority filter dropdown used by Releases, Roadmap, and Customers dashboards

    /**
     * Compute priority info from work items
     * @param {Array} items - Work items to analyze
     * @returns {Object} { priorities: [...], priorityInfo: {...}, noPriorityCount: number }
     */
    function computePriorityInfo(items) {
        const priorityInfo = {};
        let noPriorityCount = 0;

        items.forEach(item => {
            if (!item.priority) {
                noPriorityCount++;
                return;
            }
            const priority = 'P' + item.priority;
            if (!priorityInfo[priority]) {
                priorityInfo[priority] = { count: 0, items: [], numericValue: item.priority };
            }
            priorityInfo[priority].count++;
            priorityInfo[priority].items.push(item);
        });

        // Sort priorities numerically (P1, P2, P3, P4)
        const priorities = Object.keys(priorityInfo).sort((a, b) => {
            return priorityInfo[a].numericValue - priorityInfo[b].numericValue;
        });

        return { priorities, priorityInfo, noPriorityCount };
    }

    /**
     * Build Priority filter dropdown HTML (generic component)
     * @param {Object} config - Configuration object
     * @param {string} config.dashboardId - 'releases', 'roadmap', or 'customers'
     * @param {Array} config.items - Work items to build options from
     * @param {Array} config.selectedPriorities - Currently selected priorities
     * @returns {string} HTML string for dropdown content
     */
    function buildPriorityFilterDropdown(config) {
        const { dashboardId, items, selectedPriorities } = config;
        const { priorities, priorityInfo, noPriorityCount } = computePriorityInfo(items);

        const optionsId = `${dashboardId}-priority-options`;

        let html = `
            <div class="filter-dropdown-search">
                <input type="text" placeholder="Search priorities..."
                       oninput="filterGenericPriorityOptions('${optionsId}', this.value)"
                       onclick="event.stopPropagation();">
            </div>
            <div class="filter-dropdown-options" id="${optionsId}">
        `;

        // Priority options sorted numerically (P1 first)
        priorities.forEach(p => {
            const info = priorityInfo[p];
            const isChecked = selectedPriorities.includes(p);

            html += `
                <label class="filter-dropdown-option" data-search-value="${p.toLowerCase()}" onclick="event.stopPropagation();">
                    <input type="checkbox" value="${p}" ${isChecked ? 'checked' : ''}
                           onchange="handleGenericPriorityChange('${dashboardId}', '${p}', this.checked, event)">
                    <span class="option-label">${p}</span>
                    <span class="option-count">${info.count}</span>
                </label>
            `;
        });

        // "(No Priority)" option last
        if (noPriorityCount > 0) {
            const isChecked = selectedPriorities.includes('(No Priority)');
            html += `
                <label class="filter-dropdown-option" data-search-value="(no priority)" onclick="event.stopPropagation();">
                    <input type="checkbox" value="(No Priority)" ${isChecked ? 'checked' : ''}
                           onchange="handleGenericPriorityChange('${dashboardId}', '(No Priority)', this.checked, event)">
                    <span class="option-label">(No Priority)</span>
                    <span class="option-count">${noPriorityCount}</span>
                </label>
            `;
        }

        html += `</div>`;
        html += `
            <div class="filter-dropdown-actions">
                <button class="filter-btn-primary" onclick="selectAllGenericPriority('${dashboardId}', event)">Select All</button>
                <button class="filter-btn-secondary" onclick="clearGenericPriority('${dashboardId}', event)">Clear</button>
            </div>
        `;

        return html;
    }

    /**
     * Filter priority options by search text
     */
    function filterGenericPriorityOptions(optionsId, searchText) {
        const container = document.getElementById(optionsId);
        if (!container) return;

        const searchLower = searchText.toLowerCase();
        container.querySelectorAll('.filter-dropdown-option').forEach(opt => {
            const searchValue = opt.dataset.searchValue || '';
            opt.style.display = searchValue.includes(searchLower) ? '' : 'none';
        });
    }

    /**
     * Handle priority checkbox change
     */
    function handleGenericPriorityChange(dashboardId, priority, checked, event) {
        if (event) event.stopPropagation();

        // Save scroll position
        const optionsId = `${dashboardId}-priority-options`;
        const optionsContainer = document.getElementById(optionsId);
        const scrollTop = optionsContainer ? optionsContainer.scrollTop : 0;

        let openDropdownId;

        if (dashboardId === 'releases') {
            openDropdownId = 'release-priority-header-dropdown';
            if (checked) {
                if (!releaseHeaderFilters.priority.includes(priority)) {
                    releaseHeaderFilters.priority.push(priority);
                }
            } else {
                releaseHeaderFilters.priority = releaseHeaderFilters.priority.filter(p => p !== priority);
            }
            updateGenericPriorityDisplay(dashboardId);
            updateClearFiltersButton();
            saveStateToStorage();
            renderReleasesView();
        } else if (dashboardId === 'roadmap') {
            openDropdownId = 'roadmap-priority-dropdown';
            if (checked) {
                if (!roadmapFilters.priorities.includes(priority)) {
                    roadmapFilters.priorities.push(priority);
                }
            } else {
                roadmapFilters.priorities = roadmapFilters.priorities.filter(p => p !== priority);
            }
            updateGenericPriorityDisplay(dashboardId);
            renderRoadmapView();
            saveStateToStorage();
        } else if (dashboardId === 'customers') {
            openDropdownId = 'customers-priority-dropdown';
            if (checked) {
                if (!customersFilters.priorities.includes(priority)) {
                    customersFilters.priorities.push(priority);
                }
            } else {
                customersFilters.priorities = customersFilters.priorities.filter(p => p !== priority);
            }
            updateGenericPriorityDisplay(dashboardId);
            saveStateToStorage();
            renderCustomersView();
            updateCustomersClearButton();
        }

        // Re-open dropdown and restore scroll position
        setTimeout(() => {
            const dropdown = document.getElementById(openDropdownId);
            if (dropdown) {
                dropdown.classList.add('open');
                const newOptionsContainer = document.getElementById(optionsId);
                if (newOptionsContainer) newOptionsContainer.scrollTop = scrollTop;
            }
        }, 10);
    }

    /**
     * Select all priorities for a dashboard
     */
    function selectAllGenericPriority(dashboardId, event) {
        if (event) event.stopPropagation();

        const optionsId = `${dashboardId}-priority-options`;
        const checkboxes = document.querySelectorAll(`#${optionsId} input[type="checkbox"]`);
        const allPriorities = [];
        checkboxes.forEach(cb => {
            cb.checked = true;
            allPriorities.push(cb.value);
        });

        if (dashboardId === 'releases') {
            releaseHeaderFilters.priority = allPriorities;
            updateGenericPriorityDisplay(dashboardId);
            updateClearFiltersButton();
            saveStateToStorage();
            renderReleasesView();
        } else if (dashboardId === 'roadmap') {
            roadmapFilters.priorities = allPriorities;
            updateGenericPriorityDisplay(dashboardId);
            renderRoadmapView();
            saveStateToStorage();
        } else if (dashboardId === 'customers') {
            customersFilters.priorities = allPriorities;
            updateGenericPriorityDisplay(dashboardId);
            saveStateToStorage();
            renderCustomersView();
            updateCustomersClearButton();
        }
    }

    /**
     * Clear priority selection for a dashboard
     */
    function clearGenericPriority(dashboardId, event) {
        if (event) event.stopPropagation();

        const optionsId = `${dashboardId}-priority-options`;
        const checkboxes = document.querySelectorAll(`#${optionsId} input[type="checkbox"]`);
        checkboxes.forEach(cb => cb.checked = false);

        if (dashboardId === 'releases') {
            releaseHeaderFilters.priority = [];
            updateGenericPriorityDisplay(dashboardId);
            updateClearFiltersButton();
            saveStateToStorage();
            renderReleasesView();
        } else if (dashboardId === 'roadmap') {
            roadmapFilters.priorities = [];
            updateGenericPriorityDisplay(dashboardId);
            renderRoadmapView();
            saveStateToStorage();
        } else if (dashboardId === 'customers') {
            customersFilters.priorities = [];
            updateGenericPriorityDisplay(dashboardId);
            saveStateToStorage();
            renderCustomersView();
            updateCustomersClearButton();
        }
    }

    /**
     * Update priority filter display text
     */
    function updateGenericPriorityDisplay(dashboardId) {
        let displayId, selectedPriorities;

        if (dashboardId === 'releases') {
            displayId = 'release-priority-display';
            selectedPriorities = releaseHeaderFilters.priority;
        } else if (dashboardId === 'roadmap') {
            displayId = 'roadmap-priority-display';
            selectedPriorities = roadmapFilters.priorities;
        } else if (dashboardId === 'customers') {
            displayId = 'customers-priority-display';
            selectedPriorities = customersFilters.priorities;
        } else {
            return;
        }

        const display = document.getElementById(displayId);
        if (!display) return;

        if (selectedPriorities.length === 0) {
            display.textContent = 'All Priorities';
        } else if (selectedPriorities.length === 1) {
            display.textContent = selectedPriorities[0];
        } else {
            display.textContent = `${selectedPriorities.length} selected`;
        }
    }

    /**
     * Sync priority filter checkboxes with current state (after loading from localStorage)
     */
    function syncGenericPriorityFilter(dashboardId) {
        let selectedPriorities;

        if (dashboardId === 'releases') {
            selectedPriorities = releaseHeaderFilters.priority;
        } else if (dashboardId === 'roadmap') {
            selectedPriorities = roadmapFilters.priorities;
        } else if (dashboardId === 'customers') {
            selectedPriorities = customersFilters.priorities;
        } else {
            return;
        }

        const optionsId = `${dashboardId}-priority-options`;
        const checkboxes = document.querySelectorAll(`#${optionsId} input[type="checkbox"]`);
        checkboxes.forEach(cb => {
            cb.checked = selectedPriorities.includes(cb.value);
        });

        updateGenericPriorityDisplay(dashboardId);
    }

    // ==================== END GENERIC PRIORITY FILTER COMPONENT ====================

    // ==================== GENERIC STATE FILTER COMPONENT ====================
    // Shared State filter used by Releases, Roadmap, and Customers dashboards
    // Features: search box, semantic state ordering, item counts, cross-filter support

    // Standard state order (semantic ordering for work items)
    const STATE_ORDER = ['New', 'Triaged', 'To Do', 'In Progress', 'Ready For Review', 'Done', 'Closed', 'Removed'];

    /**
     * Compute state information from a list of items
     * @param {Array} items - Array of work items
     * @returns {Object} { states: [], stateInfo: {}, noStateCount: number }
     */
    function computeStateInfo(items) {
        const stateInfo = {};
        let noStateCount = 0;

        items.forEach(item => {
            if (!item.state) {
                noStateCount++;
                return;
            }
            const state = item.state;
            if (!stateInfo[state]) {
                stateInfo[state] = { count: 0, items: [] };
            }
            stateInfo[state].count++;
        });

        // Sort states using semantic order
        const states = Object.keys(stateInfo).sort((a, b) => {
            const aIdx = STATE_ORDER.indexOf(a);
            const bIdx = STATE_ORDER.indexOf(b);
            if (aIdx === -1 && bIdx === -1) return a.localeCompare(b);
            if (aIdx === -1) return 1;
            if (bIdx === -1) return -1;
            return aIdx - bIdx;
        });

        return { states, stateInfo, noStateCount };
    }

    /**
     * Build State filter dropdown HTML
     * @param {Object} config - { dashboardId, items, selectedStates }
     * @returns {string} HTML string for dropdown content
     */
    function buildStateFilterDropdown(config) {
        const { dashboardId, items, selectedStates } = config;
        const { states, stateInfo, noStateCount } = computeStateInfo(items);

        if (states.length === 0 && noStateCount === 0) {
            return '<div class="filter-dropdown-empty">No states available</div>';
        }

        const optionsId = `${dashboardId}-state-options`;

        let html = `
            <div class="filter-dropdown-search">
                <input type="text" placeholder="Search states..."
                       oninput="filterGenericStateOptions('${optionsId}', this.value)"
                       onclick="event.stopPropagation();">
            </div>
            <div class="filter-dropdown-options" id="${optionsId}">
        `;

        // Add state options in semantic order
        states.forEach(state => {
            const isChecked = selectedStates.includes(state);
            const count = stateInfo[state].count;
            html += `
                <label class="filter-dropdown-option" data-search-value="${state.toLowerCase()}" onclick="event.stopPropagation();">
                    <input type="checkbox" value="${state}" ${isChecked ? 'checked' : ''}
                           onchange="handleGenericStateChange('${dashboardId}', '${state}', this.checked, event)">
                    <span class="option-label">${state}</span>
                    <span class="option-count">${count}</span>
                </label>
            `;
        });

        // Add "(No State)" option at the end if there are items without state
        if (noStateCount > 0) {
            const isChecked = selectedStates.includes('(No State)');
            html += `
                <label class="filter-dropdown-option" data-search-value="(no state)" onclick="event.stopPropagation();">
                    <input type="checkbox" value="(No State)" ${isChecked ? 'checked' : ''}
                           onchange="handleGenericStateChange('${dashboardId}', '(No State)', this.checked, event)">
                    <span class="option-label">(No State)</span>
                    <span class="option-count">${noStateCount}</span>
                </label>
            `;
        }

        html += `</div>`;

        // Add Select All / Clear buttons
        html += `
            <div class="filter-dropdown-actions">
                <button class="filter-btn-primary" onclick="selectAllGenericState('${dashboardId}', event)">Select All</button>
                <button class="filter-btn-secondary" onclick="clearGenericState('${dashboardId}', event)">Clear</button>
            </div>
        `;

        return html;
    }

    /**
     * Filter state options by search text
     */
    function filterGenericStateOptions(optionsId, searchText) {
        const options = document.querySelectorAll(`#${optionsId} .filter-dropdown-option`);
        const search = searchText.toLowerCase();
        options.forEach(opt => {
            const searchValue = opt.dataset.searchValue || '';
            opt.style.display = searchValue.includes(search) ? '' : 'none';
        });
    }

    /**
     * Handle state filter checkbox change
     */
    function handleGenericStateChange(dashboardId, state, checked, event) {
        event.stopPropagation();

        let openDropdownId, selectedStates;

        if (dashboardId === 'releases') {
            openDropdownId = 'release-state-header-dropdown';
            if (checked) {
                if (!releaseHeaderFilters.state.includes(state)) releaseHeaderFilters.state.push(state);
            } else {
                releaseHeaderFilters.state = releaseHeaderFilters.state.filter(s => s !== state);
            }
            selectedStates = releaseHeaderFilters.state;
            saveStateToStorage();
            renderReleasesView();
        } else if (dashboardId === 'roadmap') {
            openDropdownId = 'roadmap-state-dropdown';
            if (checked) {
                if (!roadmapFilters.states.includes(state)) roadmapFilters.states.push(state);
            } else {
                roadmapFilters.states = roadmapFilters.states.filter(s => s !== state);
            }
            selectedStates = roadmapFilters.states;
            saveStateToStorage();
            renderRoadmapView();
        } else if (dashboardId === 'customers') {
            openDropdownId = 'customers-state-dropdown';
            if (checked) {
                if (!customersFilters.states.includes(state)) customersFilters.states.push(state);
            } else {
                customersFilters.states = customersFilters.states.filter(s => s !== state);
            }
            selectedStates = customersFilters.states;
            saveStateToStorage();
            renderCustomersView();
            populateCustomersFilterDropdowns();
            updateCustomersClearButton();
        } else {
            return;
        }

        // Preserve scroll position and keep dropdown open
        const optionsContainer = document.getElementById(`${dashboardId}-state-options`);
        const scrollTop = optionsContainer ? optionsContainer.scrollTop : 0;

        // Restore scroll and ensure dropdown stays open
        setTimeout(() => {
            const newOptionsContainer = document.getElementById(`${dashboardId}-state-options`);
            if (newOptionsContainer) newOptionsContainer.scrollTop = scrollTop;

            const dropdown = document.getElementById(openDropdownId);
            if (dropdown) dropdown.classList.add('open');
        }, 0);
    }

    /**
     * Select all states
     */
    function selectAllGenericState(dashboardId, event) {
        event.stopPropagation();

        const optionsId = `${dashboardId}-state-options`;
        const checkboxes = document.querySelectorAll(`#${optionsId} input[type="checkbox"]`);
        const allStates = Array.from(checkboxes).map(cb => cb.value);

        checkboxes.forEach(cb => cb.checked = true);

        if (dashboardId === 'releases') {
            releaseHeaderFilters.state = allStates;
            saveStateToStorage();
            renderReleasesView();
        } else if (dashboardId === 'roadmap') {
            roadmapFilters.states = allStates;
            saveStateToStorage();
            renderRoadmapView();
        } else if (dashboardId === 'customers') {
            customersFilters.states = allStates;
            saveStateToStorage();
            renderCustomersView();
            populateCustomersFilterDropdowns();
            updateCustomersClearButton();
        }

        updateGenericStateDisplay(dashboardId);
    }

    /**
     * Clear state filter
     */
    function clearGenericState(dashboardId, event) {
        event.stopPropagation();

        const optionsId = `${dashboardId}-state-options`;
        const checkboxes = document.querySelectorAll(`#${optionsId} input[type="checkbox"]`);
        checkboxes.forEach(cb => cb.checked = false);

        if (dashboardId === 'releases') {
            releaseHeaderFilters.state = [];
            saveStateToStorage();
            renderReleasesView();
        } else if (dashboardId === 'roadmap') {
            roadmapFilters.states = [];
            saveStateToStorage();
            renderRoadmapView();
        } else if (dashboardId === 'customers') {
            customersFilters.states = [];
            saveStateToStorage();
            renderCustomersView();
            populateCustomersFilterDropdowns();
            updateCustomersClearButton();
        }

        updateGenericStateDisplay(dashboardId);
    }

    /**
     * Update state filter display text
     */
    function updateGenericStateDisplay(dashboardId) {
        let displayId, selectedStates;

        if (dashboardId === 'releases') {
            displayId = 'release-state-display';
            selectedStates = releaseHeaderFilters.state;
        } else if (dashboardId === 'roadmap') {
            displayId = 'roadmap-state-display';
            selectedStates = roadmapFilters.states;
        } else if (dashboardId === 'customers') {
            displayId = 'customers-state-display';
            selectedStates = customersFilters.states;
        } else {
            return;
        }

        const display = document.getElementById(displayId);
        if (!display) return;

        if (selectedStates.length === 0) {
            display.textContent = 'All States';
        } else if (selectedStates.length === 1) {
            display.textContent = selectedStates[0];
        } else {
            display.textContent = `${selectedStates.length} selected`;
        }
    }

    /**
     * Sync state filter checkboxes with current state (after loading from localStorage)
     */
    function syncGenericStateFilter(dashboardId) {
        let selectedStates;

        if (dashboardId === 'releases') {
            selectedStates = releaseHeaderFilters.state;
        } else if (dashboardId === 'roadmap') {
            selectedStates = roadmapFilters.states;
        } else if (dashboardId === 'customers') {
            selectedStates = customersFilters.states;
        } else {
            return;
        }

        const optionsId = `${dashboardId}-state-options`;
        const checkboxes = document.querySelectorAll(`#${optionsId} input[type="checkbox"]`);
        checkboxes.forEach(cb => {
            cb.checked = selectedStates.includes(cb.value);
        });

        updateGenericStateDisplay(dashboardId);
    }

    // ==================== END GENERIC STATE FILTER COMPONENT ====================

    // ==================== GENERIC TEAM FILTER COMPONENT ====================
    // Shared Team filter used by Releases, Roadmap, and Customers dashboards
    // Teams are sorted alphabetically with "(No Team)" at the end

    /**
     * Compute team info from items
     * @param {Array} items - Work items to analyze
     * @param {Object} options - Options: { useAreaPath: true } for Roadmap (extract from delivery slices)
     * @returns {Object} { teams: [...], teamInfo: {...}, noTeamCount }
     */
    function computeTeamInfo(items, options = {}) {
        const teamInfo = {};
        let noTeamCount = 0;

        items.forEach(item => {
            let team = item.team;

            // For items without team field, check if we should use areaPath
            if (!team && options.useAreaPath && item.areaPath) {
                team = getLastPathSegment(item.areaPath);
            }

            if (!team) {
                noTeamCount++;
                return;
            }

            if (!teamInfo[team]) {
                teamInfo[team] = { count: 0 };
            }
            teamInfo[team].count++;
        });

        // Sort teams alphabetically (case-insensitive)
        const teams = Object.keys(teamInfo).sort((a, b) =>
            a.toLowerCase().localeCompare(b.toLowerCase())
        );

        return { teams, teamInfo, noTeamCount };
    }

    /**
     * Build Team filter dropdown HTML
     * @param {Object} config - { dashboardId, items, selectedTeams, options }
     * @returns {string} HTML string for dropdown content
     */
    function buildTeamFilterDropdown(config) {
        const { dashboardId, items, selectedTeams, options = {} } = config;
        const { teams, teamInfo, noTeamCount } = computeTeamInfo(items, options);
        const optionsId = `${dashboardId}-team-options`;

        let html = `
            <div class="filter-dropdown-search">
                <input type="text" placeholder="Search teams..."
                       oninput="filterGenericTeamOptions('${optionsId}', this.value)"
                       onclick="event.stopPropagation();">
            </div>
            <div class="filter-dropdown-options" id="${optionsId}">
        `;

        // Add regular teams first
        teams.forEach(team => {
            const isChecked = selectedTeams.includes(team);
            const count = teamInfo[team].count;
            html += `
                <label class="filter-dropdown-option" data-search-value="${team.toLowerCase()}" onclick="event.stopPropagation();">
                    <input type="checkbox" value="${team}" ${isChecked ? 'checked' : ''}
                           onchange="handleGenericTeamChange('${dashboardId}', '${team.replace(/'/g, "\\'")}', this.checked, event)">
                    <span class="option-label">${team}</span>
                    <span class="option-count">(${count})</span>
                </label>
            `;
        });

        // Add "(No Team)" option at the end if there are items without team
        if (noTeamCount > 0) {
            const isChecked = selectedTeams.includes('(No Team)');
            html += `
                <label class="filter-dropdown-option" data-search-value="(no team)" onclick="event.stopPropagation();">
                    <input type="checkbox" value="(No Team)" ${isChecked ? 'checked' : ''}
                           onchange="handleGenericTeamChange('${dashboardId}', '(No Team)', this.checked, event)">
                    <span class="option-label">(No Team)</span>
                    <span class="option-count">(${noTeamCount})</span>
                </label>
            `;
        }

        html += `
            </div>
            <div class="filter-dropdown-actions">
                <button class="filter-btn-primary" onclick="selectAllGenericTeam('${dashboardId}', event)">Select All</button>
                <button class="filter-btn-secondary" onclick="clearGenericTeam('${dashboardId}', event)">Clear</button>
            </div>
        `;

        return html;
    }

    /**
     * Filter team options by search text
     */
    function filterGenericTeamOptions(optionsId, searchText) {
        const container = document.getElementById(optionsId);
        if (!container) return;

        const search = searchText.toLowerCase();
        container.querySelectorAll('.filter-dropdown-option').forEach(option => {
            const value = option.dataset.searchValue || '';
            option.style.display = value.includes(search) ? '' : 'none';
        });
    }

    /**
     * Handle team checkbox change - routes to correct dashboard
     */
    function handleGenericTeamChange(dashboardId, team, checked, event) {
        if (event) event.stopPropagation();

        // Save scroll position
        const optionsContainer = document.getElementById(`${dashboardId}-team-options`);
        const scrollTop = optionsContainer ? optionsContainer.scrollTop : 0;

        let openDropdownId;

        if (dashboardId === 'releases') {
            openDropdownId = 'release-team-header-dropdown';
            if (checked) {
                if (!releaseHeaderFilters.team.includes(team)) {
                    releaseHeaderFilters.team.push(team);
                }
            } else {
                releaseHeaderFilters.team = releaseHeaderFilters.team.filter(t => t !== team);
            }
            saveStateToStorage();
            renderReleasesView();
        } else if (dashboardId === 'roadmap') {
            openDropdownId = 'roadmap-team-dropdown';
            if (checked) {
                if (!roadmapFilters.teams.includes(team)) {
                    roadmapFilters.teams.push(team);
                }
            } else {
                roadmapFilters.teams = roadmapFilters.teams.filter(t => t !== team);
            }
            saveStateToStorage();
            renderRoadmapView();
        } else if (dashboardId === 'customers') {
            openDropdownId = 'customers-team-dropdown';
            if (checked) {
                if (!customersFilters.teams.includes(team)) {
                    customersFilters.teams.push(team);
                }
            } else {
                customersFilters.teams = customersFilters.teams.filter(t => t !== team);
            }
            saveStateToStorage();
            renderCustomersView();
        }

        // Keep dropdown open and restore scroll position
        if (openDropdownId) {
            setTimeout(() => {
                const dropdown = document.getElementById(openDropdownId);
                if (dropdown) dropdown.classList.add('open');
                const newOptionsContainer = document.getElementById(`${dashboardId}-team-options`);
                if (newOptionsContainer) newOptionsContainer.scrollTop = scrollTop;
            }, 0);
        }
    }

    /**
     * Select all teams
     */
    function selectAllGenericTeam(dashboardId, event) {
        if (event) event.stopPropagation();

        const optionsContainer = document.getElementById(`${dashboardId}-team-options`);
        const scrollTop = optionsContainer ? optionsContainer.scrollTop : 0;

        const checkboxes = document.querySelectorAll(`#${dashboardId}-team-options input[type="checkbox"]`);
        const allTeams = [];
        checkboxes.forEach(cb => {
            cb.checked = true;
            allTeams.push(cb.value);
        });

        let openDropdownId;

        if (dashboardId === 'releases') {
            openDropdownId = 'release-team-header-dropdown';
            releaseHeaderFilters.team = allTeams;
            saveStateToStorage();
            renderReleasesView();
        } else if (dashboardId === 'roadmap') {
            openDropdownId = 'roadmap-team-dropdown';
            roadmapFilters.teams = allTeams;
            saveStateToStorage();
            renderRoadmapView();
        } else if (dashboardId === 'customers') {
            openDropdownId = 'customers-team-dropdown';
            customersFilters.teams = allTeams;
            saveStateToStorage();
            renderCustomersView();
        }

        if (openDropdownId) {
            setTimeout(() => {
                const dropdown = document.getElementById(openDropdownId);
                if (dropdown) dropdown.classList.add('open');
                const newOptionsContainer = document.getElementById(`${dashboardId}-team-options`);
                if (newOptionsContainer) newOptionsContainer.scrollTop = scrollTop;
            }, 0);
        }
    }

    /**
     * Clear all teams
     */
    function clearGenericTeam(dashboardId, event) {
        if (event) event.stopPropagation();

        const optionsContainer = document.getElementById(`${dashboardId}-team-options`);
        const scrollTop = optionsContainer ? optionsContainer.scrollTop : 0;

        const checkboxes = document.querySelectorAll(`#${dashboardId}-team-options input[type="checkbox"]`);
        checkboxes.forEach(cb => cb.checked = false);

        let openDropdownId;

        if (dashboardId === 'releases') {
            openDropdownId = 'release-team-header-dropdown';
            releaseHeaderFilters.team = [];
            saveStateToStorage();
            renderReleasesView();
        } else if (dashboardId === 'roadmap') {
            openDropdownId = 'roadmap-team-dropdown';
            roadmapFilters.teams = [];
            saveStateToStorage();
            renderRoadmapView();
        } else if (dashboardId === 'customers') {
            openDropdownId = 'customers-team-dropdown';
            customersFilters.teams = [];
            saveStateToStorage();
            renderCustomersView();
        }

        if (openDropdownId) {
            setTimeout(() => {
                const dropdown = document.getElementById(openDropdownId);
                if (dropdown) dropdown.classList.add('open');
                const newOptionsContainer = document.getElementById(`${dashboardId}-team-options`);
                if (newOptionsContainer) newOptionsContainer.scrollTop = scrollTop;
            }, 0);
        }
    }

    /**
     * Update team filter display text
     */
    function updateGenericTeamDisplay(dashboardId) {
        let displayId, selectedTeams;

        if (dashboardId === 'releases') {
            displayId = 'release-team-header-display';
            selectedTeams = releaseHeaderFilters.team;
        } else if (dashboardId === 'roadmap') {
            displayId = 'roadmap-team-display';
            selectedTeams = roadmapFilters.teams;
        } else if (dashboardId === 'customers') {
            displayId = 'customers-team-display';
            selectedTeams = customersFilters.teams;
        } else {
            return;
        }

        const display = document.getElementById(displayId);
        if (!display) return;

        if (selectedTeams.length === 0) {
            display.textContent = 'All Teams';
        } else if (selectedTeams.length === 1) {
            display.textContent = selectedTeams[0];
        } else {
            display.textContent = `${selectedTeams.length} selected`;
        }
    }

    /**
     * Sync team filter checkboxes with current state (after loading from localStorage)
     */
    function syncGenericTeamFilter(dashboardId) {
        let selectedTeams;

        if (dashboardId === 'releases') {
            selectedTeams = releaseHeaderFilters.team;
        } else if (dashboardId === 'roadmap') {
            selectedTeams = roadmapFilters.teams;
        } else if (dashboardId === 'customers') {
            selectedTeams = customersFilters.teams;
        } else {
            return;
        }

        const optionsId = `${dashboardId}-team-options`;
        const checkboxes = document.querySelectorAll(`#${optionsId} input[type="checkbox"]`);
        checkboxes.forEach(cb => {
            cb.checked = selectedTeams.includes(cb.value);
        });

        updateGenericTeamDisplay(dashboardId);
    }

    /**
     * Helper function to get last segment of a path (e.g., "eSHARE\\Frontend" -> "Frontend")
     * Note: This is also defined in part3.html for Roadmap - this version is for generic use
     */
    function getLastPathSegment(path) {
        if (!path) return '';
        const parts = path.split('\\');
        return parts[parts.length - 1] || '';
    }

    // ==================== END GENERIC TEAM FILTER COMPONENT ====================

    // Utility functions
    function getStateClass(state) {
        const s = (state || '').toLowerCase().replace(/\s+/g, '');
        if (s === 'done' || s === 'closed') return 'state-done';
        if (s === 'inprogress') return 'state-inprogress';
        if (s === 'new' || s === 'todo') return 'state-new';
        if (s === 'triaged') return 'state-triaged';
        if (s === 'removed') return 'state-removed';
        return 'state-new';
    }
    
    function countBy(items, field) {
        const counts = {};
        items.forEach(item => {
            const val = item[field] || '(Not Set)';
            counts[val] = (counts[val] || 0) + 1;
        });
        return counts;
    }
    
    function sumBy(items, groupField, sumField) {
        const sums = {};
        items.forEach(item => {
            const key = item[groupField] || '(Not Set)';
            const val = item[sumField] || 0;
            sums[key] = (sums[key] || 0) + val;
        });
        return sums;
    }
    
    function sortObjectByValue(obj, ascending = false) {
        const sorted = Object.entries(obj).sort((a, b) => ascending ? a[1] - b[1] : b[1] - a[1]);
        return Object.fromEntries(sorted);
    }
    
    function filterItems(items, filters) {
        return items.filter(item => {
            for (const [field, value] of Object.entries(filters)) {
                if (Array.isArray(value)) {
                    // Multi-select filter
                    const itemVal = item[field] || '(Not Set)';
                    if (!value.includes(itemVal)) return false;
                } else {
                    const itemVal = item[field] || '(Not Set)';
                    if (itemVal !== value) return false;
                }
            }
            return true;
        });
    }
    
    function destroyChart(chartId) {
        if (activeCharts[chartId]) {
            activeCharts[chartId].destroy();
            delete activeCharts[chartId];
        }
    }
    
    function createChart(canvasId, type, data, options = {}) {
        destroyChart(canvasId);
        const ctx = document.getElementById(canvasId);
        if (!ctx) return null;
        
        const defaultOptions = {
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
                legend: {
                    display: type === 'doughnut' || type === 'pie',
                    position: 'right',
                    labels: { color: '#94a3b8', font: { size: 11 } }
                },
                datalabels: {
                    display: false  // Disable datalabels by default
                }
            }
        };
        
        activeCharts[canvasId] = new Chart(ctx, {
            type,
            data,
            options: { ...defaultOptions, ...options }
        });
        
        return activeCharts[canvasId];
    }
    
    // Date utility functions
    function parseDate(dateStr) {
        if (!dateStr) return null;
        return new Date(dateStr);
    }
    
    function getCompletionDate(item) {
        if (item.state === 'Done' && item.closedDate) {
            return parseDate(item.closedDate);
        } else if (item.state === 'Closed' && item.stateChangeDate) {
            return parseDate(item.stateChangeDate);
        }
        return null;
    }
    
    function isInPeriod(date, period) {
        if (!date) return false;
        const now = new Date();
        const d = new Date(date);
        
        switch(period) {
            case 'week':
                const startOfWeek = new Date(now);
                startOfWeek.setDate(now.getDate() - now.getDay());
                startOfWeek.setHours(0, 0, 0, 0);
                return d >= startOfWeek;
            case 'month':
                return d.getMonth() === now.getMonth() && d.getFullYear() === now.getFullYear();
            case 'lastmonth':
                const lastMonth = new Date(now.getFullYear(), now.getMonth() - 1, 1);
                return d.getMonth() === lastMonth.getMonth() && d.getFullYear() === lastMonth.getFullYear();
            case 'quarter':
                const currentQuarter = Math.floor(now.getMonth() / 3);
                const dateQuarter = Math.floor(d.getMonth() / 3);
                return dateQuarter === currentQuarter && d.getFullYear() === now.getFullYear();
            case 'all':
            default:
                return true;
        }
    }
    
    function getWeekNumber(date) {
        const d = new Date(date);
        d.setHours(0, 0, 0, 0);
        d.setDate(d.getDate() + 4 - (d.getDay() || 7));
        const yearStart = new Date(d.getFullYear(), 0, 1);
        return Math.ceil((((d - yearStart) / 86400000) + 1) / 7);
    }
    
    function formatDate(dateStr) {
        if (!dateStr) return '';
        const d = new Date(dateStr);
        return d.toLocaleDateString('en-US', { month: 'short', day: 'numeric', year: 'numeric' });
    }
    
    // Extract iteration info
    function getIterationMonth(iteration) {
        if (!iteration) return null;
        const match = iteration.match(/CY\d{4}Q\d-(\w+)/);
        return match ? match[1] : null;
    }
    
    // Slice field definitions per work item type
    const sliceFieldsByType = {
        'Bug': [
            { key: 'bugType', label: 'Bug Type', colors: colors.bugTypes },
            { key: 'state', label: 'Status', colors: colors.states },
            { key: 'deliverySliceOwner', label: 'Bug Owner' },
            { key: 'feature', label: 'Feature' },
            { key: 'component', label: 'Component' },
            { key: 'team', label: 'Team', colors: colors.teams },
            { key: 'releaseVersion', label: 'Release' },
            { key: 'assignedTo', label: 'Assigned To' }
        ],
        'Issue': [
            { key: 'ticketCategory', label: 'Category' },
            { key: 'state', label: 'Status', colors: colors.states },
            { key: 'customers', label: 'Customer' },
            { key: 'team', label: 'Team', colors: colors.teams },
            { key: 'deliverySliceOwner', label: 'DS Owner' }
        ],
        'Feature': [
            { key: 'state', label: 'Status', colors: colors.states },
            { key: 'customers', label: 'Customer' },
            { key: 'team', label: 'Team', colors: colors.teams },
            { key: 'releaseVersion', label: 'Release' }
        ],
        'Delivery Slice': [
            { key: 'state', label: 'Status', colors: colors.states },
            { key: 'team', label: 'Team', colors: colors.teams },
            { key: 'deliverySliceOwner', label: 'DS Owner' },
            { key: 'iteration', label: 'Iteration' }
        ],
        'Task': [
            { key: 'state', label: 'Status', colors: colors.states },
            { key: 'team', label: 'Team', colors: colors.teams },
            { key: 'assignedTo', label: 'Assigned To' },
            { key: 'iteration', label: 'Iteration' }
        ],
        'default': [
            { key: 'type', label: 'Type' },
            { key: 'state', label: 'Status', colors: colors.states },
            { key: 'team', label: 'Team', colors: colors.teams },
            { key: 'assignedTo', label: 'Assigned To' }
        ]
    };
    
    function getSliceFields(items) {
        const types = [...new Set(items.map(i => i.type))];
        if (types.length === 1) {
            return sliceFieldsByType[types[0]] || sliceFieldsByType['default'];
        }
        return sliceFieldsByType['default'];
    }
    
    // Multi-select handling
    function handleChartClick(evt, elements, chart, items, filterField, sliceFields) {
        if (elements.length === 0) return;
        
        const labels = chart.data.labels;
        const clickedLabel = labels[elements[0].index];
        
        // Check if Ctrl/Cmd key is pressed for multi-select
        if (evt.native.ctrlKey || evt.native.metaKey) {
            // Initialize multi-select if first click or different field
            if (multiSelectState.field !== filterField) {
                multiSelectState.field = filterField;
                multiSelectState.values = new Set();
            }
            
            // Toggle the clicked value
            if (multiSelectState.values.has(clickedLabel)) {
                multiSelectState.values.delete(clickedLabel);
            } else {
                multiSelectState.values.add(clickedLabel);
            }
            
            // Update selection info display
            updateSelectionInfo();
            
            // If we have selections, filter and show
            if (multiSelectState.values.size > 0) {
                const selectedValues = Array.from(multiSelectState.values);
                const filtered = items.filter(item => selectedValues.includes(item[filterField] || '(Not Set)'));
                
                // Update current drilldown with multi-select filter
                if (drilldownStack.length > 0) {
                    const current = drilldownStack[drilldownStack.length - 1];
                    current.multiSelect = { field: filterField, values: selectedValues };
                    renderDrilldown();
                } else {
                    showDrilldown(`${filterField}: ${selectedValues.join(', ')}`, filtered, sliceFields);
                }
            }
        } else {
            // Single click - clear multi-select and do normal drilldown
            clearMultiSelect();
            const filtered = items.filter(item => (item[filterField] || '(Not Set)') === clickedLabel);
            showDrilldown(`${filterField}: ${clickedLabel}`, filtered, sliceFields);
        }
    }
    
    function updateSelectionInfo() {
        const infoEl = document.getElementById('selectionInfo');
        const countEl = document.getElementById('selectionCount');
        
        // Guard against missing elements (e.g., when drilldown panel doesn't exist)
        if (!infoEl) return;
        
        if (multiSelectState.values.size > 0) {
            infoEl.classList.add('active');
            if (countEl) countEl.textContent = multiSelectState.values.size;
        } else {
            infoEl.classList.remove('active');
        }
    }
    
    function clearMultiSelect() {
        multiSelectState.field = null;
        multiSelectState.values = new Set();
        updateSelectionInfo();
        
        if (drilldownStack.length > 0) {
            const current = drilldownStack[drilldownStack.length - 1];
            delete current.multiSelect;
            renderDrilldown();
        }
    }
    
    // Drilldown functions
    function showDrilldown(title, items, sliceFields) {
        drilldownStack.push({ 
            title, 
            items: [...items], // Store a copy of items
            sliceFields, 
            filters: {} 
        });
        renderDrilldown();
    }
    
    function renderDrilldown() {
        const drilldownPanel = document.getElementById('drilldownPanel');
        
        // Guard against missing drilldown panel (removed in v68)
        if (!drilldownPanel) {
            updateBreadcrumb();
            return;
        }
        
        if (drilldownStack.length === 0) {
            drilldownPanel.classList.remove('active');
            updateBreadcrumb();
            return;
        }
        
        const current = drilldownStack[drilldownStack.length - 1];
        let filteredItems = [...current.items];
        
        // Apply any filters
        if (Object.keys(current.filters).length > 0) {
            filteredItems = filterItems(filteredItems, current.filters);
        }
        
        // Apply multi-select if present
        if (current.multiSelect && current.multiSelect.values.length > 0) {
            filteredItems = filteredItems.filter(item => 
                current.multiSelect.values.includes(item[current.multiSelect.field] || '(Not Set)')
            );
        }
        
        drilldownPanel.classList.add('active');
        const titleEl = document.getElementById('drilldownTitle');
        const countEl = document.getElementById('drilldownCount');
        if (titleEl) titleEl.textContent = current.title;
        if (countEl) countEl.textContent = `${filteredItems.length} items`;
        
        // Render custom header if present
        const customHeaderContainer = document.getElementById('drilldownCustomHeader');
        if (customHeaderContainer) {
            customHeaderContainer.innerHTML = current.customHeader || '';
        }
        
        // Render slice filters
        renderSliceFilters(current, filteredItems);
        
        // Render table
        renderWorkItemsTable(filteredItems);
        
        updateBreadcrumb();
        
        // Scroll drilldown panel into view
        setTimeout(() => {
            drilldownPanel.scrollIntoView({ behavior: 'smooth', block: 'start' });
        }, 100);
    }
    
    function renderSliceFilters(drilldownState, items) {
        const container = document.getElementById('sliceFilters');
        container.innerHTML = '';
        
        if (!drilldownState.sliceFields || drilldownState.sliceFields.length === 0) return;
        
        drilldownState.sliceFields.forEach((field, idx) => {
            const counts = countBy(items, field.key);
            if (Object.keys(counts).length <= 1) return;
            
            // Sort by value descending
            const sortedCounts = sortObjectByValue(counts);
            
            const chartDiv = document.createElement('div');
            chartDiv.className = 'slice-chart-container';
            chartDiv.innerHTML = `
                <div class="slice-chart-title">${field.label}</div>
                <canvas id="slice-chart-${idx}" class="slice-chart-canvas"></canvas>
                <div class="multi-select-hint">Ctrl+Click to multi-select</div>
            `;
            container.appendChild(chartDiv);
            
            const labels = Object.keys(sortedCounts).slice(0, 8);
            const data = labels.map(l => sortedCounts[l]);
            const chartColors = field.colors || colors.primary;
            
            setTimeout(() => {
                const chart = createChart(`slice-chart-${idx}`, 'doughnut', {
                    labels,
                    datasets: [{
                        data,
                        backgroundColor: labels.map((label, i) => 
                            typeof chartColors === 'object' && !Array.isArray(chartColors) 
                                ? (chartColors[label] || colors.primary[i % colors.primary.length])
                                : chartColors[i % chartColors.length]
                        ),
                        borderWidth: 0
                    }]
                }, {
                    plugins: { legend: { display: false } },
                    onClick: (evt, elements) => {
                        if (elements.length > 0) {
                            const label = labels[elements[0].index];
                            drilldownBySlice(field.key, label, evt);
                        }
                    }
                });
            }, 50);
        });
    }
    
    function drilldownBySlice(field, value, evt) {
        const current = drilldownStack[drilldownStack.length - 1];
        
        // Check for multi-select (Ctrl/Cmd+Click)
        if (evt && (evt.native.ctrlKey || evt.native.metaKey)) {
            if (!current.multiSelect || current.multiSelect.field !== field) {
                current.multiSelect = { field, values: [] };
            }
            
            const idx = current.multiSelect.values.indexOf(value);
            if (idx > -1) {
                current.multiSelect.values.splice(idx, 1);
            } else {
                current.multiSelect.values.push(value);
            }
            
            multiSelectState.field = field;
            multiSelectState.values = new Set(current.multiSelect.values);
            updateSelectionInfo();
            renderDrilldown();
            return;
        }
        
        // Single click - create new drilldown level
        clearMultiSelect();
        
        let filteredItems = [...current.items];
        if (Object.keys(current.filters).length > 0) {
            filteredItems = filterItems(filteredItems, current.filters);
        }
        
        const newFiltered = filteredItems.filter(item => (item[field] || '(Not Set)') === value);
        const fieldLabel = current.sliceFields.find(f => f.key === field)?.label || field;
        
        drilldownStack.push({
            title: `${fieldLabel}: ${value}`,
            items: newFiltered,
            sliceFields: current.sliceFields.filter(f => f.key !== field),
            filters: {}
        });
        
        renderDrilldown();
    }
    
    function renderWorkItemsTable(items) {
        const thead = document.getElementById('tableHead');
        const tbody = document.getElementById('tableBody');
        
        // Determine columns based on item types present
        const types = [...new Set(items.map(i => i.type))];
        let columns = [
            { key: 'id', label: 'ID' },
            { key: 'title', label: 'Title' },
            { key: 'type', label: 'Type' },
            { key: 'state', label: 'State' }
        ];
        
        // Add Customers column for release-related items (Feature, Issue, Bug)
        const isReleaseRelated = types.some(t => ['Feature', 'Issue', 'Bug'].includes(t));
        if (isReleaseRelated) {
            columns.push({ key: 'customers', label: 'Customers' });
        }
        
        columns.push({ key: 'assignedTo', label: 'Assigned To' });
        columns.push({ key: 'team', label: 'Team' });
        
        // Add type-specific columns
        if (types.includes('Bug')) {
            columns.push({ key: 'bugType', label: 'Bug Type' });
            columns.push({ key: 'feature', label: 'Feature' });
            columns.push({ key: 'component', label: 'Component' });
            columns.push({ key: 'deliverySliceOwner', label: 'Bug Owner' });
            columns.push({ key: 'effort', label: 'Effort' });
            columns.push({ key: 'createdDate', label: 'Created' });
            columns.push({ key: 'closedDate', label: 'Closed' });
            columns.push({ key: 'gantt', label: 'Timeline' });
        }
        if (types.includes('Issue')) {
            columns.push({ key: 'ticketCategory', label: 'Category' });
        }
        if (types.includes('Delivery Slice') && !types.includes('Bug')) {
            columns.push({ key: 'deliverySliceOwner', label: 'DS Owner' });
            columns.push({ key: 'effort', label: 'Effort' });
        }
        if (types.includes('Task')) {
            columns.push({ key: 'effort', label: 'Effort' });
        }
        columns.push({ key: 'iteration', label: 'Iteration' });
        columns.push({ key: 'releaseVersion', label: 'Release' });
        
        // Remove duplicates
        const seenKeys = new Set();
        columns = columns.filter(c => {
            if (seenKeys.has(c.key)) return false;
            seenKeys.add(c.key);
            return true;
        });
        
        // Calculate Gantt timeline range if showing bugs
        let ganttStartDate, ganttEndDate, ganttWeeks = [];
        if (types.includes('Bug')) {
            // Get date range from bug filter inputs or use item dates
            const startInput = document.getElementById('bug-trend-start')?.value;
            const endInput = document.getElementById('bug-trend-end')?.value;
            
            if (startInput && endInput) {
                ganttStartDate = new Date(startInput);
                ganttEndDate = new Date(endInput);
            } else {
                // Find min/max dates from items
                const dates = items.flatMap(item => {
                    const d = [];
                    if (item.createdDate) d.push(new Date(item.createdDate));
                    const closed = getBugClosedDateForTable(item);
                    if (closed) d.push(closed);
                    return d;
                }).filter(d => d);
                
                if (dates.length > 0) {
                    ganttStartDate = new Date(Math.min(...dates));
                    ganttEndDate = new Date(Math.max(...dates));
                }
            }
            
            // Build week columns
            if (ganttStartDate && ganttEndDate) {
                ganttStartDate.setHours(0, 0, 0, 0);
                ganttEndDate.setHours(23, 59, 59, 999);
                
                // Get Monday of start week
                const monday = new Date(ganttStartDate);
                const day = monday.getDay();
                monday.setDate(monday.getDate() - day + (day === 0 ? -6 : 1));
                
                let currentWeek = new Date(monday);
                while (currentWeek <= ganttEndDate) {
                    ganttWeeks.push(new Date(currentWeek));
                    currentWeek.setDate(currentWeek.getDate() + 7);
                }
            }
        }
        
        // Store gantt data for sorting
        window._drilldownGanttData = { ganttStartDate, ganttEndDate, ganttWeeks };
        
        // Initialize sort state for drilldown table
        if (!tableSortState['drilldown']) {
            tableSortState['drilldown'] = { column: null, direction: 'asc', items: [...items], columns };
        } else {
            tableSortState['drilldown'].items = [...items];
            tableSortState['drilldown'].columns = columns;
        }
        
        // Sort items if sort is active
        let sortedItems = [...items];
        const state = tableSortState['drilldown'];
        if (state.column) {
            sortedItems = sortItems(sortedItems, state.column, state.direction);
        }
        
        const hasSortActive = state.column;
        const clearSortBtn = hasSortActive ? `<button class="clear-sort-btn" onclick="clearDrilldownSort()">Clear Sort</button>` : '';
        
        thead.innerHTML = `<tr>${columns.map(c => {
            if (c.key === 'gantt' && ganttWeeks.length > 0) {
                // Gantt header with week markers - not sortable, not resizable
                const weekLabels = ganttWeeks.map(w => {
                    const month = w.toLocaleDateString('en-US', { month: 'short' });
                    const day = w.getDate();
                    return `<span class="gantt-week-label">${month} ${day}</span>`;
                }).join('');
                return `<th class="gantt-header"><div class="gantt-weeks">${weekLabels}</div></th>`;
            }
            return `<th class="sortable-header resizable-header ${getColumnClass(c.key)}" onclick="sortDrilldownTable('${c.key}')">
                ${c.label}
                <span class="sort-indicator">${getSortIndicator('drilldown', c.key)}</span>
                <div class="resize-handle" onmousedown="startResize(event, this)"></div>
            </th>`;
        }).join('')}${hasSortActive ? `<th style="width: 80px;">${clearSortBtn}</th>` : ''}</tr>`;
        
        tbody.innerHTML = sortedItems.map(item => `
            <tr>
                ${columns.map(col => {
                    if (col.key === 'id') {
                        return `<td><a href="${item.url}" target="_blank" class="work-item-id">${item.id}</a></td>`;
                    }
                    if (col.key === 'title') {
                        return `<td class="work-item-title" title="${(item.title || '').replace(/"/g, '&quot;')}">${item.title || ''}</td>`;
                    }
                    if (col.key === 'state') {
                        return `<td><span class="state-badge ${getStateClass(item.state)}">${item.state || ''}</span></td>`;
                    }
                    if (col.key === 'effort') {
                        return `<td class="effort-value">${item.effort ? item.effort.toFixed(1) + 'd' : ''}</td>`;
                    }
                    if (col.key === 'createdDate') {
                        const d = item.createdDate ? new Date(item.createdDate).toLocaleDateString() : '';
                        return `<td>${d}</td>`;
                    }
                    if (col.key === 'closedDate') {
                        const closed = getBugClosedDateForTable(item);
                        const d = closed ? closed.toLocaleDateString() : (item.state === 'Done' || item.state === 'Closed' ? '?' : '');
                        return `<td>${d}</td>`;
                    }
                    if (col.key === 'gantt' && ganttWeeks.length > 0) {
                        return `<td class="gantt-cell">${renderGanttBar(item, ganttStartDate, ganttEndDate, ganttWeeks)}</td>`;
                    }
                    return `<td>${item[col.key] || ''}</td>`;
                }).join('')}${hasSortActive ? '<td></td>' : ''}
            </tr>
        `).join('');
    }
    
    function sortDrilldownTable(columnKey) {
        const state = tableSortState['drilldown'];
        if (!state) return;
        
        // Toggle direction if same column, otherwise set to asc
        if (state.column === columnKey) {
            state.direction = state.direction === 'asc' ? 'desc' : 'asc';
        } else {
            state.column = columnKey;
            state.direction = 'asc';
        }
        
        // Re-render the table
        renderWorkItemsTable(state.items);
    }
    
    function clearDrilldownSort() {
        if (tableSortState['drilldown']) {
            tableSortState['drilldown'].column = null;
            tableSortState['drilldown'].direction = 'asc';
            renderWorkItemsTable(tableSortState['drilldown'].items);
        }
    }
    
    function getBugClosedDateForTable(item) {
        // For table display - get closed date
        if (item.closedDate) {
            try {
                return new Date(item.closedDate);
            } catch {
                // fall through
            }
        }
        if (item.stateChangeDate && (item.state === 'Done' || item.state === 'Closed')) {
            try {
                return new Date(item.stateChangeDate);
            } catch {
                // fall through
            }
        }
        return null;
    }
    
    function renderGanttBar(item, ganttStartDate, ganttEndDate, ganttWeeks) {
        if (!ganttStartDate || !ganttEndDate || ganttWeeks.length === 0) return '';
        
        const created = item.createdDate ? new Date(item.createdDate) : null;
        const closed = getBugClosedDateForTable(item);
        
        if (!created) return '<div class="gantt-bar-container"></div>';
        
        const totalMs = ganttEndDate.getTime() - ganttStartDate.getTime();
        if (totalMs <= 0) return '<div class="gantt-bar-container"></div>';
        
        // Calculate positions as percentages
        const startMs = Math.max(0, created.getTime() - ganttStartDate.getTime());
        const startPercent = (startMs / totalMs) * 100;
        
        let endPercent;
        let isOpen = false;
        if (closed) {
            const endMs = Math.min(totalMs, closed.getTime() - ganttStartDate.getTime());
            endPercent = (endMs / totalMs) * 100;
        } else {
            // Still open - show bar extending to end
            endPercent = 100;
            isOpen = true;
        }
        
        const widthPercent = Math.max(2, endPercent - startPercent);
        const barClass = isOpen ? 'gantt-bar open' : 'gantt-bar closed';
        
        // Week dividers
        const weekDividers = ganttWeeks.map((w, i) => {
            const weekMs = w.getTime() - ganttStartDate.getTime();
            const weekPercent = (weekMs / totalMs) * 100;
            return `<div class="gantt-week-divider" style="left: ${weekPercent}%"></div>`;
        }).join('');
        
        return `
            <div class="gantt-bar-container">
                ${weekDividers}
                <div class="${barClass}" style="left: ${startPercent}%; width: ${widthPercent}%;" 
                     title="Created: ${created.toLocaleDateString()}${closed ? ', Closed: ' + closed.toLocaleDateString() : ' (Open)'}"></div>
            </div>
        `;
    }
    
    function closeDrilldown() {
        drilldownStack = [];
        clearMultiSelect();
        const panel = document.getElementById('drilldownPanel');
        if (panel) panel.classList.remove('active');
        updateBreadcrumb();
    }
    
    function navigateBreadcrumb(index) {
        if (index === -1) {
            closeDrilldown();
        } else {
            // Keep items up to and including the clicked index
            drilldownStack = drilldownStack.slice(0, index + 1);
            clearMultiSelect();
            renderDrilldown();
        }
    }
    
    function updateBreadcrumb() {
        const container = document.getElementById('breadcrumb');
        const viewNames = {
            'executive': 'Executive',
            'teams': 'Teams',
            'customers': 'Customers',
            'bugs': 'Bugs',
            'releases': 'Releases',
            'tasks': 'Tasks',
            'validation': 'Validation',
            'orgchart': 'Org Chart',
            'details': 'Details'
        };
        
        let html = `<span class="breadcrumb-item" onclick="navigateBreadcrumb(-1)">${viewNames[currentView] || currentView}</span>`;
        
        drilldownStack.forEach((item, idx) => {
            html += `<span class="breadcrumb-separator">›</span>`;
            if (idx === drilldownStack.length - 1) {
                html += `<span class="breadcrumb-current">${item.title}</span>`;
            } else {
                html += `<span class="breadcrumb-item" onclick="navigateBreadcrumb(${idx})">${item.title}</span>`;
            }
        });
        
        container.innerHTML = html;
    }
    
    function createClickableChart(canvasId, type, data, filterField, colorMap = null, baseItems = null) {
        const items = baseItems || workItems;
        const sortedData = sortObjectByValue(data);
        const labels = Object.keys(sortedData);
        const values = Object.values(sortedData);
        const chartColors = labels.map((label, i) => 
            colorMap ? (colorMap[label] || colors.primary[i % colors.primary.length]) : colors.primary[i % colors.primary.length]
        );
        
        const chart = createChart(canvasId, type, {
            labels,
            datasets: [{
                data: values,
                backgroundColor: chartColors,
                borderWidth: 0
            }]
        }, {
            onClick: (evt, elements) => {
                if (elements.length > 0) {
                    handleChartClick(evt, elements, activeCharts[canvasId], items, filterField, getSliceFields(items));
                }
            },
            plugins: {
                legend: { display: type === 'doughnut', position: 'right', labels: { color: '#94a3b8' } }
            },
            scales: type === 'bar' ? {
                x: { ticks: { color: '#94a3b8' }, grid: { color: '#334155' } },
                y: { ticks: { color: '#94a3b8' }, grid: { color: '#334155' } }
            } : undefined
        });
        
        return chart;
    }
    
    // Sortable table state
    const tableSortState = {};
    
    function renderSortableTable(tableId, items, columns, defaultSort = null) {
        const thead = document.getElementById(`${tableId}TableHead`);
        const tbody = document.getElementById(`${tableId}TableBody`);
        
        if (!thead || !tbody) return;
        
        // Initialize sort state if needed
        if (!tableSortState[tableId]) {
            // Apply default sort if provided and no existing state
            if (defaultSort) {
                tableSortState[tableId] = { 
                    column: defaultSort.column, 
                    direction: defaultSort.direction || 'asc', 
                    items: [...items],
                    defaultSort: defaultSort  // Store default for reset
                };
            } else {
                tableSortState[tableId] = { column: null, direction: 'asc', items: [...items] };
            }
        } else {
            tableSortState[tableId].items = [...items];
            if (defaultSort) {
                tableSortState[tableId].defaultSort = defaultSort;
            }
        }
        
        // Render header with sort indicators and resize handles
        // Show reset button only when sorted by column other than default backlogPriority
        const currentColumn = tableSortState[tableId]?.column;
        const defaultColumn = tableSortState[tableId]?.defaultSort?.column;
        const showResetBtn = currentColumn && currentColumn !== defaultColumn;
        const resetSortBtn = showResetBtn ? `<button class="reset-sort-btn" onclick="clearTableSort('${tableId}')">Reset to Backlog Priority</button>` : '';

        thead.innerHTML = `<tr>${columns.map(c => `
            <th class="sortable-header resizable-header ${getColumnClass(c.key)}" onclick="sortTable('${tableId}', '${c.key}')">
                ${c.label}
                <span class="sort-indicator">${getSortIndicator(tableId, c.key)}</span>
                <div class="resize-handle" onmousedown="startResize(event, this)"></div>
            </th>
        `).join('')}${showResetBtn ? `<th style="width: 140px;">${resetSortBtn}</th>` : ''}</tr>`;
        
        // Sort items if sort is active
        let sortedItems = [...items];
        const state = tableSortState[tableId];
        if (state.column) {
            sortedItems = sortItems(sortedItems, state.column, state.direction);
        }
        
        // Render body
        tbody.innerHTML = sortedItems.map(item => `
            <tr>
                ${columns.map(col => renderTableCell(item, col)).join('')}
                ${showResetBtn ? '<td></td>' : ''}
            </tr>
        `).join('');
        
        // Store columns for re-render
        tableSortState[tableId].columns = columns;
    }
    
    function getColumnClass(key) {
        const classMap = {
            'id': 'col-id',
            'title': 'col-title',
            'type': 'col-type',
            'state': 'col-state',
            'assignedTo': 'col-assignee',
            'csOwner': 'col-assignee',
            'team': 'col-team',
            'customers': 'col-customers',
            'targetDate': 'col-date',
            'createdDate': 'col-date',
            'closedDate': 'col-date',
            'effort': 'col-effort',
            'backlogPriority': 'col-priority'
        };
        return classMap[key] || '';
    }
    
    // Column resize functionality
    let resizing = null;
    
    function startResize(e, handle) {
        e.stopPropagation();
        e.preventDefault();
        
        const th = handle.parentElement;
        resizing = {
            th: th,
            startX: e.pageX,
            startWidth: th.offsetWidth
        };
        
        handle.classList.add('resizing');
        document.addEventListener('mousemove', doResize);
        document.addEventListener('mouseup', stopResize);
    }
    
    function doResize(e) {
        if (!resizing) return;
        
        const diff = e.pageX - resizing.startX;
        const newWidth = Math.max(50, resizing.startWidth + diff);
        resizing.th.style.width = newWidth + 'px';
        resizing.th.style.minWidth = newWidth + 'px';
    }
    
    function stopResize(e) {
        if (resizing) {
            const handle = resizing.th.querySelector('.resize-handle');
            if (handle) handle.classList.remove('resizing');
        }
        resizing = null;
        document.removeEventListener('mousemove', doResize);
        document.removeEventListener('mouseup', stopResize);
    }
    
    function clearTableSort(tableId) {
        if (tableSortState[tableId]) {
            // Reset to default sort if available, otherwise clear
            const defaultSort = tableSortState[tableId].defaultSort;
            if (defaultSort) {
                tableSortState[tableId].column = defaultSort.column;
                tableSortState[tableId].direction = defaultSort.direction || 'asc';
            } else {
                tableSortState[tableId].column = null;
                tableSortState[tableId].direction = 'asc';
            }
            renderSortableTable(tableId, tableSortState[tableId].items, tableSortState[tableId].columns, defaultSort);
        }
    }
    
    function renderTableCell(item, col) {
        if (col.key === 'id') {
            return `<td><a href="${item.url}" target="_blank" class="work-item-id">${item.id}</a></td>`;
        }
        if (col.key === 'title') {
            return `<td class="work-item-title" title="${(item.title || '').replace(/"/g, '&quot;')}">${item.title || ''}</td>`;
        }
        if (col.key === 'state') {
            return `<td><span class="state-badge ${getStateClass(item.state)}">${item.state || ''}</span></td>`;
        }
        if (col.key === 'effort') {
            return `<td class="effort-value">${item.effort ? item.effort.toFixed(1) + 'd' : ''}</td>`;
        }
        if (col.key === 'targetDate') {
            return `<td>${item.targetDate ? item.targetDate.split(' ')[0] : ''}</td>`;
        }
        if (col.key === 'createdDate') {
            const d = item.createdDate ? new Date(item.createdDate).toLocaleDateString() : '';
            return `<td>${d}</td>`;
        }
        if (col.key === 'closedDate') {
            const closed = getBugClosedDateForTable(item);
            const d = closed ? closed.toLocaleDateString() : (item.state === 'Done' || item.state === 'Closed' ? '?' : '');
            return `<td>${d}</td>`;
        }
        if (col.key === 'backlogPriority') {
            // Display rank number (lower is higher priority) - format for readability
            if (item.backlogPriority) {
                // Convert large number to relative rank display
                const rank = Math.round(item.backlogPriority / 10000000);
                return `<td class="priority-value" title="${item.backlogPriority}">${rank}</td>`;
            }
            return `<td class="priority-value">-</td>`;
        }
        return `<td>${item[col.key] || ''}</td>`;
    }
    
    function sortTable(tableId, columnKey) {
        const state = tableSortState[tableId];
        if (!state) return;
        
        // Toggle direction if same column, otherwise set to asc
        if (state.column === columnKey) {
            state.direction = state.direction === 'asc' ? 'desc' : 'asc';
        } else {
            state.column = columnKey;
            state.direction = 'asc';
        }
        
        // Re-render the table
        renderSortableTable(tableId, state.items, state.columns);
    }
    
    function getSortIndicator(tableId, columnKey) {
        const state = tableSortState[tableId];
        if (!state || state.column !== columnKey) return '';
        return state.direction === 'asc' ? '▲' : '▼';
    }
    
    function sortItems(items, column, direction) {
        return [...items].sort((a, b) => {
            let aVal = a[column];
            let bVal = b[column];
            
            // Handle null/undefined
            if (aVal == null) aVal = '';
            if (bVal == null) bVal = '';
            
            // Handle dates
            if (column.includes('Date') || column === 'targetDate') {
                aVal = aVal ? new Date(aVal).getTime() : 0;
                bVal = bVal ? new Date(bVal).getTime() : 0;
            }
            // Handle numbers
            else if (column === 'id' || column === 'effort') {
                aVal = parseFloat(aVal) || 0;
                bVal = parseFloat(bVal) || 0;
            }
            // Handle strings
            else {
                aVal = String(aVal).toLowerCase();
                bVal = String(bVal).toLowerCase();
            }
            
            if (aVal < bVal) return direction === 'asc' ? -1 : 1;
            if (aVal > bVal) return direction === 'asc' ? 1 : -1;
            return 0;
        });
    }

    // ==================== GENERIC TABLE COMPONENT ====================
    // A reusable table component for consistent table behavior across dashboards.
    // Features: Title bar, header bar (item count, hint, effort total, copy/export buttons),
    // sortable columns, resizable columns, clickable rows, total row.

    // State storage for generic tables
    const genericTableState = {};

    /**
     * Build and render a generic table section
     * @param {Object} config - Configuration object
     * @param {string} config.containerId - DOM element ID to render into
     * @param {string} config.tableId - Unique table identifier
     * @param {string} config.icon - Icon emoji for the title
     * @param {string} config.title - Table title text
     * @param {string} [config.adoLink] - Optional ADO backlog link URL
     * @param {string} [config.adoLinkText] - Optional ADO link text (default: "Open in ADO")
     * @param {Array} config.columns - Column definitions [{key, label, class, width}]
     * @param {Array} config.items - Data items to display
     * @param {Object} config.sortState - Reference to sort state object {column, direction}
     * @param {Object} config.defaultSort - Default sort {column, direction}
     * @param {Function} config.onSort - Callback when sort changes (column, direction)
     * @param {boolean} [config.hasEffort] - Show effort total
     * @param {Object} [config.effortMap] - Map of item.id -> effort value
     * @param {string} [config.effortLabel] - Label for effort context (e.g., "Team · Iteration")
     * @param {Function} [config.onRowClick] - Callback when row is clicked (item)
     * @param {string} [config.rowClickHint] - Hint text for clickable rows
     * @param {Object} [config.columnWidths] - Saved column widths {columnKey: width}
     * @param {Function} [config.onColumnResize] - Callback when column is resized (columnKey, width)
     * @param {Function} [config.renderCell] - Custom cell renderer (item, column) => HTML string
     * @param {Function} [config.renderRow] - Custom row renderer (item, columns, cellsHtml) => HTML string
     * @param {boolean} [config.showTotalRow] - Show total row at bottom
     * @param {number} [config.totalColspan] - Colspan for total row label
     */
    function buildGenericTable(config) {
        const container = document.getElementById(config.containerId);
        if (!container) {
            console.error(`[GenericTable] Container not found: ${config.containerId}`);
            return;
        }

        const {
            tableId,
            icon = '📋',
            title,
            adoLink,
            adoLinkText = 'Open in ADO',
            columns,
            items,
            sortState,
            defaultSort,
            onSort,
            hasEffort = false,
            effortMap = {},
            effortLabel = '',
            onRowClick,
            rowClickHint = 'Click on a row to view details',
            columnWidths = {},
            onColumnResize,
            renderCell,
            renderRow,
            showTotalRow = false,
            totalColspan = 1
        } = config;

        // Store state
        genericTableState[tableId] = {
            config,
            lastResizeTime: 0
        };

        // Calculate effort total if needed
        let totalEffort = 0;
        if (hasEffort) {
            items.forEach(item => {
                totalEffort += effortMap[item.id] || item.effort || 0;
            });
        }

        // Check if sort is non-default
        const isNonDefaultSort = sortState.column !== null &&
            (sortState.column !== defaultSort?.column || sortState.direction !== defaultSort?.direction);

        // Sort items
        let sortedItems = [...items];
        if (sortState.column) {
            sortedItems = genericTableSortItems(sortedItems, sortState.column, sortState.direction, effortMap);
        } else if (defaultSort?.column) {
            sortedItems = genericTableSortItems(sortedItems, defaultSort.column, defaultSort.direction, effortMap);
        }

        // Build title bar
        const adoLinkHtml = adoLink ?
            `<a href="${adoLink}" target="_blank" class="generic-table-ado-link">${adoLinkText} →</a>` : '';

        const titleBarHtml = `
            <div class="generic-table-title-bar">
                <div class="generic-table-title">
                    <span class="table-icon">${icon}</span>
                    <span>${title}</span>
                    <span class="table-count">(${items.length})</span>
                    ${adoLinkHtml}
                </div>
            </div>
        `;

        // Build header bar
        const effortTotalHtml = hasEffort ?
            `<span class="generic-table-effort-total">Total: <strong>${totalEffort.toFixed(1)}d</strong>${effortLabel ? ` (${effortLabel})` : ''}</span>` : '';

        const hintHtml = onRowClick ?
            `<span class="generic-table-hint">${rowClickHint}</span>` : '';

        const resetBtnHtml = isNonDefaultSort ?
            `<button class="reset-sort-btn" onclick="genericTableResetSort('${tableId}')">↺ Reset Sort</button>` : '';

        const headerBarHtml = `
            <div class="generic-table-header-bar">
                <div class="generic-table-header-left">
                    <span class="generic-table-item-count">Showing <strong>${items.length}</strong> items</span>
                    ${hintHtml}
                </div>
                <div class="generic-table-header-right">
                    ${effortTotalHtml}
                    <button class="generic-table-btn btn-copy" onclick="genericTableCopy('${tableId}')" title="Copy to clipboard">
                        <span class="btn-icon">📋</span> Copy
                    </button>
                    <button class="generic-table-btn btn-export" onclick="genericTableExport('${tableId}', '${title.replace(/'/g, "\\'")}')">
                        <span class="btn-icon">📥</span> Export
                    </button>
                    ${resetBtnHtml}
                </div>
            </div>
        `;

        // Build table header
        const headerCellsHtml = columns.map(col => {
            const widthStyle = columnWidths[col.key] ? `style="width: ${columnWidths[col.key]}px"` : '';
            const sortIndicator = getSortIndicatorGeneric(sortState, col.key, defaultSort);
            const colClass = col.class || `col-${col.key}`;
            return `
                <th class="sortable-header resizable-header ${colClass}"
                    data-col="${col.key}"
                    onclick="genericTableSortIfNotResizing('${tableId}', '${col.key}')"
                    ${widthStyle}>
                    ${col.label}
                    <span class="sort-indicator">${sortIndicator}</span>
                    <div class="resize-handle" onmousedown="genericTableStartResize(event, this, '${tableId}', '${col.key}')"></div>
                </th>
            `;
        }).join('');

        // Build table body rows
        const bodyRowsHtml = sortedItems.map(item => {
            const cellsHtml = columns.map(col => {
                if (renderCell) {
                    return renderCell(item, col);
                }
                return genericTableDefaultRenderCell(item, col, effortMap);
            }).join('');

            if (renderRow) {
                return renderRow(item, columns, cellsHtml);
            }

            const rowClass = onRowClick ? 'clickable-row' : '';
            const escapedTitle = (item.title || '').replace(/\\/g, '\\\\').replace(/'/g, "\\'").replace(/"/g, '&quot;');
            const rowClick = onRowClick ?
                `onclick="genericTableRowClick('${tableId}', ${item.id}, '${escapedTitle}')"` : '';

            return `<tr class="${rowClass}" data-item-id="${item.id}" ${rowClick}>${cellsHtml}</tr>`;
        }).join('');

        // Build total row if needed
        let totalRowHtml = '';
        if (showTotalRow && hasEffort) {
            totalRowHtml = `
                <tr class="total-row">
                    <td colspan="${totalColspan}" style="text-align: right; font-weight: 600; color: var(--text-secondary);">Total Effort:</td>
                    <td class="effort-value" style="font-weight: 700; color: var(--accent-cyan);">${totalEffort.toFixed(1)}d</td>
                </tr>
            `;
        }

        // Assemble full HTML
        container.innerHTML = `
            <div class="generic-table-section">
                ${titleBarHtml}
                ${headerBarHtml}
                <div class="generic-table-scroll-container">
                    <table class="generic-table resizable-table" id="${tableId}">
                        <thead>
                            <tr>${headerCellsHtml}</tr>
                        </thead>
                        <tbody>
                            ${bodyRowsHtml}
                            ${totalRowHtml}
                        </tbody>
                    </table>
                </div>
            </div>
        `;

        // Set up click handler delegation if needed
        if (onRowClick) {
            setupGenericTableClickHandler(tableId, onRowClick);
        }
    }

    // Get sort indicator for a column
    function getSortIndicatorGeneric(sortState, columnKey, defaultSort) {
        // If explicitly sorted by this column
        if (sortState.column === columnKey) {
            return sortState.direction === 'asc' ? '▲' : '▼';
        }
        // If using default sort and this is the default column
        if (sortState.column === null && defaultSort?.column === columnKey) {
            return defaultSort.direction === 'asc' ? '▲' : '▼';
        }
        return '';
    }

    // Default cell renderer
    function genericTableDefaultRenderCell(item, col, effortMap = {}) {
        const key = col.key;
        const value = item[key];
        const colClass = col.class || `col-${key}`;

        if (key === 'id') {
            return `<td class="${colClass}"><a href="${item.url}" target="_blank" class="work-item-link" onclick="event.stopPropagation()">${item.id}</a></td>`;
        }
        if (key === 'title') {
            return `<td class="${colClass}" title="${(value || '').replace(/"/g, '&quot;')}">${value || ''}</td>`;
        }
        if (key === 'state') {
            const stateClass = getStateClass(value);
            return `<td class="${colClass}"><span class="state-badge ${stateClass}">${value || ''}</span></td>`;
        }
        if (key === 'effort') {
            const effort = effortMap[item.id] || item.effort || 0;
            return `<td class="${colClass} effort-value">${effort > 0 ? effort.toFixed(1) + 'd' : ''}</td>`;
        }
        if (key === 'targetDate') {
            return `<td class="${colClass}">${formatTargetDate(value)}</td>`;
        }
        if (key === 'createdDate' || key === 'closedDate') {
            const d = value ? new Date(value).toLocaleDateString() : '';
            return `<td class="${colClass}">${d}</td>`;
        }
        if (key === 'priority') {
            const priorityDisplay = value ? `P${value}` : '';
            return `<td class="${colClass} priority-cell">${priorityDisplay}</td>`;
        }
        if (key === 'backlogPriority') {
            if (value) {
                const rank = Math.round(value / 10000000);
                return `<td class="${colClass} priority-value" title="${value}">${rank}</td>`;
            }
            return `<td class="${colClass} priority-value">-</td>`;
        }

        return `<td class="${colClass}">${value || ''}</td>`;
    }

    // Sort items generically
    function genericTableSortItems(items, column, direction, effortMap = {}) {
        return [...items].sort((a, b) => {
            let aVal, bVal;

            // Special handling for effort (calculated from map)
            if (column === 'effort') {
                aVal = effortMap[a.id] || a.effort || 0;
                bVal = effortMap[b.id] || b.effort || 0;
            }
            // Special handling for aging (calculated from createdDate)
            else if (column === 'aging') {
                aVal = typeof calculateAgeDays === 'function' ? calculateAgeDays(a) : 0;
                bVal = typeof calculateAgeDays === 'function' ? calculateAgeDays(b) : 0;
            } else {
                aVal = a[column];
                bVal = b[column];
            }

            // Handle null/undefined
            if (aVal == null) aVal = '';
            if (bVal == null) bVal = '';

            // Handle dates
            if (column.includes('Date') || column === 'targetDate') {
                aVal = aVal ? new Date(aVal).getTime() : 0;
                bVal = bVal ? new Date(bVal).getTime() : 0;
            }
            // Handle numbers (already calculated for effort/aging)
            else if (column === 'id' || column === 'effort' || column === 'priority' || column === 'backlogPriority' || column === 'aging') {
                aVal = parseFloat(aVal) || 0;
                bVal = parseFloat(bVal) || 0;
            }
            // Handle state (semantic order)
            else if (column === 'state') {
                const stateOrder = ['New', 'Triaged', 'To Do', 'In Progress', 'Ready For Review', 'Done', 'Closed', 'Removed'];
                aVal = stateOrder.indexOf(aVal);
                bVal = stateOrder.indexOf(bVal);
                if (aVal === -1) aVal = 999;
                if (bVal === -1) bVal = 999;
            }
            // Handle strings
            else {
                aVal = String(aVal).toLowerCase();
                bVal = String(bVal).toLowerCase();
            }

            if (aVal < bVal) return direction === 'asc' ? -1 : 1;
            if (aVal > bVal) return direction === 'asc' ? 1 : -1;
            return 0;
        });
    }

    // Sort handler (prevents sort if resize just happened)
    function genericTableSortIfNotResizing(tableId, columnKey) {
        const state = genericTableState[tableId];
        if (!state) return;

        // Don't sort if resize happened within last 200ms
        if (Date.now() - state.lastResizeTime < 200) {
            return;
        }

        const { config } = state;
        const sortState = config.sortState;

        // Toggle direction if same column
        if (sortState.column === columnKey) {
            sortState.direction = sortState.direction === 'asc' ? 'desc' : 'asc';
        } else {
            sortState.column = columnKey;
            sortState.direction = 'asc';
        }

        // Call onSort callback
        if (config.onSort) {
            config.onSort(sortState.column, sortState.direction);
        }

        // Re-render table
        buildGenericTable(config);
    }

    // Reset sort to default
    function genericTableResetSort(tableId) {
        const state = genericTableState[tableId];
        if (!state) return;

        const { config } = state;
        config.sortState.column = null;
        config.sortState.direction = 'asc';

        if (config.onSort) {
            config.onSort(null, 'asc');
        }

        buildGenericTable(config);
    }

    // Column resize state
    let genericTableResizeState = null;

    function genericTableStartResize(e, handle, tableId, columnKey) {
        e.stopPropagation();
        e.preventDefault();

        const th = handle.parentElement;
        genericTableResizeState = {
            tableId,
            columnKey,
            th,
            startX: e.pageX,
            startWidth: th.offsetWidth
        };

        handle.classList.add('resizing');
        document.addEventListener('mousemove', genericTableDoResize);
        document.addEventListener('mouseup', genericTableStopResize);
    }

    function genericTableDoResize(e) {
        if (!genericTableResizeState) return;

        const diff = e.pageX - genericTableResizeState.startX;
        const newWidth = Math.max(50, genericTableResizeState.startWidth + diff);
        genericTableResizeState.th.style.width = newWidth + 'px';
        genericTableResizeState.th.style.minWidth = newWidth + 'px';
    }

    function genericTableStopResize(e) {
        if (!genericTableResizeState) return;

        const { tableId, columnKey, th } = genericTableResizeState;
        const state = genericTableState[tableId];

        // Mark resize time to prevent sort
        if (state) {
            state.lastResizeTime = Date.now();
        }

        // Remove handle styling
        const handle = th.querySelector('.resize-handle');
        if (handle) handle.classList.remove('resizing');

        // Call resize callback
        if (state?.config?.onColumnResize) {
            const newWidth = th.offsetWidth;
            state.config.onColumnResize(columnKey, newWidth);
        }

        genericTableResizeState = null;
        document.removeEventListener('mousemove', genericTableDoResize);
        document.removeEventListener('mouseup', genericTableStopResize);
    }

    // Row click handler
    function genericTableRowClick(tableId, itemId, itemTitle) {
        const state = genericTableState[tableId];
        if (!state?.config?.onRowClick) return;

        // Don't trigger if resize just happened
        if (Date.now() - state.lastResizeTime < 200) return;

        // Find the item
        const item = state.config.items.find(i => i.id === itemId);
        if (item) {
            state.config.onRowClick(item);
        }
    }

    // Setup click handler with event delegation
    function setupGenericTableClickHandler(tableId, onRowClick) {
        const table = document.getElementById(tableId);
        if (!table || table.dataset.clickHandlerAttached) return;

        table.addEventListener('click', function(e) {
            // Don't trigger if clicking on a link
            if (e.target.tagName === 'A' || e.target.closest('a')) return;

            const row = e.target.closest('tr.clickable-row');
            if (!row) return;

            const itemId = parseInt(row.dataset.itemId);
            const state = genericTableState[tableId];
            if (!state) return;

            // Don't trigger if resize just happened
            if (Date.now() - state.lastResizeTime < 200) return;

            const item = state.config.items.find(i => i.id === itemId);
            if (item) {
                onRowClick(item);
            }
        });

        table.dataset.clickHandlerAttached = 'true';
    }

    // Copy table to clipboard (TSV format for Excel/Google Sheets)
    function genericTableCopy(tableId) {
        const state = genericTableState[tableId];
        if (!state) return;

        const { config } = state;
        const { columns, items, sortState, defaultSort, effortMap = {} } = config;

        // Sort items same as display
        let sortedItems = [...items];
        if (sortState.column) {
            sortedItems = genericTableSortItems(sortedItems, sortState.column, sortState.direction, effortMap);
        } else if (defaultSort?.column) {
            sortedItems = genericTableSortItems(sortedItems, defaultSort.column, defaultSort.direction, effortMap);
        }

        // Build TSV
        const rows = [];

        // Header row
        rows.push(columns.map(col => col.label).join('\t'));

        // Data rows
        sortedItems.forEach(item => {
            const cells = columns.map(col => {
                let value = item[col.key];
                if (col.key === 'effort') {
                    value = effortMap[item.id] || item.effort || 0;
                    value = value > 0 ? value.toFixed(1) : '';
                } else if (col.key === 'priority') {
                    value = value ? `P${value}` : '';
                } else if (col.key === 'targetDate') {
                    value = value ? value.split(' ')[0] : '';
                } else {
                    value = value || '';
                }
                // Escape tabs and newlines
                return String(value).replace(/\t/g, ' ').replace(/\n/g, ' ');
            });
            rows.push(cells.join('\t'));
        });

        const tsv = rows.join('\n');

        // Copy to clipboard
        navigator.clipboard.writeText(tsv).then(() => {
            showGenericTableToast('Copied to clipboard!');
        }).catch(err => {
            console.error('[GenericTable] Copy failed:', err);
            showGenericTableToast('Copy failed', true);
        });
    }

    // Export table to CSV
    function genericTableExport(tableId, title) {
        const state = genericTableState[tableId];
        if (!state) return;

        const { config } = state;
        const { columns, items, sortState, defaultSort, effortMap = {} } = config;

        // Sort items same as display
        let sortedItems = [...items];
        if (sortState.column) {
            sortedItems = genericTableSortItems(sortedItems, sortState.column, sortState.direction, effortMap);
        } else if (defaultSort?.column) {
            sortedItems = genericTableSortItems(sortedItems, defaultSort.column, defaultSort.direction, effortMap);
        }

        // Build CSV
        const rows = [];

        // Header row
        rows.push(columns.map(col => `"${col.label.replace(/"/g, '""')}"`).join(','));

        // Data rows
        sortedItems.forEach(item => {
            const cells = columns.map(col => {
                let value = item[col.key];
                if (col.key === 'effort') {
                    value = effortMap[item.id] || item.effort || 0;
                    value = value > 0 ? value.toFixed(1) : '';
                } else if (col.key === 'priority') {
                    value = value ? `P${value}` : '';
                } else if (col.key === 'targetDate') {
                    value = value ? value.split(' ')[0] : '';
                } else {
                    value = value || '';
                }
                // Escape quotes and wrap in quotes
                return `"${String(value).replace(/"/g, '""')}"`;
            });
            rows.push(cells.join(','));
        });

        const csv = rows.join('\n');

        // Create blob and download
        const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
        const link = document.createElement('a');
        const filename = `${title.replace(/[^a-z0-9]/gi, '_')}_${new Date().toISOString().split('T')[0]}.csv`;

        link.href = URL.createObjectURL(blob);
        link.download = filename;
        link.style.display = 'none';
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        URL.revokeObjectURL(link.href);

        showGenericTableToast(`Exported ${sortedItems.length} items to CSV`);
    }

    // Show toast notification
    function showGenericTableToast(message, isError = false) {
        // Remove existing toast
        const existing = document.querySelector('.copy-toast');
        if (existing) existing.remove();

        const toast = document.createElement('div');
        toast.className = 'copy-toast';
        if (isError) {
            toast.style.background = 'var(--accent-red)';
        }
        toast.textContent = message;
        document.body.appendChild(toast);

        // Remove after animation
        setTimeout(() => {
            toast.remove();
        }, 2000);
    }

    // ==================== GENERIC WORK ITEM DETAILS MODAL ====================
    // A unified modal that shows delivery slices (for Features) and relationships
    // for any work item type.

    /**
     * Show work item details modal with delivery slices (if Feature) and relationships
     * @param {Object} item - Work item object
     * @param {Object} [options] - Options
     * @param {Array} [options.deliverySlices] - Pre-fetched delivery slices for Features
     * @param {string} [options.activeTeamFilter] - Active team filter for highlighting
     * @param {string} [options.activeIterationFilter] - Active iteration filter for highlighting
     */
    function showWorkItemDetailsModal(item, options = {}) {
        const modal = document.getElementById('work-item-details-modal');
        const titleEl = document.getElementById('work-item-modal-title');
        const subtitleEl = document.getElementById('work-item-modal-subtitle');
        const contentEl = document.getElementById('work-item-modal-content');

        if (!modal || !titleEl || !contentEl) {
            console.error('[GenericTable] Work item details modal elements not found');
            return;
        }

        const { deliverySlices = [], activeTeamFilter, activeIterationFilter } = options;

        // Set title
        titleEl.textContent = `${item.type} ${item.id}: ${item.title}`;

        // Set subtitle with type badge
        const typeClass = (item.type || '').toLowerCase().replace(/\s+/g, '-');
        subtitleEl.innerHTML = `<span class="work-item-type-badge type-${typeClass}">${item.type || ''}</span>`;

        // Build content sections
        let contentHtml = '';

        // Section 1: Delivery Slices (for Features only, shown first)
        if (item.type === 'Feature' && deliverySlices.length > 0) {
            contentHtml += buildDeliverySlicesSection(deliverySlices, activeTeamFilter, activeIterationFilter);
        } else if (item.type === 'Feature') {
            contentHtml += `
                <div class="work-item-modal-section">
                    <div class="work-item-modal-section-header">
                        <span class="section-icon">📦</span>
                        <span>Delivery Slices</span>
                    </div>
                    <div class="work-item-modal-empty">No Delivery Slices found for this Feature.</div>
                </div>
            `;
        }

        // Section 2: Relationships
        const relationships = getRelationshipsForWorkItem(item.id);
        contentHtml += buildRelationshipsSection(relationships, item.type);

        contentEl.innerHTML = contentHtml;

        // Show modal
        modal.style.display = 'flex';
    }

    // Build delivery slices section HTML
    function buildDeliverySlicesSection(slices, activeTeamFilter, activeIterationFilter) {
        // Sort slices: matching filters first
        let sortedSlices = [...slices];
        if (activeTeamFilter || activeIterationFilter) {
            sortedSlices.sort((a, b) => {
                const teamA = a.team || getLastPathSegment(a.areaPath) || '(No Team)';
                const teamB = b.team || getLastPathSegment(b.areaPath) || '(No Team)';
                const iterA = a.iteration || getLastPathSegment(a.iterationPath) || '(No Iteration)';
                const iterB = b.iteration || getLastPathSegment(b.iterationPath) || '(No Iteration)';

                const matchA = (activeTeamFilter && teamA === activeTeamFilter ? 2 : 0) +
                               (activeIterationFilter && iterA === activeIterationFilter ? 1 : 0);
                const matchB = (activeTeamFilter && teamB === activeTeamFilter ? 2 : 0) +
                               (activeIterationFilter && iterB === activeIterationFilter ? 1 : 0);

                return matchB - matchA;
            });
        }

        // Calculate effort summary
        let filteredEffort = 0;
        let totalEffort = 0;
        sortedSlices.forEach(ds => {
            const effort = ds.effort || 0;
            totalEffort += effort;
            const dsTeam = ds.team || getLastPathSegment(ds.areaPath) || '(No Team)';
            const dsIteration = ds.iteration || getLastPathSegment(ds.iterationPath) || '(No Iteration)';
            const teamMatch = !activeTeamFilter || dsTeam === activeTeamFilter;
            const iterationMatch = !activeIterationFilter || dsIteration === activeIterationFilter;
            if (teamMatch && iterationMatch) {
                filteredEffort += effort;
            }
        });

        // Effort summary HTML
        let effortSummaryHtml = '';
        const hasFilters = activeTeamFilter || activeIterationFilter;
        if (hasFilters) {
            const filterLabels = [];
            if (activeTeamFilter) filterLabels.push(activeTeamFilter);
            if (activeIterationFilter) filterLabels.push(activeIterationFilter);
            effortSummaryHtml = `
                <div class="delivery-slices-effort-summary">
                    <span class="effort-filter-label">${filterLabels.join(' · ')} Effort:</span>
                    <span class="effort-filter-value">${filteredEffort.toFixed(1)}d</span>
                    <span class="effort-total-label">/ Total:</span>
                    <span class="effort-total-value">${totalEffort.toFixed(1)}d</span>
                </div>
            `;
        } else {
            effortSummaryHtml = `
                <div class="delivery-slices-effort-summary">
                    <span class="effort-total-label">Total Effort:</span>
                    <span class="effort-total-value">${totalEffort.toFixed(1)}d</span>
                </div>
            `;
        }

        // Build table rows
        const rowsHtml = sortedSlices.map(ds => {
            const iteration = ds.iteration || getLastPathSegment(ds.iterationPath) || '—';
            const team = ds.team || getLastPathSegment(ds.areaPath) || '—';
            const teamMatch = !activeTeamFilter || team === activeTeamFilter;
            const iterationMatch = !activeIterationFilter || iteration === activeIterationFilter;
            const isOtherRow = hasFilters && (!teamMatch || !iterationMatch);
            const rowClass = isOtherRow ? 'other-team-row' : '';
            const stateClass = getStateClass(ds.state);

            return `
                <tr class="${rowClass}">
                    <td class="modal-col-id"><a href="${ds.url}" target="_blank" class="work-item-link">${ds.id}</a></td>
                    <td class="modal-col-title" title="${(ds.title || '').replace(/"/g, '&quot;')}">${ds.title || ''}</td>
                    <td class="modal-col-state"><span class="state-badge ${stateClass}">${ds.state || ''}</span></td>
                    <td class="modal-col-iteration">${iteration}</td>
                    <td class="modal-col-team">${team}</td>
                    <td class="modal-col-effort">${ds.effort || '—'}</td>
                    <td class="modal-col-owner">${ds.assignedTo || '—'}</td>
                </tr>
            `;
        }).join('');

        return `
            <div class="work-item-modal-section delivery-slices-section">
                <div class="work-item-modal-section-header">
                    <span class="section-icon">📦</span>
                    <span>Delivery Slices</span>
                    <span class="section-count">(${slices.length})</span>
                </div>
                ${effortSummaryHtml}
                <div class="delivery-slices-table-container">
                    <table class="delivery-slices-table">
                        <thead>
                            <tr>
                                <th class="modal-col-id">ID</th>
                                <th class="modal-col-title">Title</th>
                                <th class="modal-col-state">State</th>
                                <th class="modal-col-iteration">Iteration</th>
                                <th class="modal-col-team">Team</th>
                                <th class="modal-col-effort">Effort</th>
                                <th class="modal-col-owner">Owner</th>
                            </tr>
                        </thead>
                        <tbody>${rowsHtml}</tbody>
                    </table>
                </div>
            </div>
        `;
    }

    // Build relationships section HTML
    function buildRelationshipsSection(relationships, itemType) {
        const hasParent = relationships.parent !== null;
        const hasChildren = relationships.children.length > 0;
        const hasRelated = relationships.related.length > 0;

        if (!hasParent && !hasChildren && !hasRelated) {
            return `
                <div class="work-item-modal-section relationships-section">
                    <div class="work-item-modal-section-header">
                        <span class="section-icon">🔗</span>
                        <span>Relationships</span>
                    </div>
                    <div class="work-item-modal-empty">No relationships found for this ${itemType || 'item'}.</div>
                </div>
            `;
        }

        let html = `
            <div class="work-item-modal-section relationships-section">
                <div class="work-item-modal-section-header">
                    <span class="section-icon">🔗</span>
                    <span>Relationships</span>
                </div>
                <div class="relationships-content">
        `;

        // Parent
        if (hasParent) {
            const p = relationships.parent;
            const typeClass = (p.type || '').toLowerCase().replace(/\s+/g, '-');
            const stateClass = getStateClass(p.state);
            html += `
                <div class="relationship-group parent-group">
                    <div class="relationship-group-header">
                        <span class="rel-icon">⬆️</span>
                        <span>Parent</span>
                    </div>
                    <div class="relationship-items">
                        <div class="relationship-item">
                            <span class="rel-item-id"><a href="${p.url}" target="_blank">${p.id}</a></span>
                            <span class="rel-item-type type-${typeClass}">${p.type || ''}</span>
                            <span class="rel-item-title" title="${(p.title || '').replace(/"/g, '&quot;')}">${p.title || ''}</span>
                            <span class="rel-item-state"><span class="state-badge ${stateClass}">${p.state || ''}</span></span>
                        </div>
                    </div>
                </div>
            `;
        }

        // Children
        if (hasChildren) {
            const childrenHtml = relationships.children.map(c => {
                const typeClass = (c.type || '').toLowerCase().replace(/\s+/g, '-');
                const stateClass = getStateClass(c.state);
                return `
                    <div class="relationship-item">
                        <span class="rel-item-id"><a href="${c.url}" target="_blank">${c.id}</a></span>
                        <span class="rel-item-type type-${typeClass}">${c.type || ''}</span>
                        <span class="rel-item-title" title="${(c.title || '').replace(/"/g, '&quot;')}">${c.title || ''}</span>
                        <span class="rel-item-state"><span class="state-badge ${stateClass}">${c.state || ''}</span></span>
                    </div>
                `;
            }).join('');

            html += `
                <div class="relationship-group children-group">
                    <div class="relationship-group-header">
                        <span class="rel-icon">⬇️</span>
                        <span>Children</span>
                        <span class="rel-count">(${relationships.children.length})</span>
                    </div>
                    <div class="relationship-items">${childrenHtml}</div>
                </div>
            `;
        }

        // Related
        if (hasRelated) {
            const relatedHtml = relationships.related.map(r => {
                const typeClass = (r.type || '').toLowerCase().replace(/\s+/g, '-');
                const stateClass = getStateClass(r.state);
                let itemHtml = `
                    <div class="relationship-item">
                        <span class="rel-item-id"><a href="${r.url}" target="_blank">${r.id}</a></span>
                        <span class="rel-item-type type-${typeClass}">${r.type || ''}</span>
                        <span class="rel-item-title" title="${(r.title || '').replace(/"/g, '&quot;')}">${r.title || ''}</span>
                        <span class="rel-item-state"><span class="state-badge ${stateClass}">${r.state || ''}</span></span>
                    </div>
                `;
                if (r.comment) {
                    itemHtml += `<div class="relationship-comment">${r.comment}</div>`;
                }
                return itemHtml;
            }).join('');

            html += `
                <div class="relationship-group related-group">
                    <div class="relationship-group-header">
                        <span class="rel-icon">🔗</span>
                        <span>Related</span>
                        <span class="rel-count">(${relationships.related.length})</span>
                    </div>
                    <div class="relationship-items">${relatedHtml}</div>
                </div>
            `;
        }

        html += `
                </div>
            </div>
        `;

        return html;
    }

    // Close work item details modal
    function closeWorkItemDetailsModal() {
        const modal = document.getElementById('work-item-details-modal');
        if (modal) {
            modal.style.display = 'none';
        }
    }

    // ==================== END GENERIC TABLE COMPONENT ====================
</script>
